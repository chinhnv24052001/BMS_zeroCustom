//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import { DateTime, Duration } from "luxon";

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IsTenantAvailableOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IsTenantAvailableOutput>;
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resolveTenantId(body: ResolveTenantIdInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResolveTenantId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResolveTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveTenantId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterOutput>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendPasswordResetCode(body: SendPasswordResetCodeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendPasswordResetCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPasswordResetCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendPasswordResetCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordInput | undefined): Observable<ResetPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResetPasswordOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResetPasswordOutput>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResetPasswordOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResetPasswordOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendEmailActivationLink(body: SendEmailActivationLinkInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendEmailActivationLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailActivationLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailActivationLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendEmailActivationLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateEmail(body: ActivateEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/ActivateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    impersonate(body: ImpersonateInput | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Impersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonateOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonateOutput>;
        }));
    }

    protected processImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delegatedImpersonate(body: DelegatedImpersonateInput | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/DelegatedImpersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelegatedImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelegatedImpersonate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonateOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonateOutput>;
        }));
    }

    protected processDelegatedImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(null as any);
    }

    /**
     * @return Success
     */
    backToImpersonator(): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/BackToImpersonator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBackToImpersonator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackToImpersonator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonateOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonateOutput>;
        }));
    }

    protected processBackToImpersonator(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    switchToLinkedAccount(body: SwitchToLinkedAccountInput | undefined): Observable<SwitchToLinkedAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/SwitchToLinkedAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchToLinkedAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchToLinkedAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwitchToLinkedAccountOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwitchToLinkedAccountOutput>;
        }));
    }

    protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SwitchToLinkedAccountOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchToLinkedAccountOutput>(null as any);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogs(startDate: DateTime | undefined, endDate: DateTime | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAuditLogListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogs?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (serviceName !== undefined && serviceName !== null)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&";
        if (methodName !== undefined && methodName !== null)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&";
        if (browserInfo !== undefined && browserInfo !== null)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&";
        if (hasException !== undefined && hasException !== null)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&";
        if (minExecutionDuration !== undefined && minExecutionDuration !== null)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&";
        if (maxExecutionDuration !== undefined && maxExecutionDuration !== null)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAuditLogListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAuditLogListDto>;
        }));
    }

    protected processGetAuditLogs(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAuditLogListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAuditLogListDto>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogsToExcel(startDate: DateTime | undefined, endDate: DateTime | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogsToExcel?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (serviceName !== undefined && serviceName !== null)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&";
        if (methodName !== undefined && methodName !== null)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&";
        if (browserInfo !== undefined && browserInfo !== null)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&";
        if (hasException !== undefined && hasException !== null)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&";
        if (minExecutionDuration !== undefined && minExecutionDuration !== null)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&";
        if (maxExecutionDuration !== undefined && maxExecutionDuration !== null)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }

    /**
     * @return Success
     */
    getEntityHistoryObjectTypes(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityHistoryObjectTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityHistoryObjectTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityHistoryObjectTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NameValueDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NameValueDto[]>;
        }));
    }

    protected processGetEntityHistoryObjectTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChanges(startDate: DateTime | undefined, endDate: DateTime | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChanges?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (entityTypeFullName !== undefined && entityTypeFullName !== null)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChanges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfEntityChangeListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfEntityChangeListDto>;
        }));
    }

    protected processGetEntityChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEntityChangeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(null as any);
    }

    /**
     * @param entityTypeFullName (optional) 
     * @param entityId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityTypeChanges(entityTypeFullName: string | null | undefined, entityId: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityTypeChanges?";
        if (entityTypeFullName !== undefined && entityTypeFullName !== null)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (entityId !== undefined && entityId !== null)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityTypeChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityTypeChanges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfEntityChangeListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfEntityChangeListDto>;
        }));
    }

    protected processGetEntityTypeChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEntityChangeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChangesToExcel(startDate: DateTime | undefined, endDate: DateTime | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChangesToExcel?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (entityTypeFullName !== undefined && entityTypeFullName !== null)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChangesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChangesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetEntityChangesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }

    /**
     * @param entityChangeId (optional) 
     * @return Success
     */
    getEntityPropertyChanges(entityChangeId: number | undefined): Observable<EntityPropertyChangeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityPropertyChanges?";
        if (entityChangeId === null)
            throw new Error("The parameter 'entityChangeId' cannot be null.");
        else if (entityChangeId !== undefined)
            url_ += "entityChangeId=" + encodeURIComponent("" + entityChangeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityPropertyChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityPropertyChanges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityPropertyChangeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityPropertyChangeDto[]>;
        }));
    }

    protected processGetEntityPropertyChanges(response: HttpResponseBase): Observable<EntityPropertyChangeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityPropertyChangeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityPropertyChangeDto[]>(null as any);
    }
}

@Injectable()
export class BmsBudgetPlanReviewServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllColumnByVersionId(id: number | undefined): Observable<BmsColumnDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BmsBudgetPlanReview/GetAllColumnByVersionId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllColumnByVersionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllColumnByVersionId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BmsColumnDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BmsColumnDto[]>;
        }));
    }

    protected processGetAllColumnByVersionId(response: HttpResponseBase): Observable<BmsColumnDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BmsColumnDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BmsColumnDto[]>(null as any);
    }

    /**
     * @param periodId (optional) 
     * @param periodVersionId (optional) 
     * @param groupId (optional) 
     * @param divId (optional) 
     * @param depId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllBudgetPlanReview(periodId: number | null | undefined, periodVersionId: number | null | undefined, groupId: number | null | undefined, divId: number | null | undefined, depId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfBmsBudgetPlanReviewDto> {
        let url_ = this.baseUrl + "/api/services/app/BmsBudgetPlanReview/GetAllBudgetPlanReview?";
        if (periodId !== undefined && periodId !== null)
            url_ += "periodId=" + encodeURIComponent("" + periodId) + "&";
        if (periodVersionId !== undefined && periodVersionId !== null)
            url_ += "periodVersionId=" + encodeURIComponent("" + periodVersionId) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (divId !== undefined && divId !== null)
            url_ += "divId=" + encodeURIComponent("" + divId) + "&";
        if (depId !== undefined && depId !== null)
            url_ += "depId=" + encodeURIComponent("" + depId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBudgetPlanReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBudgetPlanReview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBmsBudgetPlanReviewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBmsBudgetPlanReviewDto>;
        }));
    }

    protected processGetAllBudgetPlanReview(response: HttpResponseBase): Observable<PagedResultDtoOfBmsBudgetPlanReviewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBmsBudgetPlanReviewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBmsBudgetPlanReviewDto>(null as any);
    }
}

@Injectable()
export class BmsBudgetUserControlServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @param manageType (optional) 
     * @return Success
     */
    getAllBudgetForUserCheckBudget(userId: number | undefined, manageType: number | undefined): Observable<BudgetControlOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/BmsBudgetUserControl/getAllBudgetForUserCheckBudget?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (manageType === null)
            throw new Error("The parameter 'manageType' cannot be null.");
        else if (manageType !== undefined)
            url_ += "manageType=" + encodeURIComponent("" + manageType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBudgetForUserCheckBudget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBudgetForUserCheckBudget(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BudgetControlOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BudgetControlOutputDto>;
        }));
    }

    protected processGetAllBudgetForUserCheckBudget(response: HttpResponseBase): Observable<BudgetControlOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BudgetControlOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BudgetControlOutputDto>(null as any);
    }

    /**
     * @return Success
     */
    getAllUserNoPage(): Observable<UserChechBudgetDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BmsBudgetUserControl/getAllUserNoPage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserNoPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserNoPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserChechBudgetDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserChechBudgetDto[]>;
        }));
    }

    protected processGetAllUserNoPage(response: HttpResponseBase): Observable<UserChechBudgetDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserChechBudgetDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserChechBudgetDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUser(body: BmsUserRoleDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BmsBudgetUserControl/SaveUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setUserControlBudget(body: InputSetUserControlBudgetDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BmsBudgetUserControl/SetUserControlBudget";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetUserControlBudget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetUserControlBudget(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetUserControlBudget(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BmsBudgetUserControl/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class BmsMstPairingSegmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstPairingSegment/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param fillterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllPairingSegment(fillterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfBmsMstPairingSegmentDto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstPairingSegment/getAllPairingSegment?";
        if (fillterText !== undefined && fillterText !== null)
            url_ += "FillterText=" + encodeURIComponent("" + fillterText) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPairingSegment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPairingSegment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBmsMstPairingSegmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBmsMstPairingSegmentDto>;
        }));
    }

    protected processGetAllPairingSegment(response: HttpResponseBase): Observable<PagedResultDtoOfBmsMstPairingSegmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBmsMstPairingSegmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBmsMstPairingSegmentDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    loadById(id: number | undefined): Observable<InputPairingSegmentDto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstPairingSegment/LoadById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InputPairingSegmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InputPairingSegmentDto>;
        }));
    }

    protected processLoadById(response: HttpResponseBase): Observable<InputPairingSegmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InputPairingSegmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InputPairingSegmentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: InputPairingSegmentDto | undefined): Observable<ValPairingSegmentDto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstPairingSegment/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValPairingSegmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValPairingSegmentDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<ValPairingSegmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValPairingSegmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValPairingSegmentDto>(null as any);
    }

    /**
     * @return Success
     */
    getAllPairingSegmentNoPage(): Observable<BmsMstPairingSegmentDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstPairingSegment/getAllPairingSegmentNoPage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPairingSegmentNoPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPairingSegmentNoPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BmsMstPairingSegmentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BmsMstPairingSegmentDto[]>;
        }));
    }

    protected processGetAllPairingSegmentNoPage(response: HttpResponseBase): Observable<BmsMstPairingSegmentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BmsMstPairingSegmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BmsMstPairingSegmentDto[]>(null as any);
    }

    /**
     * @return Success
     */
    gatAllBugetPlanForUserControl(): Observable<BmsMstPairingSegmentDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstPairingSegment/gatAllBugetPlanForUserControl";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGatAllBugetPlanForUserControl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGatAllBugetPlanForUserControl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BmsMstPairingSegmentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BmsMstPairingSegmentDto[]>;
        }));
    }

    protected processGatAllBugetPlanForUserControl(response: HttpResponseBase): Observable<BmsMstPairingSegmentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BmsMstPairingSegmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BmsMstPairingSegmentDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDepartmentInfoByBudgetPlan(id: number | undefined): Observable<DepartmentSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstPairingSegment/getDepartmentInfoByBudgetPlan?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartmentInfoByBudgetPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartmentInfoByBudgetPlan(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepartmentSelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepartmentSelectDto>;
        }));
    }

    protected processGetDepartmentInfoByBudgetPlan(response: HttpResponseBase): Observable<DepartmentSelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentSelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentSelectDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveAllImport(body: SegmentReadDataDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstPairingSegment/SaveAllImport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAllImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAllImport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveAllImport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class BmsMstPeriodServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstPeriod/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param periodName (optional) 
     * @param periodYear (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllPeriod(periodName: string | null | undefined, periodYear: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfBmsMstPeriodDto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstPeriod/getAllPeriod?";
        if (periodName !== undefined && periodName !== null)
            url_ += "PeriodName=" + encodeURIComponent("" + periodName) + "&";
        if (periodYear !== undefined && periodYear !== null)
            url_ += "PeriodYear=" + encodeURIComponent("" + periodYear) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPeriod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPeriod(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBmsMstPeriodDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBmsMstPeriodDto>;
        }));
    }

    protected processGetAllPeriod(response: HttpResponseBase): Observable<PagedResultDtoOfBmsMstPeriodDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBmsMstPeriodDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBmsMstPeriodDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    loadById(id: number | undefined): Observable<InputBmsMstPeriodDto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstPeriod/LoadById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InputBmsMstPeriodDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InputBmsMstPeriodDto>;
        }));
    }

    protected processLoadById(response: HttpResponseBase): Observable<InputBmsMstPeriodDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InputBmsMstPeriodDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InputBmsMstPeriodDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: InputBmsMstPeriodDto | undefined): Observable<ValPeriodSaveDto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstPeriod/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValPeriodSaveDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValPeriodSaveDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<ValPeriodSaveDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValPeriodSaveDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValPeriodSaveDto>(null as any);
    }

    /**
     * @param periodName (optional) 
     * @param periodYear (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllBmsPeriodNoPage(periodName: string | null | undefined, periodYear: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<BmsMstPeriodDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstPeriod/GetAllBmsPeriodNoPage?";
        if (periodName !== undefined && periodName !== null)
            url_ += "PeriodName=" + encodeURIComponent("" + periodName) + "&";
        if (periodYear !== undefined && periodYear !== null)
            url_ += "PeriodYear=" + encodeURIComponent("" + periodYear) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBmsPeriodNoPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBmsPeriodNoPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BmsMstPeriodDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BmsMstPeriodDto[]>;
        }));
    }

    protected processGetAllBmsPeriodNoPage(response: HttpResponseBase): Observable<BmsMstPeriodDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BmsMstPeriodDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BmsMstPeriodDto[]>(null as any);
    }

    /**
     * @param periodName (optional) 
     * @param periodYear (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPeriodToExcel(periodName: string | null | undefined, periodYear: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstPeriod/GetPeriodToExcel?";
        if (periodName !== undefined && periodName !== null)
            url_ += "PeriodName=" + encodeURIComponent("" + periodName) + "&";
        if (periodYear !== undefined && periodYear !== null)
            url_ += "PeriodYear=" + encodeURIComponent("" + periodYear) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPeriodToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPeriodToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetPeriodToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class BmsMstSegment1ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment1/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param periodId (optional) 
     * @param name (optional) 
     * @param code (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllSegment1(periodId: number | undefined, name: string | null | undefined, code: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfMstSegment1Dto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment1/getAllSegment1?";
        if (periodId === null)
            throw new Error("The parameter 'periodId' cannot be null.");
        else if (periodId !== undefined)
            url_ += "PeriodId=" + encodeURIComponent("" + periodId) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSegment1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSegment1(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMstSegment1Dto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMstSegment1Dto>;
        }));
    }

    protected processGetAllSegment1(response: HttpResponseBase): Observable<PagedResultDtoOfMstSegment1Dto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMstSegment1Dto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMstSegment1Dto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    loadById(id: number | undefined): Observable<InputSegment1Dto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment1/LoadById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InputSegment1Dto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InputSegment1Dto>;
        }));
    }

    protected processLoadById(response: HttpResponseBase): Observable<InputSegment1Dto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InputSegment1Dto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InputSegment1Dto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: InputSegment1Dto | undefined): Observable<ValSegment1SaveDto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment1/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValSegment1SaveDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValSegment1SaveDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<ValSegment1SaveDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValSegment1SaveDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValSegment1SaveDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveAllImport(body: SegmentReadDataDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment1/SaveAllImport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAllImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAllImport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveAllImport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getAllSegment1NoPage(): Observable<MstSegment1Dto[]> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment1/getAllSegment1NoPage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSegment1NoPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSegment1NoPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MstSegment1Dto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MstSegment1Dto[]>;
        }));
    }

    protected processGetAllSegment1NoPage(response: HttpResponseBase): Observable<MstSegment1Dto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MstSegment1Dto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MstSegment1Dto[]>(null as any);
    }
}

@Injectable()
export class BmsMstSegment1TypeCostServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment1TypeCost/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param typeCostName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllTypeCost(typeCostName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTypeCostDto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment1TypeCost/getAllTypeCost?";
        if (typeCostName !== undefined && typeCostName !== null)
            url_ += "TypeCostName=" + encodeURIComponent("" + typeCostName) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTypeCost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTypeCost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTypeCostDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTypeCostDto>;
        }));
    }

    protected processGetAllTypeCost(response: HttpResponseBase): Observable<PagedResultDtoOfTypeCostDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTypeCostDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTypeCostDto>(null as any);
    }

    /**
     * @return Success
     */
    getListSegment1TypeCosts(): Observable<MstSegment1TypeCostDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment1TypeCost/GetListSegment1TypeCosts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListSegment1TypeCosts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListSegment1TypeCosts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MstSegment1TypeCostDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MstSegment1TypeCostDto[]>;
        }));
    }

    protected processGetListSegment1TypeCosts(response: HttpResponseBase): Observable<MstSegment1TypeCostDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MstSegment1TypeCostDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MstSegment1TypeCostDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    loadById(id: number | undefined): Observable<InputTypeCostDto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment1TypeCost/LoadById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InputTypeCostDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InputTypeCostDto>;
        }));
    }

    protected processLoadById(response: HttpResponseBase): Observable<InputTypeCostDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InputTypeCostDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InputTypeCostDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: InputTypeCostDto | undefined): Observable<ValSegment1SaveDto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment1TypeCost/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValSegment1SaveDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValSegment1SaveDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<ValSegment1SaveDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValSegment1SaveDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValSegment1SaveDto>(null as any);
    }
}

@Injectable()
export class BmsMstSegment2ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param periodId (optional) 
     * @param name (optional) 
     * @param code (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllSegment2(periodId: number | undefined, name: string | null | undefined, code: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfMstSegment2Dto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment2/getAllSegment2?";
        if (periodId === null)
            throw new Error("The parameter 'periodId' cannot be null.");
        else if (periodId !== undefined)
            url_ += "PeriodId=" + encodeURIComponent("" + periodId) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSegment2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSegment2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMstSegment2Dto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMstSegment2Dto>;
        }));
    }

    protected processGetAllSegment2(response: HttpResponseBase): Observable<PagedResultDtoOfMstSegment2Dto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMstSegment2Dto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMstSegment2Dto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    loadById(id: number | undefined): Observable<InputSegment2Dto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment2/LoadById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InputSegment2Dto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InputSegment2Dto>;
        }));
    }

    protected processLoadById(response: HttpResponseBase): Observable<InputSegment2Dto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InputSegment2Dto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InputSegment2Dto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: InputSegment2Dto | undefined): Observable<ValSegment2Dto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment2/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValSegment2Dto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValSegment2Dto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<ValSegment2Dto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValSegment2Dto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValSegment2Dto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment2/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveAllImport(body: SegmentReadDataDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment2/SaveAllImport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAllImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAllImport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveAllImport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getAllSegment2NoPage(): Observable<MstSegment2Dto[]> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment2/getAllSegment2NoPage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSegment2NoPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSegment2NoPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MstSegment2Dto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MstSegment2Dto[]>;
        }));
    }

    protected processGetAllSegment2NoPage(response: HttpResponseBase): Observable<MstSegment2Dto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MstSegment2Dto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MstSegment2Dto[]>(null as any);
    }
}

@Injectable()
export class BmsMstSegment2ProjectTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment2ProjectType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param projectTypeName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllProjectType(projectTypeName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfProjectTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment2ProjectType/getAllProjectType?";
        if (projectTypeName !== undefined && projectTypeName !== null)
            url_ += "ProjectTypeName=" + encodeURIComponent("" + projectTypeName) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProjectType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProjectType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfProjectTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfProjectTypeDto>;
        }));
    }

    protected processGetAllProjectType(response: HttpResponseBase): Observable<PagedResultDtoOfProjectTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProjectTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProjectTypeDto>(null as any);
    }

    /**
     * @return Success
     */
    getListSegment2ProjectTypes(): Observable<MstSegment2ProjectTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment2ProjectType/GetListSegment2ProjectTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListSegment2ProjectTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListSegment2ProjectTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MstSegment2ProjectTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MstSegment2ProjectTypeDto[]>;
        }));
    }

    protected processGetListSegment2ProjectTypes(response: HttpResponseBase): Observable<MstSegment2ProjectTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MstSegment2ProjectTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MstSegment2ProjectTypeDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    loadById(id: number | undefined): Observable<InputProjectTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment2ProjectType/LoadById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InputProjectTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InputProjectTypeDto>;
        }));
    }

    protected processLoadById(response: HttpResponseBase): Observable<InputProjectTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InputProjectTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InputProjectTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: InputProjectTypeDto | undefined): Observable<ValSegment2Dto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment2ProjectType/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValSegment2Dto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValSegment2Dto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<ValSegment2Dto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValSegment2Dto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValSegment2Dto>(null as any);
    }
}

@Injectable()
export class BmsMstSegment3ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment3/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param divisionId (optional) 
     * @return Success
     */
    getAllDepartmentByDevisionNoPage(divisionId: number | undefined): Observable<DepartmentSelectDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment3/GetAllDepartmentByDevisionNoPage?";
        if (divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (divisionId !== undefined)
            url_ += "divisionId=" + encodeURIComponent("" + divisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDepartmentByDevisionNoPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDepartmentByDevisionNoPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepartmentSelectDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepartmentSelectDto[]>;
        }));
    }

    protected processGetAllDepartmentByDevisionNoPage(response: HttpResponseBase): Observable<DepartmentSelectDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DepartmentSelectDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentSelectDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllDivisionNoPage(): Observable<DivisionSelectDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment3/GetAllDivisionNoPage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDivisionNoPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDivisionNoPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DivisionSelectDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DivisionSelectDto[]>;
        }));
    }

    protected processGetAllDivisionNoPage(response: HttpResponseBase): Observable<DivisionSelectDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DivisionSelectDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DivisionSelectDto[]>(null as any);
    }

    /**
     * @param periodId (optional) 
     * @param name (optional) 
     * @param code (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllSegment3(periodId: number | undefined, name: string | null | undefined, code: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfMstSegment3Dto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment3/getAllSegment3?";
        if (periodId === null)
            throw new Error("The parameter 'periodId' cannot be null.");
        else if (periodId !== undefined)
            url_ += "PeriodId=" + encodeURIComponent("" + periodId) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSegment3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSegment3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMstSegment3Dto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMstSegment3Dto>;
        }));
    }

    protected processGetAllSegment3(response: HttpResponseBase): Observable<PagedResultDtoOfMstSegment3Dto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMstSegment3Dto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMstSegment3Dto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    loadById(id: number | undefined): Observable<InputSegment3Dto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment3/LoadById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InputSegment3Dto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InputSegment3Dto>;
        }));
    }

    protected processLoadById(response: HttpResponseBase): Observable<InputSegment3Dto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InputSegment3Dto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InputSegment3Dto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: InputSegment3Dto | undefined): Observable<ValSegment3Dto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment3/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValSegment3Dto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValSegment3Dto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<ValSegment3Dto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValSegment3Dto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValSegment3Dto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveAllImport(body: SegmentReadDataDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment3/SaveAllImport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAllImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAllImport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveAllImport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getAllSegment3NoPage(): Observable<MstSegment3Dto[]> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment3/getAllSegment3NoPage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSegment3NoPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSegment3NoPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MstSegment3Dto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MstSegment3Dto[]>;
        }));
    }

    protected processGetAllSegment3NoPage(response: HttpResponseBase): Observable<MstSegment3Dto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MstSegment3Dto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MstSegment3Dto[]>(null as any);
    }
}

@Injectable()
export class BmsMstSegment4ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param periodId (optional) 
     * @param name (optional) 
     * @param code (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllSegment4(periodId: number | undefined, name: string | null | undefined, code: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfMstSegment4Dto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment4/getAllSegment4?";
        if (periodId === null)
            throw new Error("The parameter 'periodId' cannot be null.");
        else if (periodId !== undefined)
            url_ += "PeriodId=" + encodeURIComponent("" + periodId) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSegment4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSegment4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMstSegment4Dto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMstSegment4Dto>;
        }));
    }

    protected processGetAllSegment4(response: HttpResponseBase): Observable<PagedResultDtoOfMstSegment4Dto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMstSegment4Dto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMstSegment4Dto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    loadById(id: number | undefined): Observable<InputSegment4Dto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment4/LoadById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InputSegment4Dto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InputSegment4Dto>;
        }));
    }

    protected processLoadById(response: HttpResponseBase): Observable<InputSegment4Dto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InputSegment4Dto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InputSegment4Dto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: InputSegment4Dto | undefined): Observable<ValSegment4Dto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment4/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValSegment4Dto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValSegment4Dto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<ValSegment4Dto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValSegment4Dto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValSegment4Dto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment4/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveAllImport(body: SegmentReadDataDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment4/SaveAllImport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAllImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAllImport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveAllImport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getAllSegment4NoPage(): Observable<MstSegment4Dto[]> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment4/getAllSegment4NoPage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSegment4NoPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSegment4NoPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MstSegment4Dto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MstSegment4Dto[]>;
        }));
    }

    protected processGetAllSegment4NoPage(response: HttpResponseBase): Observable<MstSegment4Dto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MstSegment4Dto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MstSegment4Dto[]>(null as any);
    }
}

@Injectable()
export class BmsMstSegment4GroupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment4Group/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param groupName (optional) 
     * @param periodId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllSegment4Group(groupName: string | null | undefined, periodId: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfMstSegment4GroupDto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment4Group/getAllSegment4Group?";
        if (groupName !== undefined && groupName !== null)
            url_ += "GroupName=" + encodeURIComponent("" + groupName) + "&";
        if (periodId === null)
            throw new Error("The parameter 'periodId' cannot be null.");
        else if (periodId !== undefined)
            url_ += "PeriodId=" + encodeURIComponent("" + periodId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSegment4Group(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSegment4Group(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMstSegment4GroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMstSegment4GroupDto>;
        }));
    }

    protected processGetAllSegment4Group(response: HttpResponseBase): Observable<PagedResultDtoOfMstSegment4GroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMstSegment4GroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMstSegment4GroupDto>(null as any);
    }

    /**
     * @return Success
     */
    getListSegment4Groups(): Observable<MstSegment4GroupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment4Group/GetListSegment4Groups";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListSegment4Groups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListSegment4Groups(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MstSegment4GroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MstSegment4GroupDto[]>;
        }));
    }

    protected processGetListSegment4Groups(response: HttpResponseBase): Observable<MstSegment4GroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MstSegment4GroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MstSegment4GroupDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    loadById(id: number | undefined): Observable<InputSegment4GroupDto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment4Group/LoadById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InputSegment4GroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InputSegment4GroupDto>;
        }));
    }

    protected processLoadById(response: HttpResponseBase): Observable<InputSegment4GroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InputSegment4GroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InputSegment4GroupDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: InputSegment4GroupDto | undefined): Observable<ValSegment4Dto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment4Group/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValSegment4Dto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValSegment4Dto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<ValSegment4Dto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValSegment4Dto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValSegment4Dto>(null as any);
    }
}

@Injectable()
export class BmsMstSegment5ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment5/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param periodId (optional) 
     * @param name (optional) 
     * @param code (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllSegment5(periodId: number | undefined, name: string | null | undefined, code: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfMstSegment5Dto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment5/getAllSegment5?";
        if (periodId === null)
            throw new Error("The parameter 'periodId' cannot be null.");
        else if (periodId !== undefined)
            url_ += "PeriodId=" + encodeURIComponent("" + periodId) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSegment5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSegment5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMstSegment5Dto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMstSegment5Dto>;
        }));
    }

    protected processGetAllSegment5(response: HttpResponseBase): Observable<PagedResultDtoOfMstSegment5Dto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMstSegment5Dto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMstSegment5Dto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    loadById(id: number | undefined): Observable<InputSegment5Dto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment5/LoadById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InputSegment5Dto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InputSegment5Dto>;
        }));
    }

    protected processLoadById(response: HttpResponseBase): Observable<InputSegment5Dto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InputSegment5Dto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InputSegment5Dto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: InputSegment5Dto | undefined): Observable<ValSegment5Dto> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment5/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValSegment5Dto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValSegment5Dto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<ValSegment5Dto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValSegment5Dto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValSegment5Dto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveAllImport(body: SegmentReadDataDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment5/SaveAllImport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAllImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAllImport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveAllImport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getAllSegment5NoPage(): Observable<MstSegment5Dto[]> {
        let url_ = this.baseUrl + "/api/services/app/BmsMstSegment5/getAllSegment5NoPage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSegment5NoPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSegment5NoPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MstSegment5Dto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MstSegment5Dto[]>;
        }));
    }

    protected processGetAllSegment5NoPage(response: HttpResponseBase): Observable<MstSegment5Dto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MstSegment5Dto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MstSegment5Dto[]>(null as any);
    }
}

@Injectable()
export class BmsPeriodVersionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BmsPeriodVersion/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param periodId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllVersionByPeriodId(periodId: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfBmsPeriodVersionDto> {
        let url_ = this.baseUrl + "/api/services/app/BmsPeriodVersion/getAllVersionByPeriodId?";
        if (periodId === null)
            throw new Error("The parameter 'periodId' cannot be null.");
        else if (periodId !== undefined)
            url_ += "PeriodId=" + encodeURIComponent("" + periodId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVersionByPeriodId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVersionByPeriodId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBmsPeriodVersionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBmsPeriodVersionDto>;
        }));
    }

    protected processGetAllVersionByPeriodId(response: HttpResponseBase): Observable<PagedResultDtoOfBmsPeriodVersionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBmsPeriodVersionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBmsPeriodVersionDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllVersionByPeriodIdNoPage(id: number | undefined): Observable<BmsPeriodVersionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BmsPeriodVersion/getAllVersionByPeriodIdNoPage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVersionByPeriodIdNoPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVersionByPeriodIdNoPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BmsPeriodVersionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BmsPeriodVersionDto[]>;
        }));
    }

    protected processGetAllVersionByPeriodIdNoPage(response: HttpResponseBase): Observable<BmsPeriodVersionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BmsPeriodVersionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BmsPeriodVersionDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllMstVersionNoPage(): Observable<MstVersionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BmsPeriodVersion/getAllMstVersionNoPage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMstVersionNoPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMstVersionNoPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MstVersionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MstVersionDto[]>;
        }));
    }

    protected processGetAllMstVersionNoPage(response: HttpResponseBase): Observable<MstVersionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MstVersionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MstVersionDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    loadById(id: number | undefined): Observable<InputPeriodVersionDto> {
        let url_ = this.baseUrl + "/api/services/app/BmsPeriodVersion/LoadById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InputPeriodVersionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InputPeriodVersionDto>;
        }));
    }

    protected processLoadById(response: HttpResponseBase): Observable<InputPeriodVersionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InputPeriodVersionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InputPeriodVersionDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: InputPeriodVersionDto | undefined): Observable<ValPeriodSaveDto> {
        let url_ = this.baseUrl + "/api/services/app/BmsPeriodVersion/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValPeriodSaveDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValPeriodSaveDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<ValPeriodSaveDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValPeriodSaveDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValPeriodSaveDto>(null as any);
    }

    /**
     * @param periodId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPeriodVersionToExcel(periodId: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/BmsPeriodVersion/GetPeriodVersionToExcel?";
        if (periodId === null)
            throw new Error("The parameter 'periodId' cannot be null.");
        else if (periodId !== undefined)
            url_ += "PeriodId=" + encodeURIComponent("" + periodId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPeriodVersionToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPeriodVersionToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetPeriodVersionToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    getAllPersiodAndVersion(): Observable<PeriodAndVersionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BmsPeriodVersion/GetAllPersiodAndVersion";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPersiodAndVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPersiodAndVersion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PeriodAndVersionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PeriodAndVersionDto[]>;
        }));
    }

    protected processGetAllPersiodAndVersion(response: HttpResponseBase): Observable<PeriodAndVersionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PeriodAndVersionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PeriodAndVersionDto[]>(null as any);
    }
}

@Injectable()
export class BudgetTransferServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BudgetTransfer/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param periodId (optional) 
     * @param periodVersionId (optional) 
     * @param tabKey (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllBudgetTransfer(periodId: number | undefined, periodVersionId: number | undefined, tabKey: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfBudgetTransferDto> {
        let url_ = this.baseUrl + "/api/services/app/BudgetTransfer/getAllBudgetTransfer?";
        if (periodId === null)
            throw new Error("The parameter 'periodId' cannot be null.");
        else if (periodId !== undefined)
            url_ += "PeriodId=" + encodeURIComponent("" + periodId) + "&";
        if (periodVersionId === null)
            throw new Error("The parameter 'periodVersionId' cannot be null.");
        else if (periodVersionId !== undefined)
            url_ += "PeriodVersionId=" + encodeURIComponent("" + periodVersionId) + "&";
        if (tabKey === null)
            throw new Error("The parameter 'tabKey' cannot be null.");
        else if (tabKey !== undefined)
            url_ += "TabKey=" + encodeURIComponent("" + tabKey) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBudgetTransfer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBudgetTransfer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBudgetTransferDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBudgetTransferDto>;
        }));
    }

    protected processGetAllBudgetTransfer(response: HttpResponseBase): Observable<PagedResultDtoOfBudgetTransferDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBudgetTransferDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBudgetTransferDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    loadById(id: number | undefined): Observable<InputBudgetTransferDto> {
        let url_ = this.baseUrl + "/api/services/app/BudgetTransfer/LoadById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InputBudgetTransferDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InputBudgetTransferDto>;
        }));
    }

    protected processLoadById(response: HttpResponseBase): Observable<InputBudgetTransferDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InputBudgetTransferDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InputBudgetTransferDto>(null as any);
    }

    /**
     * @return Success
     */
    genarateTransferNo(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/BudgetTransfer/GenarateTransferNo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenarateTransferNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenarateTransferNo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGenarateTransferNo(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: InputBudgetTransferDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BudgetTransfer/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getUserInfoToTransferBudget(): Observable<UserInfoToTransferBudgetDto> {
        let url_ = this.baseUrl + "/api/services/app/BudgetTransfer/getUserInfoToTransferBudget";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInfoToTransferBudget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInfoToTransferBudget(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInfoToTransferBudgetDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInfoToTransferBudgetDto>;
        }));
    }

    protected processGetUserInfoToTransferBudget(response: HttpResponseBase): Observable<UserInfoToTransferBudgetDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserInfoToTransferBudgetDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserInfoToTransferBudgetDto>(null as any);
    }

    /**
     * @param depId (optional) 
     * @return Success
     */
    getListUserInfoDtopdownToTransferBudget(depId: number | undefined): Observable<UserInfoToTransferBudgetDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BudgetTransfer/getListUserInfoDtopdownToTransferBudget?";
        if (depId === null)
            throw new Error("The parameter 'depId' cannot be null.");
        else if (depId !== undefined)
            url_ += "DepId=" + encodeURIComponent("" + depId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListUserInfoDtopdownToTransferBudget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListUserInfoDtopdownToTransferBudget(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInfoToTransferBudgetDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInfoToTransferBudgetDto[]>;
        }));
    }

    protected processGetListUserInfoDtopdownToTransferBudget(response: HttpResponseBase): Observable<UserInfoToTransferBudgetDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserInfoToTransferBudgetDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserInfoToTransferBudgetDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approvalAndSubmit(body: ApprovalTransferBudgetDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BudgetTransfer/ApprovalAndSubmit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApprovalAndSubmit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApprovalAndSubmit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processApprovalAndSubmit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reject(body: ApprovalTransferBudgetDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BudgetTransfer/Reject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReject(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    lastApproval(body: BmsTransferBudget | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BudgetTransfer/LastApproval";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLastApproval(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLastApproval(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLastApproval(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    isMAFinUser(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BudgetTransfer/IsMAFinUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsMAFinUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsMAFinUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsMAFinUser(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param transferBudgetId (optional) 
     * @return Success
     */
    isGroupReceived(transferBudgetId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BudgetTransfer/IsGroupReceived?";
        if (transferBudgetId === null)
            throw new Error("The parameter 'transferBudgetId' cannot be null.");
        else if (transferBudgetId !== undefined)
            url_ += "transferBudgetId=" + encodeURIComponent("" + transferBudgetId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsGroupReceived(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsGroupReceived(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsGroupReceived(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

@Injectable()
export class CachingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCaches(): Observable<ListResultDtoOfCacheDto> {
        let url_ = this.baseUrl + "/api/services/app/Caching/GetAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCaches(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfCacheDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfCacheDto>;
        }));
    }

    protected processGetAllCaches(response: HttpResponseBase): Observable<ListResultDtoOfCacheDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfCacheDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfCacheDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clearCache(body: EntityDtoOfString | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllCaches(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class CfgEmailTemplateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param emailTemplateCode (optional) 
     * @return Success
     */
    getTemplateByCode(emailTemplateCode: string | null | undefined): Observable<EmailTemplateOuputDto> {
        let url_ = this.baseUrl + "/api/services/app/CfgEmailTemplate/GetTemplateByCode?";
        if (emailTemplateCode !== undefined && emailTemplateCode !== null)
            url_ += "emailTemplateCode=" + encodeURIComponent("" + emailTemplateCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateByCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmailTemplateOuputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmailTemplateOuputDto>;
        }));
    }

    protected processGetTemplateByCode(response: HttpResponseBase): Observable<EmailTemplateOuputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailTemplateOuputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailTemplateOuputDto>(null as any);
    }
}

@Injectable()
export class CfgGenerateReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param reportCode (optional) 
     * @param body (optional) 
     * @return Success
     */
    createReport(reportCode: string | null | undefined, body: any | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CfgGenerateReport/CreateReport?";
        if (reportCode !== undefined && reportCode !== null)
            url_ += "ReportCode=" + encodeURIComponent("" + reportCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param anyValue (optional) 
     * @param body (optional) 
     * @return Success
     */
    formatAllData(anyValue: string | null | undefined, body: PropertyInfo | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CfgGenerateReport/FormatAllData?";
        if (anyValue !== undefined && anyValue !== null)
            url_ += "anyValue=" + encodeURIComponent("" + anyValue) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFormatAllData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFormatAllData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processFormatAllData(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param _amount (optional) 
     * @return Success
     */
    formattedAmount(_amount: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CfgGenerateReport/FormattedAmount?";
        if (_amount !== undefined && _amount !== null)
            url_ += "_amount=" + encodeURIComponent("" + _amount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFormattedAmount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFormattedAmount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processFormattedAmount(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class ChatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserChatFriendsWithSettings(): Observable<GetUserChatFriendsWithSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatFriendsWithSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatFriendsWithSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatFriendsWithSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserChatFriendsWithSettingsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserChatFriendsWithSettingsOutput>;
        }));
    }

    protected processGetUserChatFriendsWithSettings(response: HttpResponseBase): Observable<GetUserChatFriendsWithSettingsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserChatFriendsWithSettingsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserChatFriendsWithSettingsOutput>(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @param userId (optional) 
     * @param minMessageId (optional) 
     * @return Success
     */
    getUserChatMessages(tenantId: number | null | undefined, userId: number | undefined, minMessageId: number | null | undefined): Observable<ListResultDtoOfChatMessageDto> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatMessages?";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (minMessageId !== undefined && minMessageId !== null)
            url_ += "MinMessageId=" + encodeURIComponent("" + minMessageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatMessages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfChatMessageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfChatMessageDto>;
        }));
    }

    protected processGetUserChatMessages(response: HttpResponseBase): Observable<ListResultDtoOfChatMessageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfChatMessageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfChatMessageDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    markAllUnreadMessagesOfUserAsRead(body: MarkAllUnreadMessagesOfUserAsReadInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Chat/MarkAllUnreadMessagesOfUserAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAllUnreadMessagesOfUserAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllUnreadMessagesOfUserAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMarkAllUnreadMessagesOfUserAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class CommonGeneralCacheServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllInventoryGroups(): Observable<CommonAllInventoryGroup[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/GetAllInventoryGroups";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInventoryGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInventoryGroups(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonAllInventoryGroup[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonAllInventoryGroup[]>;
        }));
    }

    protected processGetAllInventoryGroups(response: HttpResponseBase): Observable<CommonAllInventoryGroup[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonAllInventoryGroup.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonAllInventoryGroup[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllCurrencies(): Observable<CommonAllCurrency[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/GetAllCurrencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCurrencies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCurrencies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonAllCurrency[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonAllCurrency[]>;
        }));
    }

    protected processGetAllCurrencies(response: HttpResponseBase): Observable<CommonAllCurrency[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonAllCurrency.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonAllCurrency[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllSuppliers(): Observable<CommonAllSupplier[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/GetAllSuppliers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSuppliers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSuppliers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonAllSupplier[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonAllSupplier[]>;
        }));
    }

    protected processGetAllSuppliers(response: HttpResponseBase): Observable<CommonAllSupplier[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonAllSupplier.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonAllSupplier[]>(null as any);
    }

    /**
     * @param supplierId (optional) 
     * @return Success
     */
    getAllSupplierSitesBySupplerId(supplierId: number | undefined): Observable<CommonAllSupplierSite[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/GetAllSupplierSitesBySupplerId?";
        if (supplierId === null)
            throw new Error("The parameter 'supplierId' cannot be null.");
        else if (supplierId !== undefined)
            url_ += "supplierId=" + encodeURIComponent("" + supplierId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSupplierSitesBySupplerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSupplierSitesBySupplerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonAllSupplierSite[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonAllSupplierSite[]>;
        }));
    }

    protected processGetAllSupplierSitesBySupplerId(response: HttpResponseBase): Observable<CommonAllSupplierSite[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonAllSupplierSite.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonAllSupplierSite[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllSupplierSites(): Observable<CommonAllSupplierSite[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/GetAllSupplierSites";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSupplierSites(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSupplierSites(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonAllSupplierSite[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonAllSupplierSite[]>;
        }));
    }

    protected processGetAllSupplierSites(response: HttpResponseBase): Observable<CommonAllSupplierSite[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonAllSupplierSite.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonAllSupplierSite[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllLineTypes(): Observable<CommonAllLineType[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/GetAllLineTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLineTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLineTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonAllLineType[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonAllLineType[]>;
        }));
    }

    protected processGetAllLineTypes(response: HttpResponseBase): Observable<CommonAllLineType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonAllLineType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonAllLineType[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllLocations(): Observable<GetMstLocationsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/getAllLocations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLocations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLocations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMstLocationsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMstLocationsDto[]>;
        }));
    }

    protected processGetAllLocations(response: HttpResponseBase): Observable<GetMstLocationsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetMstLocationsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMstLocationsDto[]>(null as any);
    }

    /**
     * @param supplierSiteId (optional) 
     * @return Success
     */
    getAllSupplierContact(supplierSiteId: number | undefined): Observable<CommonAllSupplierContacts[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/GetAllSupplierContact?";
        if (supplierSiteId === null)
            throw new Error("The parameter 'supplierSiteId' cannot be null.");
        else if (supplierSiteId !== undefined)
            url_ += "supplierSiteId=" + encodeURIComponent("" + supplierSiteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSupplierContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSupplierContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonAllSupplierContacts[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonAllSupplierContacts[]>;
        }));
    }

    protected processGetAllSupplierContact(response: HttpResponseBase): Observable<CommonAllSupplierContacts[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonAllSupplierContacts.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonAllSupplierContacts[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllUsersInfo(): Observable<GetRequesterDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/getAllUsersInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsersInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsersInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRequesterDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRequesterDto[]>;
        }));
    }

    protected processGetAllUsersInfo(response: HttpResponseBase): Observable<GetRequesterDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetRequesterDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRequesterDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllPurchasePurpose(): Observable<CommonAllPurchasePurpose[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/GetAllPurchasePurpose";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPurchasePurpose(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPurchasePurpose(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonAllPurchasePurpose[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonAllPurchasePurpose[]>;
        }));
    }

    protected processGetAllPurchasePurpose(response: HttpResponseBase): Observable<CommonAllPurchasePurpose[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonAllPurchasePurpose.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonAllPurchasePurpose[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllDepartments(): Observable<CommonAllDepartment[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/GetAllDepartments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDepartments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDepartments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonAllDepartment[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonAllDepartment[]>;
        }));
    }

    protected processGetAllDepartments(response: HttpResponseBase): Observable<CommonAllDepartment[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonAllDepartment.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonAllDepartment[]>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getRequesterInfo(userId: number | undefined): Observable<GetRequesterInfoForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/GetRequesterInfo?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequesterInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequesterInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRequesterInfoForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRequesterInfoForViewDto>;
        }));
    }

    protected processGetRequesterInfo(response: HttpResponseBase): Observable<GetRequesterInfoForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRequesterInfoForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRequesterInfoForViewDto>(null as any);
    }

    /**
     * @param budgetCode (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllGlCodeCombinations(budgetCode: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfCommonAllGlCodeCombination> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/GetAllGlCodeCombinations?";
        if (budgetCode !== undefined && budgetCode !== null)
            url_ += "BudgetCode=" + encodeURIComponent("" + budgetCode) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllGlCodeCombinations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGlCodeCombinations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfCommonAllGlCodeCombination>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfCommonAllGlCodeCombination>;
        }));
    }

    protected processGetAllGlCodeCombinations(response: HttpResponseBase): Observable<PagedResultDtoOfCommonAllGlCodeCombination> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCommonAllGlCodeCombination.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCommonAllGlCodeCombination>(null as any);
    }

    /**
     * @return Success
     */
    getAllProcessType(): Observable<CommonAllProcessType[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/GetAllProcessType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProcessType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProcessType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonAllProcessType[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonAllProcessType[]>;
        }));
    }

    protected processGetAllProcessType(response: HttpResponseBase): Observable<CommonAllProcessType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonAllProcessType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonAllProcessType[]>(null as any);
    }

    /**
     * @param partNo (optional) 
     * @return Success
     */
    getListOrgzationsByPartNo(partNo: string | null | undefined): Observable<GetMstOrganizationsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/getListOrgzationsByPartNo?";
        if (partNo !== undefined && partNo !== null)
            url_ += "partNo=" + encodeURIComponent("" + partNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListOrgzationsByPartNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListOrgzationsByPartNo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMstOrganizationsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMstOrganizationsDto[]>;
        }));
    }

    protected processGetListOrgzationsByPartNo(response: HttpResponseBase): Observable<GetMstOrganizationsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetMstOrganizationsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMstOrganizationsDto[]>(null as any);
    }

    /**
     * @param inventoryGroupId (optional) 
     * @param supplierId (optional) 
     * @param currencyCode (optional) 
     * @param partNo (optional) 
     * @param documentDate (optional) 
     * @return Success
     */
    getAllInventoryItemsByGroup(inventoryGroupId: number | null | undefined, supplierId: number | null | undefined, currencyCode: string | null | undefined, partNo: string | null | undefined, documentDate: DateTime | null | undefined): Observable<GetMstInventoryItemsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/getAllInventoryItemsByGroup?";
        if (inventoryGroupId !== undefined && inventoryGroupId !== null)
            url_ += "InventoryGroupId=" + encodeURIComponent("" + inventoryGroupId) + "&";
        if (supplierId !== undefined && supplierId !== null)
            url_ += "SupplierId=" + encodeURIComponent("" + supplierId) + "&";
        if (currencyCode !== undefined && currencyCode !== null)
            url_ += "CurrencyCode=" + encodeURIComponent("" + currencyCode) + "&";
        if (partNo !== undefined && partNo !== null)
            url_ += "PartNo=" + encodeURIComponent("" + partNo) + "&";
        if (documentDate !== undefined && documentDate !== null)
            url_ += "DocumentDate=" + encodeURIComponent(documentDate ? "" + documentDate.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInventoryItemsByGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInventoryItemsByGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMstInventoryItemsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMstInventoryItemsDto[]>;
        }));
    }

    protected processGetAllInventoryItemsByGroup(response: HttpResponseBase): Observable<GetMstInventoryItemsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetMstInventoryItemsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMstInventoryItemsDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getGlCombaination(): Observable<SearchGlCodeOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/getGlCombaination";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGlCombaination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGlCombaination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SearchGlCodeOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SearchGlCodeOutputDto>;
        }));
    }

    protected processGetGlCombaination(response: HttpResponseBase): Observable<SearchGlCodeOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchGlCodeOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchGlCodeOutputDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param type (optional) 
     * @return Success
     */
    getListReference(id: number | undefined, type: string | null | undefined): Observable<CommonGetReferencecs[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/getListReference?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListReference(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListReference(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonGetReferencecs[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonGetReferencecs[]>;
        }));
    }

    protected processGetListReference(response: HttpResponseBase): Observable<CommonGetReferencecs[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonGetReferencecs.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonGetReferencecs[]>(null as any);
    }

    /**
     * @param lookupType (optional) 
     * @return Success
     */
    getLookupsBy(lookupType: string | null | undefined): Observable<CommonLookupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/getLookupsBy?";
        if (lookupType !== undefined && lookupType !== null)
            url_ += "lookupType=" + encodeURIComponent("" + lookupType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLookupsBy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLookupsBy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonLookupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonLookupDto[]>;
        }));
    }

    protected processGetLookupsBy(response: HttpResponseBase): Observable<CommonLookupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonLookupDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllPaymentTerms(): Observable<CommonPaymentTermsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/getAllPaymentTerms";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPaymentTerms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPaymentTerms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonPaymentTermsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonPaymentTermsDto[]>;
        }));
    }

    protected processGetAllPaymentTerms(response: HttpResponseBase): Observable<CommonPaymentTermsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonPaymentTermsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonPaymentTermsDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    geUserById(id: number | undefined): Observable<GetRequesterDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/geUserById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeUserById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeUserById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRequesterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRequesterDto>;
        }));
    }

    protected processGeUserById(response: HttpResponseBase): Observable<GetRequesterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRequesterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRequesterDto>(null as any);
    }

    /**
     * @param fromCurrency (optional) 
     * @param toCurrency (optional) 
     * @param conversionDate (optional) 
     * @return Success
     */
    getGlExchangeRate(fromCurrency: string | null | undefined, toCurrency: string | null | undefined, conversionDate: DateTime | null | undefined): Observable<CommonGetGlExchangeRateDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/getGlExchangeRate?";
        if (fromCurrency !== undefined && fromCurrency !== null)
            url_ += "FromCurrency=" + encodeURIComponent("" + fromCurrency) + "&";
        if (toCurrency !== undefined && toCurrency !== null)
            url_ += "ToCurrency=" + encodeURIComponent("" + toCurrency) + "&";
        if (conversionDate !== undefined && conversionDate !== null)
            url_ += "ConversionDate=" + encodeURIComponent(conversionDate ? "" + conversionDate.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGlExchangeRate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGlExchangeRate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonGetGlExchangeRateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonGetGlExchangeRateDto[]>;
        }));
    }

    protected processGetGlExchangeRate(response: HttpResponseBase): Observable<CommonGetGlExchangeRateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonGetGlExchangeRateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonGetGlExchangeRateDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getDefaultParameter(): Observable<CommonDefaultParameterDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/GetDefaultParameter";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultParameter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultParameter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonDefaultParameterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonDefaultParameterDto>;
        }));
    }

    protected processGetDefaultParameter(response: HttpResponseBase): Observable<CommonDefaultParameterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommonDefaultParameterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonDefaultParameterDto>(null as any);
    }

    /**
     * @param processTypeCode (optional) 
     * @return Success
     */
    getDocumentByProcessType(processTypeCode: string | null | undefined): Observable<CommonAllDocument[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/getDocumentByProcessType?";
        if (processTypeCode !== undefined && processTypeCode !== null)
            url_ += "processTypeCode=" + encodeURIComponent("" + processTypeCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentByProcessType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentByProcessType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonAllDocument[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonAllDocument[]>;
        }));
    }

    protected processGetDocumentByProcessType(response: HttpResponseBase): Observable<CommonAllDocument[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonAllDocument.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonAllDocument[]>(null as any);
    }

    /**
     * @param invGroupId (optional) 
     * @return Success
     */
    getTemplateContractByInvGroup(invGroupId: number | undefined): Observable<CommonAllTemplate[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/getTemplateContractByInvGroup?";
        if (invGroupId === null)
            throw new Error("The parameter 'invGroupId' cannot be null.");
        else if (invGroupId !== undefined)
            url_ += "invGroupId=" + encodeURIComponent("" + invGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateContractByInvGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateContractByInvGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonAllTemplate[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonAllTemplate[]>;
        }));
    }

    protected processGetTemplateContractByInvGroup(response: HttpResponseBase): Observable<CommonAllTemplate[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonAllTemplate.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonAllTemplate[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllOrganization(): Observable<CommonAllOrganization[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/GetAllOrganization";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOrganization(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonAllOrganization[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonAllOrganization[]>;
        }));
    }

    protected processGetAllOrganization(response: HttpResponseBase): Observable<CommonAllOrganization[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonAllOrganization.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonAllOrganization[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllCatalog(): Observable<CommonGetAllCatalogDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneralCache/getAllCatalog";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCatalog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCatalog(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonGetAllCatalogDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonGetAllCatalogDto[]>;
        }));
    }

    protected processGetAllCatalog(response: HttpResponseBase): Observable<CommonGetAllCatalogDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonGetAllCatalogDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonGetAllCatalogDto[]>(null as any);
    }
}

@Injectable()
export class CommonGeneratePurchasingNumberServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    generateRequestNumber(body: GenSeqType | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CommonGeneratePurchasingNumber/GenerateRequestNumber";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateRequestNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateRequestNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGenerateRequestNumber(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionsForCombobox(onlyFreeItems: boolean | undefined): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetEditionsForCombobox?";
        if (onlyFreeItems === null)
            throw new Error("The parameter 'onlyFreeItems' cannot be null.");
        else if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForCombobox(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>;
        }));
    }

    protected processGetEditionsForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfSubscribableEditionComboboxItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfSubscribableEditionComboboxItemDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findUsers(body: FindUsersInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfNameValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfNameValueDto>;
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(null as any);
    }

    /**
     * @return Success
     */
    getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetDefaultEditionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultEditionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultEditionName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDefaultEditionNameOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDefaultEditionNameOutput>;
        }));
    }

    protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDefaultEditionNameOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDefaultEditionNameOutput>(null as any);
    }

    /**
     * @param headerId (optional) 
     * @param type (optional) 
     * @return Success
     */
    getListAttachFileData(headerId: number | undefined, type: string | null | undefined): Observable<GetAttachFileDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetListAttachFileData?";
        if (headerId === null)
            throw new Error("The parameter 'headerId' cannot be null.");
        else if (headerId !== undefined)
            url_ += "headerId=" + encodeURIComponent("" + headerId) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListAttachFileData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListAttachFileData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAttachFileDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAttachFileDto[]>;
        }));
    }

    protected processGetListAttachFileData(response: HttpResponseBase): Observable<GetAttachFileDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAttachFileDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAttachFileDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveAttachFileToDb(body: GetAttachFileDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/SaveAttachFileToDb";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAttachFileToDb(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAttachFileToDb(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveAttachFileToDb(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param inputId (optional) 
     * @return Success
     */
    deleteAttachFile(inputId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/DeleteAttachFile?";
        if (inputId === null)
            throw new Error("The parameter 'inputId' cannot be null.");
        else if (inputId !== undefined)
            url_ += "inputId=" + encodeURIComponent("" + inputId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAttachFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAttachFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAttachFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param headerId (optional) 
     * @param type (optional) 
     * @return Success
     */
    getAttachFileData(headerId: number | undefined, type: string | null | undefined): Observable<GetAttachFileDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetAttachFileData?";
        if (headerId === null)
            throw new Error("The parameter 'headerId' cannot be null.");
        else if (headerId !== undefined)
            url_ += "headerId=" + encodeURIComponent("" + headerId) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttachFileData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttachFileData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAttachFileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAttachFileDto>;
        }));
    }

    protected processGetAttachFileData(response: HttpResponseBase): Observable<GetAttachFileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAttachFileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAttachFileDto>(null as any);
    }

    /**
     * @param contractId (optional) 
     * @return Success
     */
    deleteAllAttachmentByConTractId(contractId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/DeleteAllAttachmentByConTractId?";
        if (contractId === null)
            throw new Error("The parameter 'contractId' cannot be null.");
        else if (contractId !== undefined)
            url_ += "contractId=" + encodeURIComponent("" + contractId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllAttachmentByConTractId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllAttachmentByConTractId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAllAttachmentByConTractId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class DashboardCustomizationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    getUserDashboard(dashboardName: string | null | undefined, application: string | null | undefined): Observable<Dashboard> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetUserDashboard?";
        if (dashboardName !== undefined && dashboardName !== null)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application !== undefined && application !== null)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDashboard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Dashboard>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Dashboard>;
        }));
    }

    protected processGetUserDashboard(response: HttpResponseBase): Observable<Dashboard> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Dashboard.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dashboard>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savePage(body: SavePageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/SavePage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSavePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    renamePage(body: RenamePageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/RenamePage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRenamePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRenamePage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRenamePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addNewPage(body: AddNewPageInput | undefined): Observable<AddNewPageOutput> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/AddNewPage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddNewPageOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddNewPageOutput>;
        }));
    }

    protected processAddNewPage(response: HttpResponseBase): Observable<AddNewPageOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddNewPageOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddNewPageOutput>(null as any);
    }

    /**
     * @param id (optional) 
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    deletePage(id: string | null | undefined, dashboardName: string | null | undefined, application: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/DeletePage?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (dashboardName !== undefined && dashboardName !== null)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application !== undefined && application !== null)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addWidget(body: AddWidgetInput | undefined): Observable<Widget> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/AddWidget";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddWidget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddWidget(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Widget>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Widget>;
        }));
    }

    protected processAddWidget(response: HttpResponseBase): Observable<Widget> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Widget.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Widget>(null as any);
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    getDashboardDefinition(dashboardName: string | null | undefined, application: string | null | undefined): Observable<DashboardOutput> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetDashboardDefinition?";
        if (dashboardName !== undefined && dashboardName !== null)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application !== undefined && application !== null)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardDefinition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashboardOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashboardOutput>;
        }));
    }

    protected processGetDashboardDefinition(response: HttpResponseBase): Observable<DashboardOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashboardOutput>(null as any);
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    getAllWidgetDefinitions(dashboardName: string | null | undefined, application: string | null | undefined): Observable<WidgetOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetAllWidgetDefinitions?";
        if (dashboardName !== undefined && dashboardName !== null)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application !== undefined && application !== null)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWidgetDefinitions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWidgetDefinitions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WidgetOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WidgetOutput[]>;
        }));
    }

    protected processGetAllWidgetDefinitions(response: HttpResponseBase): Observable<WidgetOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WidgetOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WidgetOutput[]>(null as any);
    }

    /**
     * @param application (optional) 
     * @return Success
     */
    getSettingName(application: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetSettingName?";
        if (application !== undefined && application !== null)
            url_ += "application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettingName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettingName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetSettingName(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class DemoUiComponentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDate(date: DateTime | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDate?";
        if (date !== undefined && date !== null)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DateToStringOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DateToStringOutput>;
        }));
    }

    protected processSendAndGetDate(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateToStringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(null as any);
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDateTime(date: DateTime | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateTime?";
        if (date !== undefined && date !== null)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateTime(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DateToStringOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DateToStringOutput>;
        }));
    }

    protected processSendAndGetDateTime(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateToStringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    sendAndGetDateRange(startDate: DateTime | null | undefined, endDate: DateTime | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateRange?";
        if (startDate !== undefined && startDate !== null)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DateToStringOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DateToStringOutput>;
        }));
    }

    protected processSendAndGetDateRange(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateToStringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(null as any);
    }

    /**
     * @param searchTerm (optional) 
     * @return Success
     */
    getCountries(searchTerm: string | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/GetCountries?";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NameValueOfString[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NameValueOfString[]>;
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendAndGetSelectedCountries(body: NameValueOfString[] | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetSelectedCountries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetSelectedCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetSelectedCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NameValueOfString[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NameValueOfString[]>;
        }));
    }

    protected processSendAndGetSelectedCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendAndGetValue(input: string | null | undefined): Observable<StringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetValue?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetValue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringOutput>;
        }));
    }

    protected processSendAndGetValue(response: HttpResponseBase): Observable<StringOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringOutput>(null as any);
    }
}

@Injectable()
export class DigitalInvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param invoiceNum (optional) 
     * @param serialNo (optional) 
     * @param supplierNum (optional) 
     * @param status (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllDigitalInvoiceInfo(invoiceNum: string | null | undefined, serialNo: string | null | undefined, supplierNum: string | null | undefined, status: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfDigitalInvoiceInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/DigitalInvoice/GetAllDigitalInvoiceInfo?";
        if (invoiceNum !== undefined && invoiceNum !== null)
            url_ += "InvoiceNum=" + encodeURIComponent("" + invoiceNum) + "&";
        if (serialNo !== undefined && serialNo !== null)
            url_ += "SerialNo=" + encodeURIComponent("" + serialNo) + "&";
        if (supplierNum !== undefined && supplierNum !== null)
            url_ += "SupplierNum=" + encodeURIComponent("" + supplierNum) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDigitalInvoiceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDigitalInvoiceInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfDigitalInvoiceInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfDigitalInvoiceInfoDto>;
        }));
    }

    protected processGetAllDigitalInvoiceInfo(response: HttpResponseBase): Observable<PagedResultDtoOfDigitalInvoiceInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDigitalInvoiceInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDigitalInvoiceInfoDto>(null as any);
    }

    /**
     * @param headerId (optional) 
     * @param poNo (optional) 
     * @return Success
     */
    updatePoNo(headerId: number | undefined, poNo: string | null | undefined): Observable<DigitalInvoiceInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/DigitalInvoice/UpdatePoNo?";
        if (headerId === null)
            throw new Error("The parameter 'headerId' cannot be null.");
        else if (headerId !== undefined)
            url_ += "headerId=" + encodeURIComponent("" + headerId) + "&";
        if (poNo !== undefined && poNo !== null)
            url_ += "poNo=" + encodeURIComponent("" + poNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePoNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePoNo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DigitalInvoiceInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DigitalInvoiceInfoDto>;
        }));
    }

    protected processUpdatePoNo(response: HttpResponseBase): Observable<DigitalInvoiceInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DigitalInvoiceInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DigitalInvoiceInfoDto>(null as any);
    }

    /**
     * @param headerId (optional) 
     * @return Success
     */
    getAttachFile(headerId: number | undefined): Observable<InvoiceAkabotFileDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DigitalInvoice/GetAttachFile?";
        if (headerId === null)
            throw new Error("The parameter 'headerId' cannot be null.");
        else if (headerId !== undefined)
            url_ += "headerId=" + encodeURIComponent("" + headerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttachFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttachFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceAkabotFileDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceAkabotFileDto[]>;
        }));
    }

    protected processGetAttachFile(response: HttpResponseBase): Observable<InvoiceAkabotFileDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InvoiceAkabotFileDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceAkabotFileDto[]>(null as any);
    }

    /**
     * @param headerId (optional) 
     * @return Success
     */
    getAllDigitalInvoiceDetailInfo(headerId: number | undefined): Observable<DigitalInvoiceDetailInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DigitalInvoice/GetAllDigitalInvoiceDetailInfo?";
        if (headerId === null)
            throw new Error("The parameter 'headerId' cannot be null.");
        else if (headerId !== undefined)
            url_ += "headerId=" + encodeURIComponent("" + headerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDigitalInvoiceDetailInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDigitalInvoiceDetailInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DigitalInvoiceDetailInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DigitalInvoiceDetailInfoDto[]>;
        }));
    }

    protected processGetAllDigitalInvoiceDetailInfo(response: HttpResponseBase): Observable<DigitalInvoiceDetailInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DigitalInvoiceDetailInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DigitalInvoiceDetailInfoDto[]>(null as any);
    }

    /**
     * @param headerId (optional) 
     * @return Success
     */
    getDigitalInvoiceMatchResults(headerId: number | undefined): Observable<DigitalInvoiceMatchResultsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DigitalInvoice/GetDigitalInvoiceMatchResults?";
        if (headerId === null)
            throw new Error("The parameter 'headerId' cannot be null.");
        else if (headerId !== undefined)
            url_ += "headerId=" + encodeURIComponent("" + headerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDigitalInvoiceMatchResults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDigitalInvoiceMatchResults(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DigitalInvoiceMatchResultsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DigitalInvoiceMatchResultsDto[]>;
        }));
    }

    protected processGetDigitalInvoiceMatchResults(response: HttpResponseBase): Observable<DigitalInvoiceMatchResultsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DigitalInvoiceMatchResultsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DigitalInvoiceMatchResultsDto[]>(null as any);
    }

    /**
     * @param headerId (optional) 
     * @return Success
     */
    matchInvoice(headerId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DigitalInvoice/MatchInvoice?";
        if (headerId === null)
            throw new Error("The parameter 'headerId' cannot be null.");
        else if (headerId !== undefined)
            url_ += "headerId=" + encodeURIComponent("" + headerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMatchInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMatchInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMatchInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param headerId (optional) 
     * @return Success
     */
    unMatchInvoice(headerId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DigitalInvoice/UnMatchInvoice?";
        if (headerId === null)
            throw new Error("The parameter 'headerId' cannot be null.");
        else if (headerId !== undefined)
            url_ += "headerId=" + encodeURIComponent("" + headerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnMatchInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnMatchInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnMatchInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    confirmInvoice(body: DigitalInvoiceMatchResultsDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DigitalInvoice/confirmInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConfirmInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class DynamicEntityPropertyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DynamicEntityPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DynamicEntityPropertyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DynamicEntityPropertyDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DynamicEntityPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicEntityPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicEntityPropertyDto>(null as any);
    }

    /**
     * @param entityFullName (optional) 
     * @return Success
     */
    getAllPropertiesOfAnEntity(entityFullName: string | null | undefined): Observable<ListResultDtoOfDynamicEntityPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/GetAllPropertiesOfAnEntity?";
        if (entityFullName !== undefined && entityFullName !== null)
            url_ += "EntityFullName=" + encodeURIComponent("" + entityFullName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPropertiesOfAnEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPropertiesOfAnEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfDynamicEntityPropertyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfDynamicEntityPropertyDto>;
        }));
    }

    protected processGetAllPropertiesOfAnEntity(response: HttpResponseBase): Observable<ListResultDtoOfDynamicEntityPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicEntityPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDynamicEntityPropertyDto>(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<ListResultDtoOfDynamicEntityPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfDynamicEntityPropertyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfDynamicEntityPropertyDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfDynamicEntityPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicEntityPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDynamicEntityPropertyDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: DynamicEntityPropertyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DynamicEntityPropertyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getAllEntitiesHasDynamicProperty(): Observable<ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/GetAllEntitiesHasDynamicProperty";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEntitiesHasDynamicProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEntitiesHasDynamicProperty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput>;
        }));
    }

    protected processGetAllEntitiesHasDynamicProperty(response: HttpResponseBase): Observable<ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput>(null as any);
    }
}

@Injectable()
export class DynamicEntityPropertyDefinitionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllAllowedInputTypeNames(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyDefinition/GetAllAllowedInputTypeNames";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAllowedInputTypeNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAllowedInputTypeNames(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetAllAllowedInputTypeNames(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllEntities(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyDefinition/GetAllEntities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEntities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEntities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetAllEntities(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(null as any);
    }
}

@Injectable()
export class DynamicEntityPropertyValueServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DynamicEntityPropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DynamicEntityPropertyValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DynamicEntityPropertyValueDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DynamicEntityPropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicEntityPropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicEntityPropertyValueDto>(null as any);
    }

    /**
     * @param entityId (optional) 
     * @param propertyId (optional) 
     * @return Success
     */
    getAll(entityId: string | null | undefined, propertyId: number | undefined): Observable<ListResultDtoOfDynamicEntityPropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/GetAll?";
        if (entityId !== undefined && entityId !== null)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "PropertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfDynamicEntityPropertyValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfDynamicEntityPropertyValueDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfDynamicEntityPropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicEntityPropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDynamicEntityPropertyValueDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: DynamicEntityPropertyValueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DynamicEntityPropertyValueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getAllDynamicEntityPropertyValues(entityFullName: string, entityId: string): Observable<GetAllDynamicEntityPropertyValuesOutput> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/GetAllDynamicEntityPropertyValues?";
        if (entityFullName === undefined || entityFullName === null)
            throw new Error("The parameter 'entityFullName' must be defined and cannot be null.");
        else
            url_ += "EntityFullName=" + encodeURIComponent("" + entityFullName) + "&";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined and cannot be null.");
        else
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDynamicEntityPropertyValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDynamicEntityPropertyValues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllDynamicEntityPropertyValuesOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllDynamicEntityPropertyValuesOutput>;
        }));
    }

    protected processGetAllDynamicEntityPropertyValues(response: HttpResponseBase): Observable<GetAllDynamicEntityPropertyValuesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllDynamicEntityPropertyValuesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllDynamicEntityPropertyValuesOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertOrUpdateAllValues(body: InsertOrUpdateAllValuesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/InsertOrUpdateAllValues";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertOrUpdateAllValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertOrUpdateAllValues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInsertOrUpdateAllValues(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cleanValues(body: CleanValuesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/CleanValues";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCleanValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCleanValues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCleanValues(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class DynamicPropertyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DynamicPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DynamicPropertyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DynamicPropertyDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DynamicPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicPropertyDto>(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<ListResultDtoOfDynamicPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfDynamicPropertyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfDynamicPropertyDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfDynamicPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDynamicPropertyDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: DynamicPropertyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DynamicPropertyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    findAllowedInputType(name: string | null | undefined): Observable<IInputType> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/FindAllowedInputType?";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindAllowedInputType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindAllowedInputType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IInputType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IInputType>;
        }));
    }

    protected processFindAllowedInputType(response: HttpResponseBase): Observable<IInputType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IInputType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IInputType>(null as any);
    }
}

@Injectable()
export class DynamicPropertyValueServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DynamicPropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DynamicPropertyValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DynamicPropertyValueDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DynamicPropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicPropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicPropertyValueDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllValuesOfDynamicProperty(id: number | undefined): Observable<ListResultDtoOfDynamicPropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/GetAllValuesOfDynamicProperty?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllValuesOfDynamicProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllValuesOfDynamicProperty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfDynamicPropertyValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfDynamicPropertyValueDto>;
        }));
    }

    protected processGetAllValuesOfDynamicProperty(response: HttpResponseBase): Observable<ListResultDtoOfDynamicPropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicPropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDynamicPropertyValueDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: DynamicPropertyValueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DynamicPropertyValueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class EditionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEditions(): Observable<ListResultDtoOfEditionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfEditionListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfEditionListDto>;
        }));
    }

    protected processGetEditions(response: HttpResponseBase): Observable<ListResultDtoOfEditionListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfEditionListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfEditionListDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEditionForEdit(id: number | null | undefined): Observable<GetEditionEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEditionEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEditionEditOutput>;
        }));
    }

    protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEditionEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionEditOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createEdition(body: CreateEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/CreateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateEdition(body: UpdateEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/UpdateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteEdition(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/DeleteEdition?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moveTenantsToAnotherEdition(body: MoveTenantsToAnotherEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/MoveTenantsToAnotherEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveTenantsToAnotherEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveTenantsToAnotherEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMoveTenantsToAnotherEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param selectedEditionId (optional) 
     * @param addAllItem (optional) 
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionComboboxItems(selectedEditionId: number | null | undefined, addAllItem: boolean | undefined, onlyFreeItems: boolean | undefined): Observable<SubscribableEditionComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionComboboxItems?";
        if (selectedEditionId !== undefined && selectedEditionId !== null)
            url_ += "selectedEditionId=" + encodeURIComponent("" + selectedEditionId) + "&";
        if (addAllItem === null)
            throw new Error("The parameter 'addAllItem' cannot be null.");
        else if (addAllItem !== undefined)
            url_ += "addAllItem=" + encodeURIComponent("" + addAllItem) + "&";
        if (onlyFreeItems === null)
            throw new Error("The parameter 'onlyFreeItems' cannot be null.");
        else if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionComboboxItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscribableEditionComboboxItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscribableEditionComboboxItemDto[]>;
        }));
    }

    protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscribableEditionComboboxItemDto[]>(null as any);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getTenantCount(editionId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetTenantCount?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetTenantCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class ExchangeRateMasterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExchangeRateMaster/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param currencyId (optional) 
     * @param periodId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllExchangeRate(currencyId: number | undefined, periodId: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfMstExchangeRateDto> {
        let url_ = this.baseUrl + "/api/services/app/ExchangeRateMaster/getAllExchangeRate?";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (periodId === null)
            throw new Error("The parameter 'periodId' cannot be null.");
        else if (periodId !== undefined)
            url_ += "PeriodId=" + encodeURIComponent("" + periodId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllExchangeRate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllExchangeRate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMstExchangeRateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMstExchangeRateDto>;
        }));
    }

    protected processGetAllExchangeRate(response: HttpResponseBase): Observable<PagedResultDtoOfMstExchangeRateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMstExchangeRateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMstExchangeRateDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    loadById(id: number | undefined): Observable<InputExchangeRateDto> {
        let url_ = this.baseUrl + "/api/services/app/ExchangeRateMaster/LoadById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InputExchangeRateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InputExchangeRateDto>;
        }));
    }

    protected processLoadById(response: HttpResponseBase): Observable<InputExchangeRateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InputExchangeRateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InputExchangeRateDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: InputExchangeRateDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExchangeRateMaster/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    syncBMSEnum(body: BmsMstColumn | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExchangeRateMaster/SyncBMSEnum";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncBMSEnum(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncBMSEnum(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSyncBMSEnum(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class FriendshipServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFriendshipRequest(body: CreateFriendshipRequestInput | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FriendDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FriendDto>;
        }));
    }

    protected processCreateFriendshipRequest(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FriendDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFriendshipRequestByUserName(body: CreateFriendshipRequestByUserNameInput | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequestByUserName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequestByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequestByUserName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FriendDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FriendDto>;
        }));
    }

    protected processCreateFriendshipRequestByUserName(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FriendDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    blockUser(body: BlockUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/BlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlockUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unblockUser(body: UnblockUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/UnblockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnblockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnblockUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnblockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    acceptFriendshipRequest(body: AcceptFriendshipRequestInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/AcceptFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptFriendshipRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAcceptFriendshipRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class HostDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getTopStatsData(startDate: DateTime | undefined, endDate: DateTime | undefined): Observable<TopStatsData> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetTopStatsData?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopStatsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopStatsData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TopStatsData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TopStatsData>;
        }));
    }

    protected processGetTopStatsData(response: HttpResponseBase): Observable<TopStatsData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TopStatsData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TopStatsData>(null as any);
    }

    /**
     * @return Success
     */
    getRecentTenantsData(): Observable<GetRecentTenantsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetRecentTenantsData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentTenantsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentTenantsData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRecentTenantsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRecentTenantsOutput>;
        }));
    }

    protected processGetRecentTenantsData(response: HttpResponseBase): Observable<GetRecentTenantsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRecentTenantsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRecentTenantsOutput>(null as any);
    }

    /**
     * @return Success
     */
    getSubscriptionExpiringTenantsData(): Observable<GetExpiringTenantsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetSubscriptionExpiringTenantsData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptionExpiringTenantsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptionExpiringTenantsData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetExpiringTenantsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetExpiringTenantsOutput>;
        }));
    }

    protected processGetSubscriptionExpiringTenantsData(response: HttpResponseBase): Observable<GetExpiringTenantsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetExpiringTenantsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetExpiringTenantsOutput>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getIncomeStatistics(incomeStatisticsDateInterval: ChartDateInterval, startDate: DateTime | undefined, endDate: DateTime | undefined): Observable<GetIncomeStatisticsDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetIncomeStatistics?";
        if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
            throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
        else
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncomeStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncomeStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetIncomeStatisticsDataOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetIncomeStatisticsDataOutput>;
        }));
    }

    protected processGetIncomeStatistics(response: HttpResponseBase): Observable<GetIncomeStatisticsDataOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetIncomeStatisticsDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncomeStatisticsDataOutput>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getEditionTenantStatistics(startDate: DateTime | undefined, endDate: DateTime | undefined): Observable<GetEditionTenantStatisticsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetEditionTenantStatistics?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionTenantStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionTenantStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEditionTenantStatisticsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEditionTenantStatisticsOutput>;
        }));
    }

    protected processGetEditionTenantStatistics(response: HttpResponseBase): Observable<GetEditionTenantStatisticsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEditionTenantStatisticsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionTenantStatisticsOutput>(null as any);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HostSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HostSettingsEditDto>;
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HostSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostSettingsEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllSettings(body: HostSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getEnabledSocialLoginSettings(): Observable<ExternalLoginSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetEnabledSocialLoginSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnabledSocialLoginSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnabledSocialLoginSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalLoginSettingsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalLoginSettingsDto>;
        }));
    }

    protected processGetEnabledSocialLoginSettings(response: HttpResponseBase): Observable<ExternalLoginSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalLoginSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginSettingsDto>(null as any);
    }
}

@Injectable()
export class ImpInventoryItemPriceTempServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchInvItemsDto (optional) 
     * @return Success
     */
    getAllInventoryItemsByGroup(searchInvItemsDto: ImpInventoryItemPriceTempDto[] | null | undefined): Observable<ImpInventoryItemPriceTempDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ImpInventoryItemPriceTemp/getAllInventoryItemsByGroup?";
        if (searchInvItemsDto !== undefined && searchInvItemsDto !== null)
            searchInvItemsDto && searchInvItemsDto.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "searchInvItemsDto[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInventoryItemsByGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInventoryItemsByGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpInventoryItemPriceTempDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpInventoryItemPriceTempDto[]>;
        }));
    }

    protected processGetAllInventoryItemsByGroup(response: HttpResponseBase): Observable<ImpInventoryItemPriceTempDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ImpInventoryItemPriceTempDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpInventoryItemPriceTempDto[]>(null as any);
    }
}

@Injectable()
export class ImportPrImportExcelDataReaderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param data (optional) 
     * @return Success
     */
    getImportPrFromExcel(data: string | null | undefined): Observable<ImportPrDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ImportPrImportExcelDataReader/GetImportPrFromExcel?";
        if (data !== undefined && data !== null)
            url_ += "data=" + encodeURIComponent("" + data) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImportPrFromExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImportPrFromExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImportPrDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImportPrDto[]>;
        }));
    }

    protected processGetImportPrFromExcel(response: HttpResponseBase): Observable<ImportPrDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ImportPrDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportPrDto[]>(null as any);
    }
}

@Injectable()
export class ImportPurchaseOrdersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param data (optional) 
     * @return Success
     */
    getImportPoFromExcel(data: string | null | undefined): Observable<PoImportPurchaseOrderDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ImportPurchaseOrders/GetImportPoFromExcel?";
        if (data !== undefined && data !== null)
            url_ += "data=" + encodeURIComponent("" + data) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImportPoFromExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImportPoFromExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PoImportPurchaseOrderDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PoImportPurchaseOrderDto[]>;
        }));
    }

    protected processGetImportPoFromExcel(response: HttpResponseBase): Observable<PoImportPurchaseOrderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PoImportPurchaseOrderDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PoImportPurchaseOrderDto[]>(null as any);
    }
}

@Injectable()
export class InstallServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setup(body: InstallDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Install/Setup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getAppSettingsJson(): Observable<AppSettingsJsonDto> {
        let url_ = this.baseUrl + "/api/services/app/Install/GetAppSettingsJson";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppSettingsJson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppSettingsJson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppSettingsJsonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppSettingsJsonDto>;
        }));
    }

    protected processGetAppSettingsJson(response: HttpResponseBase): Observable<AppSettingsJsonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppSettingsJsonDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppSettingsJsonDto>(null as any);
    }

    /**
     * @return Success
     */
    checkDatabase(): Observable<CheckDatabaseOutput> {
        let url_ = this.baseUrl + "/api/services/app/Install/CheckDatabase";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckDatabase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckDatabase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckDatabaseOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckDatabaseOutput>;
        }));
    }

    protected processCheckDatabase(response: HttpResponseBase): Observable<CheckDatabaseOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckDatabaseOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckDatabaseOutput>(null as any);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoiceInfo(id: number | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDto>;
        }));
    }

    protected processGetInvoiceInfo(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createInvoice(body: CreateInvoiceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CreateInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param invoiceNum (optional) 
     * @param invoiceSymbol (optional) 
     * @param vendorNumber (optional) 
     * @param vendorId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param status (optional) 
     * @param source (optional) 
     * @param poNumber (optional) 
     * @param vatRegistrationInvoice (optional) 
     * @param createInvoiceDate (optional) 
     * @param picUserId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getInvoiceSearch(invoiceNum: string | null | undefined, invoiceSymbol: string | null | undefined, vendorNumber: string | null | undefined, vendorId: number | undefined, fromDate: DateTime | null | undefined, toDate: DateTime | null | undefined, status: string | null | undefined, source: string | null | undefined, poNumber: string | null | undefined, vatRegistrationInvoice: string | null | undefined, createInvoiceDate: DateTime | null | undefined, picUserId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSearchInvoiceOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/getInvoiceSearch?";
        if (invoiceNum !== undefined && invoiceNum !== null)
            url_ += "InvoiceNum=" + encodeURIComponent("" + invoiceNum) + "&";
        if (invoiceSymbol !== undefined && invoiceSymbol !== null)
            url_ += "InvoiceSymbol=" + encodeURIComponent("" + invoiceSymbol) + "&";
        if (vendorNumber !== undefined && vendorNumber !== null)
            url_ += "VendorNumber=" + encodeURIComponent("" + vendorNumber) + "&";
        if (vendorId === null)
            throw new Error("The parameter 'vendorId' cannot be null.");
        else if (vendorId !== undefined)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toString() : "") + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (source !== undefined && source !== null)
            url_ += "Source=" + encodeURIComponent("" + source) + "&";
        if (poNumber !== undefined && poNumber !== null)
            url_ += "PoNumber=" + encodeURIComponent("" + poNumber) + "&";
        if (vatRegistrationInvoice !== undefined && vatRegistrationInvoice !== null)
            url_ += "VatRegistrationInvoice=" + encodeURIComponent("" + vatRegistrationInvoice) + "&";
        if (createInvoiceDate !== undefined && createInvoiceDate !== null)
            url_ += "CreateInvoiceDate=" + encodeURIComponent(createInvoiceDate ? "" + createInvoiceDate.toString() : "") + "&";
        if (picUserId !== undefined && picUserId !== null)
            url_ += "PicUserId=" + encodeURIComponent("" + picUserId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfSearchInvoiceOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfSearchInvoiceOutputDto>;
        }));
    }

    protected processGetInvoiceSearch(response: HttpResponseBase): Observable<PagedResultDtoOfSearchInvoiceOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSearchInvoiceOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSearchInvoiceOutputDto>(null as any);
    }

    /**
     * @param invoiceId (optional) 
     * @param status (optional) 
     * @return Success
     */
    getInvoiceSearchDetail(invoiceId: number | undefined, status: string | null | undefined): Observable<SearchInvoiceOutputDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/getInvoiceSearchDetail?";
        if (invoiceId === null)
            throw new Error("The parameter 'invoiceId' cannot be null.");
        else if (invoiceId !== undefined)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceSearchDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceSearchDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SearchInvoiceOutputDetailDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SearchInvoiceOutputDetailDto[]>;
        }));
    }

    protected processGetInvoiceSearchDetail(response: HttpResponseBase): Observable<SearchInvoiceOutputDetailDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SearchInvoiceOutputDetailDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchInvoiceOutputDetailDto[]>(null as any);
    }

    /**
     * @param vendorId (optional) 
     * @param removeId (optional) 
     * @return Success
     */
    getPoVendorById(vendorId: number | undefined, removeId: string | null | undefined): Observable<GetPoVendorDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/getPoVendorById?";
        if (vendorId === null)
            throw new Error("The parameter 'vendorId' cannot be null.");
        else if (vendorId !== undefined)
            url_ += "vendorId=" + encodeURIComponent("" + vendorId) + "&";
        if (removeId !== undefined && removeId !== null)
            url_ += "removeId=" + encodeURIComponent("" + removeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPoVendorById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPoVendorById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPoVendorDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPoVendorDto[]>;
        }));
    }

    protected processGetPoVendorById(response: HttpResponseBase): Observable<GetPoVendorDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetPoVendorDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPoVendorDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllVendor(): Observable<VendorComboboxDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/getAllVendor";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVendor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorComboboxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorComboboxDto[]>;
        }));
    }

    protected processGetAllVendor(response: HttpResponseBase): Observable<VendorComboboxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VendorComboboxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorComboboxDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getStatus(): Observable<MasterLookupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/getStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MasterLookupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MasterLookupDto[]>;
        }));
    }

    protected processGetStatus(response: HttpResponseBase): Observable<MasterLookupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MasterLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MasterLookupDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllCurrency(): Observable<CurrencyComboboxDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/getAllCurrency";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCurrency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCurrency(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrencyComboboxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrencyComboboxDto[]>;
        }));
    }

    protected processGetAllCurrency(response: HttpResponseBase): Observable<CurrencyComboboxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CurrencyComboboxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrencyComboboxDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveInvoice(body: SearchInvoiceOutputDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/SaveInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processSaveInvoice(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    importMultipleInvoice(body: string | null | undefined): Observable<InvImportMultipleDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/ImportMultipleInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportMultipleInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportMultipleInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvImportMultipleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvImportMultipleDto>;
        }));
    }

    protected processImportMultipleInvoice(response: HttpResponseBase): Observable<InvImportMultipleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvImportMultipleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvImportMultipleDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    invoiceInsertMultiple(body: InvImportMultipleDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/InvoiceInsertMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoiceInsertMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoiceInsertMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processInvoiceInsertMultiple(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param invoiceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    importListDetails(invoiceId: number | null | undefined, body: SearchInvoiceOutputDetailDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/ImportListDetails?";
        if (invoiceId !== undefined && invoiceId !== null)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportListDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportListDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportListDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    matchedInvoice(body: SearchInvoiceOutputDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/MatchedInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMatchedInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMatchedInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processMatchedInvoice(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listPOExportExcel(body: GetPoVendorDto[] | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/ListPOExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListPOExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListPOExportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processListPOExportExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    importData(body: string | null | undefined): Observable<GetPoVendorDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/ImportData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPoVendorDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPoVendorDto[]>;
        }));
    }

    protected processImportData(response: HttpResponseBase): Observable<GetPoVendorDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetPoVendorDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPoVendorDto[]>(null as any);
    }

    /**
     * @param vendorId (optional) 
     * @return Success
     */
    getAllPoNumberByVendor(vendorId: number | undefined): Observable<GetAllPoNumberByVendorDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetAllPoNumberByVendor?";
        if (vendorId === null)
            throw new Error("The parameter 'vendorId' cannot be null.");
        else if (vendorId !== undefined)
            url_ += "vendorId=" + encodeURIComponent("" + vendorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPoNumberByVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPoNumberByVendor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllPoNumberByVendorDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllPoNumberByVendorDto[]>;
        }));
    }

    protected processGetAllPoNumberByVendor(response: HttpResponseBase): Observable<GetAllPoNumberByVendorDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAllPoNumberByVendorDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllPoNumberByVendorDto[]>(null as any);
    }

    /**
     * @param poId (optional) 
     * @return Success
     */
    getAllPoLinesForUpdateInvoice(poId: number | undefined): Observable<GetAllPoLinesForUpdateInvoiceDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetAllPoLinesForUpdateInvoice?";
        if (poId === null)
            throw new Error("The parameter 'poId' cannot be null.");
        else if (poId !== undefined)
            url_ += "poId=" + encodeURIComponent("" + poId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPoLinesForUpdateInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPoLinesForUpdateInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllPoLinesForUpdateInvoiceDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllPoLinesForUpdateInvoiceDto[]>;
        }));
    }

    protected processGetAllPoLinesForUpdateInvoice(response: HttpResponseBase): Observable<GetAllPoLinesForUpdateInvoiceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAllPoLinesForUpdateInvoiceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllPoLinesForUpdateInvoiceDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelInvoice(body: CancelInvoiceInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CancelInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancelInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteInvoice(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/DeleteInvoice?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getAllCancelReasonForInvoice(): Observable<GetAllCancelReasonForInvoice[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetAllCancelReasonForInvoice";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCancelReasonForInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCancelReasonForInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllCancelReasonForInvoice[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllCancelReasonForInvoice[]>;
        }));
    }

    protected processGetAllCancelReasonForInvoice(response: HttpResponseBase): Observable<GetAllCancelReasonForInvoice[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAllCancelReasonForInvoice.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllCancelReasonForInvoice[]>(null as any);
    }

    /**
     * @param vatRegistrationInvoice (optional) 
     * @return Success
     */
    updateSupplier(vatRegistrationInvoice: string | null | undefined): Observable<GetSupplierInfoForInvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/UpdateSupplier?";
        if (vatRegistrationInvoice !== undefined && vatRegistrationInvoice !== null)
            url_ += "vatRegistrationInvoice=" + encodeURIComponent("" + vatRegistrationInvoice) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSupplier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSupplier(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSupplierInfoForInvoiceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSupplierInfoForInvoiceDto>;
        }));
    }

    protected processUpdateSupplier(response: HttpResponseBase): Observable<GetSupplierInfoForInvoiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSupplierInfoForInvoiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSupplierInfoForInvoiceDto>(null as any);
    }

    /**
     * @return Success
     */
    getAllUserForCombobox(): Observable<GetAllUserForComboboxDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetAllUserForCombobox";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForCombobox(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllUserForComboboxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllUserForComboboxDto[]>;
        }));
    }

    protected processGetAllUserForCombobox(response: HttpResponseBase): Observable<GetAllUserForComboboxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAllUserForComboboxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllUserForComboboxDto[]>(null as any);
    }
}

@Injectable()
export class InvoiceAdjustedServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditInvoiceAdjusted(body: InputInvoiceAdjustedHeadersDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/InvoiceAdjusted/CreateOrEditInvoiceAdjusted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditInvoiceAdjusted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditInvoiceAdjusted(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateOrEditInvoiceAdjusted(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteInvoiceAdjusted(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InvoiceAdjusted/deleteInvoiceAdjusted?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInvoiceAdjusted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInvoiceAdjusted(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteInvoiceAdjusted(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoiceAdjestedId(id: number | null | undefined): Observable<InputInvoiceAdjustedHeadersDto> {
        let url_ = this.baseUrl + "/api/services/app/InvoiceAdjusted/getInvoiceAdjestedId?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceAdjestedId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceAdjestedId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InputInvoiceAdjustedHeadersDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InputInvoiceAdjustedHeadersDto>;
        }));
    }

    protected processGetInvoiceAdjestedId(response: HttpResponseBase): Observable<InputInvoiceAdjustedHeadersDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InputInvoiceAdjustedHeadersDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InputInvoiceAdjustedHeadersDto>(null as any);
    }

    /**
     * @param supplierId (optional) 
     * @param invoiceNo (optional) 
     * @param serialNo (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllInvoiceAdjusted(supplierId: number | null | undefined, invoiceNo: string | null | undefined, serialNo: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetAllInvoiceAdjustedDto> {
        let url_ = this.baseUrl + "/api/services/app/InvoiceAdjusted/getAllInvoiceAdjusted?";
        if (supplierId !== undefined && supplierId !== null)
            url_ += "SupplierId=" + encodeURIComponent("" + supplierId) + "&";
        if (invoiceNo !== undefined && invoiceNo !== null)
            url_ += "InvoiceNo=" + encodeURIComponent("" + invoiceNo) + "&";
        if (serialNo !== undefined && serialNo !== null)
            url_ += "SerialNo=" + encodeURIComponent("" + serialNo) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInvoiceAdjusted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInvoiceAdjusted(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAllInvoiceAdjustedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAllInvoiceAdjustedDto>;
        }));
    }

    protected processGetAllInvoiceAdjusted(response: HttpResponseBase): Observable<PagedResultDtoOfGetAllInvoiceAdjustedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAllInvoiceAdjustedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAllInvoiceAdjustedDto>(null as any);
    }

    /**
     * @param vendorId (optional) 
     * @return Success
     */
    getListInvoiceHeadersByVendorId(vendorId: number | undefined): Observable<GetListInvoiceHeadersDto[]> {
        let url_ = this.baseUrl + "/api/services/app/InvoiceAdjusted/getListInvoiceHeadersByVendorId?";
        if (vendorId === null)
            throw new Error("The parameter 'vendorId' cannot be null.");
        else if (vendorId !== undefined)
            url_ += "vendorId=" + encodeURIComponent("" + vendorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListInvoiceHeadersByVendorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListInvoiceHeadersByVendorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetListInvoiceHeadersDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetListInvoiceHeadersDto[]>;
        }));
    }

    protected processGetListInvoiceHeadersByVendorId(response: HttpResponseBase): Observable<GetListInvoiceHeadersDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetListInvoiceHeadersDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetListInvoiceHeadersDto[]>(null as any);
    }

    /**
     * @param headerId (optional) 
     * @return Success
     */
    getListInvoiceLineByHeadersId(headerId: number | undefined): Observable<GetListInvoiceLinesDto[]> {
        let url_ = this.baseUrl + "/api/services/app/InvoiceAdjusted/getListInvoiceLineByHeadersId?";
        if (headerId === null)
            throw new Error("The parameter 'headerId' cannot be null.");
        else if (headerId !== undefined)
            url_ += "headerId=" + encodeURIComponent("" + headerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListInvoiceLineByHeadersId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListInvoiceLineByHeadersId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetListInvoiceLinesDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetListInvoiceLinesDto[]>;
        }));
    }

    protected processGetListInvoiceLineByHeadersId(response: HttpResponseBase): Observable<GetListInvoiceLinesDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetListInvoiceLinesDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetListInvoiceLinesDto[]>(null as any);
    }
}

@Injectable()
export class InvoicesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllInvoice(): Observable<PagedResultDtoOfInvoiceHeadersDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoices/getAllInvoice";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfInvoiceHeadersDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfInvoiceHeadersDto>;
        }));
    }

    protected processGetAllInvoice(response: HttpResponseBase): Observable<PagedResultDtoOfInvoiceHeadersDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfInvoiceHeadersDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfInvoiceHeadersDto>(null as any);
    }

    /**
     * @param invoiceId (optional) 
     * @return Success
     */
    getInvoiceLinesByInvoiceId(invoiceId: number | undefined): Observable<PagedResultDtoOfInvoiceLinesDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoices/getInvoiceLinesByInvoiceId?";
        if (invoiceId === null)
            throw new Error("The parameter 'invoiceId' cannot be null.");
        else if (invoiceId !== undefined)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceLinesByInvoiceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceLinesByInvoiceId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfInvoiceLinesDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfInvoiceLinesDto>;
        }));
    }

    protected processGetInvoiceLinesByInvoiceId(response: HttpResponseBase): Observable<PagedResultDtoOfInvoiceLinesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfInvoiceLinesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfInvoiceLinesDto>(null as any);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<GetLanguagesOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetLanguagesOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetLanguagesOutput>;
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLanguagesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguagesOutput>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLanguageForEdit(id: number | null | undefined): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetLanguageForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetLanguageForEditOutput>;
        }));
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLanguageForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguageForEditOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateLanguage(body: CreateOrUpdateLanguageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteLanguage(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/DeleteLanguage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setDefaultLanguage(body: SetDefaultLanguageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @param baseLanguageName (optional) 
     * @param targetValueFilter (optional) 
     * @param filterText (optional) 
     * @return Success
     */
    getLanguageTexts(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined, sourceName: string, baseLanguageName: string | null | undefined, targetLanguageName: string, targetValueFilter: string | null | undefined, filterText: string | null | undefined): Observable<PagedResultDtoOfLanguageTextListDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageTexts?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "SourceName=" + encodeURIComponent("" + sourceName) + "&";
        if (baseLanguageName !== undefined && baseLanguageName !== null)
            url_ += "BaseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&";
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "TargetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&";
        if (targetValueFilter !== undefined && targetValueFilter !== null)
            url_ += "TargetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&";
        if (filterText !== undefined && filterText !== null)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageTexts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTexts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfLanguageTextListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfLanguageTextListDto>;
        }));
    }

    protected processGetLanguageTexts(response: HttpResponseBase): Observable<PagedResultDtoOfLanguageTextListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLanguageTextListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLanguageTextListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateLanguageText(body: UpdateLanguageTextInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class MstApprovalTreeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstApprovalTree/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getListProcessType(): Observable<ProcessTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstApprovalTree/GetListProcessType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListProcessType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListProcessType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessTypeDto[]>;
        }));
    }

    protected processGetListProcessType(response: HttpResponseBase): Observable<ProcessTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProcessTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getListIventoryGroup(): Observable<IventoryGroupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstApprovalTree/GetListIventoryGroup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListIventoryGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListIventoryGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IventoryGroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IventoryGroupDto[]>;
        }));
    }

    protected processGetListIventoryGroup(response: HttpResponseBase): Observable<IventoryGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IventoryGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IventoryGroupDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getListUser(): Observable<UserSearchByHrOgrDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstApprovalTree/GetListUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserSearchByHrOgrDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserSearchByHrOgrDto[]>;
        }));
    }

    protected processGetListUser(response: HttpResponseBase): Observable<UserSearchByHrOgrDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserSearchByHrOgrDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserSearchByHrOgrDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getListApprovalType(): Observable<ApprovalTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstApprovalTree/GetListApprovalType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListApprovalType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListApprovalType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApprovalTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApprovalTypeDto[]>;
        }));
    }

    protected processGetListApprovalType(response: HttpResponseBase): Observable<ApprovalTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ApprovalTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getListHrOrgStructure(): Observable<HrOrgStructureDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstApprovalTree/GetListHrOrgStructure";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListHrOrgStructure(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListHrOrgStructure(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HrOrgStructureDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HrOrgStructureDto[]>;
        }));
    }

    protected processGetListHrOrgStructure(response: HttpResponseBase): Observable<HrOrgStructureDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HrOrgStructureDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HrOrgStructureDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getListTitle(): Observable<TitleDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstApprovalTree/GetListTitle";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListTitle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListTitle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TitleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TitleDto[]>;
        }));
    }

    protected processGetListTitle(response: HttpResponseBase): Observable<TitleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TitleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TitleDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getListCurrency(): Observable<CurrencyDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstApprovalTree/GetListCurrency";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListCurrency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListCurrency(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrencyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrencyDto[]>;
        }));
    }

    protected processGetListCurrency(response: HttpResponseBase): Observable<CurrencyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CurrencyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrencyDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getHrOrgInternal(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstApprovalTree/GetHrOrgInternal";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHrOrgInternal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHrOrgInternal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetHrOrgInternal(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param processTypeId (optional) 
     * @param creationTime (optional) 
     * @param inventoryGroupId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllApproval(processTypeId: number | undefined, creationTime: DateTime | null | undefined, inventoryGroupId: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfApprovalTreeOutputSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/MstApprovalTree/getAllApproval?";
        if (processTypeId === null)
            throw new Error("The parameter 'processTypeId' cannot be null.");
        else if (processTypeId !== undefined)
            url_ += "ProcessTypeId=" + encodeURIComponent("" + processTypeId) + "&";
        if (creationTime !== undefined && creationTime !== null)
            url_ += "CreationTime=" + encodeURIComponent(creationTime ? "" + creationTime.toString() : "") + "&";
        if (inventoryGroupId === null)
            throw new Error("The parameter 'inventoryGroupId' cannot be null.");
        else if (inventoryGroupId !== undefined)
            url_ += "InventoryGroupId=" + encodeURIComponent("" + inventoryGroupId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllApproval(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllApproval(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfApprovalTreeOutputSelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfApprovalTreeOutputSelectDto>;
        }));
    }

    protected processGetAllApproval(response: HttpResponseBase): Observable<PagedResultDtoOfApprovalTreeOutputSelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfApprovalTreeOutputSelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfApprovalTreeOutputSelectDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    loadById(id: number | undefined): Observable<ApprovalTreeSaveDto> {
        let url_ = this.baseUrl + "/api/services/app/MstApprovalTree/LoadById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApprovalTreeSaveDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApprovalTreeSaveDto>;
        }));
    }

    protected processLoadById(response: HttpResponseBase): Observable<ApprovalTreeSaveDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalTreeSaveDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalTreeSaveDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: ApprovalTreeSaveDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstApprovalTree/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDetailApprovalTree(id: number | undefined): Observable<ApprovalTreeDetailSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/MstApprovalTree/getDetailApprovalTree?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetailApprovalTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetailApprovalTree(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApprovalTreeDetailSelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApprovalTreeDetailSelectDto>;
        }));
    }

    protected processGetDetailApprovalTree(response: HttpResponseBase): Observable<ApprovalTreeDetailSelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalTreeDetailSelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApprovalTreeDetailSelectDto>(null as any);
    }

    /**
     * @return Success
     */
    getListPosition(): Observable<PositionDropdownDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstApprovalTree/GetListPosition";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListPosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PositionDropdownDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PositionDropdownDto[]>;
        }));
    }

    protected processGetListPosition(response: HttpResponseBase): Observable<PositionDropdownDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PositionDropdownDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PositionDropdownDto[]>(null as any);
    }
}

@Injectable()
export class MstAssessServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchValue (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAssessDataInfo(searchValue: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAssessInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/MstAssess/GetAssessDataInfo?";
        if (searchValue !== undefined && searchValue !== null)
            url_ += "SearchValue=" + encodeURIComponent("" + searchValue) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssessDataInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssessDataInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAssessInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAssessInfoDto>;
        }));
    }

    protected processGetAssessDataInfo(response: HttpResponseBase): Observable<PagedResultDtoOfAssessInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAssessInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAssessInfoDto>(null as any);
    }

    /**
     * @param searchValue (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAssessGroupDataInfo(searchValue: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAssessGroupInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/MstAssess/GetAssessGroupDataInfo?";
        if (searchValue !== undefined && searchValue !== null)
            url_ += "SearchValue=" + encodeURIComponent("" + searchValue) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssessGroupDataInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssessGroupDataInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAssessGroupInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAssessGroupInfoDto>;
        }));
    }

    protected processGetAssessGroupDataInfo(response: HttpResponseBase): Observable<PagedResultDtoOfAssessGroupInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAssessGroupInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAssessGroupInfoDto>(null as any);
    }

    /**
     * @param assessGroupId (optional) 
     * @return Success
     */
    getAssessGroupDetailDataInfo(assessGroupId: number | null | undefined): Observable<AssessDetailInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstAssess/GetAssessGroupDetailDataInfo?";
        if (assessGroupId !== undefined && assessGroupId !== null)
            url_ += "assessGroupId=" + encodeURIComponent("" + assessGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssessGroupDetailDataInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssessGroupDetailDataInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssessDetailInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssessDetailInfoDto[]>;
        }));
    }

    protected processGetAssessGroupDetailDataInfo(response: HttpResponseBase): Observable<AssessDetailInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssessDetailInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssessDetailInfoDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditAssessGroup(body: AssessGroupInfoDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstAssess/CreateOrEditAssessGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditAssessGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditAssessGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEditAssessGroup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param assessId (optional) 
     * @return Success
     */
    getAssessDetailDataInfo(assessId: number | undefined): Observable<AssessDetailInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstAssess/GetAssessDetailDataInfo?";
        if (assessId === null)
            throw new Error("The parameter 'assessId' cannot be null.");
        else if (assessId !== undefined)
            url_ += "assessId=" + encodeURIComponent("" + assessId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssessDetailDataInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssessDetailDataInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssessDetailInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssessDetailInfoDto[]>;
        }));
    }

    protected processGetAssessDetailDataInfo(response: HttpResponseBase): Observable<AssessDetailInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssessDetailInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssessDetailInfoDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditAssess(body: AssessInfoDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstAssess/CreateOrEditAssess";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditAssess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditAssess(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEditAssess(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditAssessDetail(body: AssessDetailInfoDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstAssess/CreateOrEditAssessDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditAssessDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditAssessDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEditAssessDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteAssess(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstAssess/DeleteAssess?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssess(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAssess(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteAssessDetail(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstAssess/DeleteAssessDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssessDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssessDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAssessDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteAssessGroup(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstAssess/DeleteAssessGroup?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssessGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssessGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAssessGroup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class MstCancelReasonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteCancelReason(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstCancelReason/DeleteCancelReason?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCancelReason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCancelReason(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteCancelReason(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllCancelReason(keyword: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfInputCancelReasonDto> {
        let url_ = this.baseUrl + "/api/services/app/MstCancelReason/getAllCancelReason?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCancelReason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCancelReason(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfInputCancelReasonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfInputCancelReasonDto>;
        }));
    }

    protected processGetAllCancelReason(response: HttpResponseBase): Observable<PagedResultDtoOfInputCancelReasonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfInputCancelReasonDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfInputCancelReasonDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    loadById(id: number | undefined): Observable<InputCancelReasonDto> {
        let url_ = this.baseUrl + "/api/services/app/MstCancelReason/LoadById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InputCancelReasonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InputCancelReasonDto>;
        }));
    }

    protected processLoadById(response: HttpResponseBase): Observable<InputCancelReasonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InputCancelReasonDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InputCancelReasonDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: InputCancelReasonDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstCancelReason/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class MstCatalogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllData(filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSearchCatalogOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/MstCatalog/GetAllData?";
        if (filterText !== undefined && filterText !== null)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfSearchCatalogOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfSearchCatalogOutputDto>;
        }));
    }

    protected processGetAllData(response: HttpResponseBase): Observable<PagedResultDtoOfSearchCatalogOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSearchCatalogOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSearchCatalogOutputDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: SearchCatalogOutputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstCatalog/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstCatalog/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class MstCategoriesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param segment1 (optional) 
     * @return Success
     */
    getAllCategoties(segment1: string | null | undefined): Observable<GetMstCategotiesDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstCategories/getAllCategoties?";
        if (segment1 !== undefined && segment1 !== null)
            url_ += "Segment1=" + encodeURIComponent("" + segment1) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCategoties(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCategoties(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMstCategotiesDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMstCategotiesDto[]>;
        }));
    }

    protected processGetAllCategoties(response: HttpResponseBase): Observable<GetMstCategotiesDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetMstCategotiesDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMstCategotiesDto[]>(null as any);
    }
}

@Injectable()
export class MstContractTemplateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllContractTemplate(keyword: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetContractTemplateDto> {
        let url_ = this.baseUrl + "/api/services/app/MstContractTemplate/getAllContractTemplate?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllContractTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllContractTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetContractTemplateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetContractTemplateDto>;
        }));
    }

    protected processGetAllContractTemplate(response: HttpResponseBase): Observable<PagedResultDtoOfGetContractTemplateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetContractTemplateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetContractTemplateDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    loadById(id: number | undefined): Observable<InputContractTemplateDto> {
        let url_ = this.baseUrl + "/api/services/app/MstContractTemplate/LoadById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InputContractTemplateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InputContractTemplateDto>;
        }));
    }

    protected processLoadById(response: HttpResponseBase): Observable<InputContractTemplateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InputContractTemplateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InputContractTemplateDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: InputContractTemplateDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/MstContractTemplate/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteContractTemplate(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstContractTemplate/DeleteContractTemplate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContractTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContractTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteContractTemplate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param contractId (optional) 
     * @return Success
     */
    deleteAttachment(contractId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstContractTemplate/DeleteAttachment?";
        if (contractId === null)
            throw new Error("The parameter 'contractId' cannot be null.");
        else if (contractId !== undefined)
            url_ += "ContractId=" + encodeURIComponent("" + contractId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAttachment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class MstCurrencyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstCurrency/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param hasAll (optional) 
     * @return Success
     */
    loadAll(hasAll: boolean | undefined): Observable<LoadAllOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstCurrency/LoadAll?";
        if (hasAll === null)
            throw new Error("The parameter 'hasAll' cannot be null.");
        else if (hasAll !== undefined)
            url_ += "hasAll=" + encodeURIComponent("" + hasAll) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoadAllOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoadAllOutputDto[]>;
        }));
    }

    protected processLoadAll(response: HttpResponseBase): Observable<LoadAllOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LoadAllOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoadAllOutputDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    loadAllCurrency(body: InputSearchMstCurrency | undefined): Observable<PagedResultDtoOfMstCurrencySelectDto> {
        let url_ = this.baseUrl + "/api/services/app/MstCurrency/LoadAllCurrency";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadAllCurrency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadAllCurrency(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMstCurrencySelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMstCurrencySelectDto>;
        }));
    }

    protected processLoadAllCurrency(response: HttpResponseBase): Observable<PagedResultDtoOfMstCurrencySelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMstCurrencySelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMstCurrencySelectDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    loadById(id: number | undefined): Observable<MstCurrencyDto> {
        let url_ = this.baseUrl + "/api/services/app/MstCurrency/LoadById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MstCurrencyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MstCurrencyDto>;
        }));
    }

    protected processLoadById(response: HttpResponseBase): Observable<MstCurrencyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MstCurrencyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MstCurrencyDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: MstCurrencyDto | undefined): Observable<ValInventoryGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/MstCurrency/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValInventoryGroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValInventoryGroupDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<ValInventoryGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValInventoryGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValInventoryGroupDto>(null as any);
    }

    /**
     * @return Success
     */
    loadAllCurrencyNoPage(): Observable<MstCurrencySelectDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstCurrency/LoadAllCurrencyNoPage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadAllCurrencyNoPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadAllCurrencyNoPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MstCurrencySelectDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MstCurrencySelectDto[]>;
        }));
    }

    protected processLoadAllCurrencyNoPage(response: HttpResponseBase): Observable<MstCurrencySelectDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MstCurrencySelectDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MstCurrencySelectDto[]>(null as any);
    }
}

@Injectable()
export class MstDistrictServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getByProvinceId(): Observable<GetByProvinceIdOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstDistrict/GetByProvinceId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByProvinceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByProvinceId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetByProvinceIdOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetByProvinceIdOutputDto[]>;
        }));
    }

    protected processGetByProvinceId(response: HttpResponseBase): Observable<GetByProvinceIdOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetByProvinceIdOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetByProvinceIdOutputDto[]>(null as any);
    }
}

@Injectable()
export class MstDocumentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param code (optional) 
     * @param name (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMstDocumentSearch(code: string | null | undefined, name: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfMstDocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/MstDocument/getMstDocumentSearch?";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMstDocumentSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMstDocumentSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMstDocumentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMstDocumentDto>;
        }));
    }

    protected processGetMstDocumentSearch(response: HttpResponseBase): Observable<PagedResultDtoOfMstDocumentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMstDocumentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMstDocumentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mstDocumentExcel(body: InputDocumentDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstDocument/MstDocumentExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstDocumentExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstDocumentExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processMstDocumentExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mstDocumentExportExcel(body: InputDocumentDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstDocument/MstDocumentExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstDocumentExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstDocumentExportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processMstDocumentExportExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mstDocumentInsert(body: MstDocumentDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstDocument/MstDocumentInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstDocumentInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstDocumentInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processMstDocumentInsert(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mstDocumentUpdate(body: MstDocumentDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstDocument/MstDocumentUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstDocumentUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstDocumentUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processMstDocumentUpdate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    mstInventoryGroupGetAll(): Observable<MasterLookupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstDocument/MstInventoryGroupGetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstInventoryGroupGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstInventoryGroupGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MasterLookupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MasterLookupDto[]>;
        }));
    }

    protected processMstInventoryGroupGetAll(response: HttpResponseBase): Observable<MasterLookupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MasterLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MasterLookupDto[]>(null as any);
    }

    /**
     * @return Success
     */
    mstPRoductTypeGetAll(): Observable<ProcessTypeGetAllOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstDocument/MstPRoductTypeGetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstPRoductTypeGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstPRoductTypeGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessTypeGetAllOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessTypeGetAllOutputDto[]>;
        }));
    }

    protected processMstPRoductTypeGetAll(response: HttpResponseBase): Observable<ProcessTypeGetAllOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProcessTypeGetAllOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessTypeGetAllOutputDto[]>(null as any);
    }
}

@Injectable()
export class MstGlCodeCombinationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllData(keyword: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSearchGlCodeOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/MstGlCodeCombination/GetAllData?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfSearchGlCodeOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfSearchGlCodeOutputDto>;
        }));
    }

    protected processGetAllData(response: HttpResponseBase): Observable<PagedResultDtoOfSearchGlCodeOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSearchGlCodeOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSearchGlCodeOutputDto>(null as any);
    }
}

@Injectable()
export class MstGlExchangeRateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param currencyId (optional) 
     * @param toCurrencyId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllData(currencyId: number | null | undefined, toCurrencyId: number | null | undefined, startDate: DateTime | null | undefined, endDate: DateTime | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSearchOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/MstGlExchangeRate/GetAllData?";
        if (currencyId !== undefined && currencyId !== null)
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (toCurrencyId !== undefined && toCurrencyId !== null)
            url_ += "ToCurrencyId=" + encodeURIComponent("" + toCurrencyId) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfSearchOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfSearchOutputDto>;
        }));
    }

    protected processGetAllData(response: HttpResponseBase): Observable<PagedResultDtoOfSearchOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSearchOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSearchOutputDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: SearchOutputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstGlExchangeRate/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstGlExchangeRate/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mstGlExchangeRateExportExcel(body: InputMstGlExchangeRateExportDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstGlExchangeRate/MstGlExchangeRateExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstGlExchangeRateExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstGlExchangeRateExportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processMstGlExchangeRateExportExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class MstHrOrgStructureServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllActive(): Observable<MstHrOrgStructureOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstHrOrgStructure/GetAllActive";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MstHrOrgStructureOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MstHrOrgStructureOutputDto[]>;
        }));
    }

    protected processGetAllActive(response: HttpResponseBase): Observable<MstHrOrgStructureOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MstHrOrgStructureOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MstHrOrgStructureOutputDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getUserByHrOrgStructureId(): Observable<MstHrOrgStructureEmployeeOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstHrOrgStructure/GetUserByHrOrgStructureId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserByHrOrgStructureId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserByHrOrgStructureId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MstHrOrgStructureEmployeeOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MstHrOrgStructureEmployeeOutputDto[]>;
        }));
    }

    protected processGetUserByHrOrgStructureId(response: HttpResponseBase): Observable<MstHrOrgStructureEmployeeOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MstHrOrgStructureEmployeeOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MstHrOrgStructureEmployeeOutputDto[]>(null as any);
    }

    /**
     * @param hrOrgId (optional) 
     * @param positionId (optional) 
     * @return Success
     */
    getListUserByHrOrg(hrOrgId: string | null | undefined, positionId: number | undefined): Observable<UserSearchByHrOgrDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstHrOrgStructure/GetListUserByHrOrg?";
        if (hrOrgId !== undefined && hrOrgId !== null)
            url_ += "HrOrgId=" + encodeURIComponent("" + hrOrgId) + "&";
        if (positionId === null)
            throw new Error("The parameter 'positionId' cannot be null.");
        else if (positionId !== undefined)
            url_ += "positionId=" + encodeURIComponent("" + positionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListUserByHrOrg(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListUserByHrOrg(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserSearchByHrOgrDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserSearchByHrOgrDto[]>;
        }));
    }

    protected processGetListUserByHrOrg(response: HttpResponseBase): Observable<UserSearchByHrOgrDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserSearchByHrOgrDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserSearchByHrOgrDto[]>(null as any);
    }
}

@Injectable()
export class MstInventoryCodeConfigServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param inventoryGroupCode (optional) 
     * @param inventoryGroupName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMstInventoryCodeConfigSearch(inventoryGroupCode: string | null | undefined, inventoryGroupName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfMstInventoryCodeConfigDto> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryCodeConfig/getMstInventoryCodeConfigSearch?";
        if (inventoryGroupCode !== undefined && inventoryGroupCode !== null)
            url_ += "InventoryGroupCode=" + encodeURIComponent("" + inventoryGroupCode) + "&";
        if (inventoryGroupName !== undefined && inventoryGroupName !== null)
            url_ += "InventoryGroupName=" + encodeURIComponent("" + inventoryGroupName) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMstInventoryCodeConfigSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMstInventoryCodeConfigSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMstInventoryCodeConfigDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMstInventoryCodeConfigDto>;
        }));
    }

    protected processGetMstInventoryCodeConfigSearch(response: HttpResponseBase): Observable<PagedResultDtoOfMstInventoryCodeConfigDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMstInventoryCodeConfigDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMstInventoryCodeConfigDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mstInventoryCodeConfigExportExcel(body: InputSearchInventoryCodeConfigDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryCodeConfig/MstInventoryCodeConfigExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstInventoryCodeConfigExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstInventoryCodeConfigExportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processMstInventoryCodeConfigExportExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mstInventoryCodeConfigInsert(body: MstInventoryCodeConfigDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryCodeConfig/MstInventoryCodeConfigInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstInventoryCodeConfigInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstInventoryCodeConfigInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processMstInventoryCodeConfigInsert(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mstInventoryCodeConfigUpdate(body: MstInventoryCodeConfigDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryCodeConfig/MstInventoryCodeConfigUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstInventoryCodeConfigUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstInventoryCodeConfigUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processMstInventoryCodeConfigUpdate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    getAllInventoryGroup(): Observable<MstInventoryCodeConfigDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryCodeConfig/getAllInventoryGroup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInventoryGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInventoryGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MstInventoryCodeConfigDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MstInventoryCodeConfigDto[]>;
        }));
    }

    protected processGetAllInventoryGroup(response: HttpResponseBase): Observable<MstInventoryCodeConfigDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MstInventoryCodeConfigDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MstInventoryCodeConfigDto[]>(null as any);
    }
}

@Injectable()
export class MstInventoryGroupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllInventoryGroup(): Observable<GetMstInventoryGroupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryGroup/getAllInventoryGroup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInventoryGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInventoryGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMstInventoryGroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMstInventoryGroupDto[]>;
        }));
    }

    protected processGetAllInventoryGroup(response: HttpResponseBase): Observable<GetMstInventoryGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetMstInventoryGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMstInventoryGroupDto[]>(null as any);
    }

    /**
     * @param iventoryGroupName (optional) 
     * @param iventoryGroupCode (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(iventoryGroupName: string | null | undefined, iventoryGroupCode: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfMstInventoryGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryGroup/getAll?";
        if (iventoryGroupName !== undefined && iventoryGroupName !== null)
            url_ += "IventoryGroupName=" + encodeURIComponent("" + iventoryGroupName) + "&";
        if (iventoryGroupCode !== undefined && iventoryGroupCode !== null)
            url_ += "IventoryGroupCode=" + encodeURIComponent("" + iventoryGroupCode) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMstInventoryGroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMstInventoryGroupDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfMstInventoryGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMstInventoryGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMstInventoryGroupDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInventoryGroupById(id: number | undefined): Observable<MstInventoryGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryGroup/getInventoryGroupById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInventoryGroupById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInventoryGroupById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MstInventoryGroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MstInventoryGroupDto>;
        }));
    }

    protected processGetInventoryGroupById(response: HttpResponseBase): Observable<MstInventoryGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MstInventoryGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MstInventoryGroupDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: MstInventoryGroupDto | undefined): Observable<ValInventoryGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryGroup/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValInventoryGroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValInventoryGroupDto>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<ValInventoryGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValInventoryGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValInventoryGroupDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteInventoryGroup(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryGroup/deleteInventoryGroup?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInventoryGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInventoryGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteInventoryGroup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getAllMstHr(): Observable<MasterLookupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryGroup/getAllMstHr";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMstHr(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMstHr(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MasterLookupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MasterLookupDto[]>;
        }));
    }

    protected processGetAllMstHr(response: HttpResponseBase): Observable<MasterLookupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MasterLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MasterLookupDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllProductGroup(): Observable<MasterLookupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryGroup/getAllProductGroup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MasterLookupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MasterLookupDto[]>;
        }));
    }

    protected processGetAllProductGroup(response: HttpResponseBase): Observable<MasterLookupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MasterLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MasterLookupDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mstInventoryGroupExportExcel(body: InputMstInventoryGroupExportDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryGroup/MstInventoryGroupExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstInventoryGroupExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstInventoryGroupExportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processMstInventoryGroupExportExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class MstInventoryItemPriceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param inventoryItemId (optional) 
     * @return Success
     */
    getByInventoryItem(inventoryItemId: number | undefined): Observable<PagedResultDtoOfGetByInventoryItemOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryItemPrice/GetByInventoryItem?";
        if (inventoryItemId === null)
            throw new Error("The parameter 'inventoryItemId' cannot be null.");
        else if (inventoryItemId !== undefined)
            url_ += "InventoryItemId=" + encodeURIComponent("" + inventoryItemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByInventoryItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByInventoryItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetByInventoryItemOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetByInventoryItemOutputDto>;
        }));
    }

    protected processGetByInventoryItem(response: HttpResponseBase): Observable<PagedResultDtoOfGetByInventoryItemOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetByInventoryItemOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetByInventoryItemOutputDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditInventoryItemPrice(body: CreateOrEditInventoryItemPriceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryItemPrice/CreateOrEditInventoryItemPrice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditInventoryItemPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditInventoryItemPrice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEditInventoryItemPrice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInventoryItemPriceForEdit(id: number | undefined): Observable<GetInventoryItemPriceForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryItemPrice/GetInventoryItemPriceForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInventoryItemPriceForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInventoryItemPriceForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetInventoryItemPriceForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetInventoryItemPriceForEditOutput>;
        }));
    }

    protected processGetInventoryItemPriceForEdit(response: HttpResponseBase): Observable<GetInventoryItemPriceForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetInventoryItemPriceForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInventoryItemPriceForEditOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createImpInventoryItemPriceDto(body: ImpInventoryItemPriceDto[] | null | undefined): Observable<ImpInventoryItemPriceDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryItemPrice/CreateImpInventoryItemPriceDto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateImpInventoryItemPriceDto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateImpInventoryItemPriceDto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpInventoryItemPriceDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpInventoryItemPriceDto[]>;
        }));
    }

    protected processCreateImpInventoryItemPriceDto(response: HttpResponseBase): Observable<ImpInventoryItemPriceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ImpInventoryItemPriceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpInventoryItemPriceDto[]>(null as any);
    }

    /**
     * @param inventoryItemPriceId (optional) 
     * @return Success
     */
    getByInventoryPriceItem(inventoryItemPriceId: number | undefined): Observable<PagedResultDtoOfGetByInventoryItemPriceOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryItemPrice/GetByInventoryPriceItem?";
        if (inventoryItemPriceId === null)
            throw new Error("The parameter 'inventoryItemPriceId' cannot be null.");
        else if (inventoryItemPriceId !== undefined)
            url_ += "InventoryItemPriceId=" + encodeURIComponent("" + inventoryItemPriceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByInventoryPriceItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByInventoryPriceItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetByInventoryItemPriceOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetByInventoryItemPriceOutputDto>;
        }));
    }

    protected processGetByInventoryPriceItem(response: HttpResponseBase): Observable<PagedResultDtoOfGetByInventoryItemPriceOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetByInventoryItemPriceOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetByInventoryItemPriceOutputDto>(null as any);
    }
}

@Injectable()
export class MstInventoryItemsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchInventoryItems(body: InventoryItemsSearchInputDto | undefined): Observable<PagedResultDtoOfInventoryItemsSearchOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryItems/searchInventoryItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchInventoryItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchInventoryItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfInventoryItemsSearchOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfInventoryItemsSearchOutputDto>;
        }));
    }

    protected processSearchInventoryItems(response: HttpResponseBase): Observable<PagedResultDtoOfInventoryItemsSearchOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfInventoryItemsSearchOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfInventoryItemsSearchOutputDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mstProductMngtInsert(body: InventoryItemsSearchOutputDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryItems/MstProductMngtInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstProductMngtInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstProductMngtInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processMstProductMngtInsert(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mstProductMngtUpdate(body: InventoryItemsSearchOutputDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryItems/MstProductMngtUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstProductMngtUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstProductMngtUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processMstProductMngtUpdate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param type (optional) 
     * @return Success
     */
    exportTemplate(type: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryItems/ExportTemplate?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processExportTemplate(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createImpInventoryItemDto(body: ProductImportDto[] | null | undefined): Observable<ProductImportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryItems/CreateImpInventoryItemDto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateImpInventoryItemDto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateImpInventoryItemDto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductImportDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductImportDto[]>;
        }));
    }

    protected processCreateImpInventoryItemDto(response: HttpResponseBase): Observable<ProductImportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductImportDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductImportDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchInventoryPrice(body: InventoryPriceSearchInputDto | undefined): Observable<PagedResultDtoOfInventoryPriceSearchOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryItems/searchInventoryPrice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchInventoryPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchInventoryPrice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfInventoryPriceSearchOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfInventoryPriceSearchOutputDto>;
        }));
    }

    protected processSearchInventoryPrice(response: HttpResponseBase): Observable<PagedResultDtoOfInventoryPriceSearchOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfInventoryPriceSearchOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfInventoryPriceSearchOutputDto>(null as any);
    }

    /**
     * @return Success
     */
    getAllVendor(): Observable<VendorComboboxDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryItems/getAllVendor";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVendor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorComboboxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorComboboxDto[]>;
        }));
    }

    protected processGetAllVendor(response: HttpResponseBase): Observable<VendorComboboxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VendorComboboxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorComboboxDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllCurrency(): Observable<CurrencyComboboxDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryItems/getAllCurrency";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCurrency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCurrency(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrencyComboboxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrencyComboboxDto[]>;
        }));
    }

    protected processGetAllCurrency(response: HttpResponseBase): Observable<CurrencyComboboxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CurrencyComboboxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrencyComboboxDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllMstUnitOfMeasure(): Observable<MasterLookupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryItems/GetAllMstUnitOfMeasure";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMstUnitOfMeasure(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMstUnitOfMeasure(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MasterLookupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MasterLookupDto[]>;
        }));
    }

    protected processGetAllMstUnitOfMeasure(response: HttpResponseBase): Observable<MasterLookupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MasterLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MasterLookupDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllInventoryGroup(): Observable<MstInventoryCodeConfigDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryItems/GetAllInventoryGroup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInventoryGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInventoryGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MstInventoryCodeConfigDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MstInventoryCodeConfigDto[]>;
        }));
    }

    protected processGetAllInventoryGroup(response: HttpResponseBase): Observable<MstInventoryCodeConfigDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MstInventoryCodeConfigDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MstInventoryCodeConfigDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditInventoryItem(body: MstInventoryItemsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryItems/CreateOrEditInventoryItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditInventoryItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditInventoryItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEditInventoryItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getFileByteImage(id: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryItems/GetFileByteImage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFileByteImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFileByteImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetFileByteImage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    mstProductMngtDelete(id: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryItems/MstProductMngtDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstProductMngtDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstProductMngtDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processMstProductMngtDelete(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mstInventoryItemsExportExcel(body: InputInventoryItemsSearchInputDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryItems/MstInventoryItemsExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstInventoryItemsExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstInventoryItemsExportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processMstInventoryItemsExportExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class MstInventoryItemSubInventoriesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param inventoryItemId (optional) 
     * @param organizationId (optional) 
     * @return Success
     */
    getAllItemSubInventories(inventoryItemId: number | undefined, organizationId: number | undefined): Observable<GettemsSubInventoriesDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryItemSubInventories/getAllItemSubInventories?";
        if (inventoryItemId === null)
            throw new Error("The parameter 'inventoryItemId' cannot be null.");
        else if (inventoryItemId !== undefined)
            url_ += "InventoryItemId=" + encodeURIComponent("" + inventoryItemId) + "&";
        if (organizationId === null)
            throw new Error("The parameter 'organizationId' cannot be null.");
        else if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllItemSubInventories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllItemSubInventories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GettemsSubInventoriesDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GettemsSubInventoriesDto[]>;
        }));
    }

    protected processGetAllItemSubInventories(response: HttpResponseBase): Observable<GettemsSubInventoriesDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GettemsSubInventoriesDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GettemsSubInventoriesDto[]>(null as any);
    }

    /**
     * @param inventoryItemId (optional) 
     * @param organizationId (optional) 
     * @return Success
     */
    getAllSubInventories(inventoryItemId: number | undefined, organizationId: number | undefined): Observable<GettemsSubInventoriesDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstInventoryItemSubInventories/getAllSubInventories?";
        if (inventoryItemId === null)
            throw new Error("The parameter 'inventoryItemId' cannot be null.");
        else if (inventoryItemId !== undefined)
            url_ += "InventoryItemId=" + encodeURIComponent("" + inventoryItemId) + "&";
        if (organizationId === null)
            throw new Error("The parameter 'organizationId' cannot be null.");
        else if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubInventories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubInventories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GettemsSubInventoriesDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GettemsSubInventoriesDto[]>;
        }));
    }

    protected processGetAllSubInventories(response: HttpResponseBase): Observable<GettemsSubInventoriesDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GettemsSubInventoriesDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GettemsSubInventoriesDto[]>(null as any);
    }
}

@Injectable()
export class MstLineTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllLineTypes(): Observable<GetMstLineTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstLineType/getAllLineTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLineTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLineTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMstLineTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMstLineTypeDto[]>;
        }));
    }

    protected processGetAllLineTypes(response: HttpResponseBase): Observable<GetMstLineTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetMstLineTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMstLineTypeDto[]>(null as any);
    }
}

@Injectable()
export class MstLocationsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param locationCode (optional) 
     * @return Success
     */
    getAllLocations(locationCode: string | null | undefined): Observable<GetMstLocationsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstLocations/getAllLocations?";
        if (locationCode !== undefined && locationCode !== null)
            url_ += "LocationCode=" + encodeURIComponent("" + locationCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLocations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLocations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMstLocationsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMstLocationsDto[]>;
        }));
    }

    protected processGetAllLocations(response: HttpResponseBase): Observable<GetMstLocationsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetMstLocationsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMstLocationsDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLocationById(id: number | undefined): Observable<GetMstLocationsDto> {
        let url_ = this.baseUrl + "/api/services/app/MstLocations/getLocationById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocationById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocationById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMstLocationsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMstLocationsDto>;
        }));
    }

    protected processGetLocationById(response: HttpResponseBase): Observable<GetMstLocationsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMstLocationsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMstLocationsDto>(null as any);
    }
}

@Injectable()
export class MstNationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllNation(): Observable<GetAllOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstNation/GetAllNation";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllOutputDto[]>;
        }));
    }

    protected processGetAllNation(response: HttpResponseBase): Observable<GetAllOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAllOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllOutputDto[]>(null as any);
    }
}

@Injectable()
export class MstOrganizationsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllOrganizations(): Observable<GetMstOrganizationsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstOrganizations/getAllOrganizations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOrganizations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOrganizations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMstOrganizationsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMstOrganizationsDto[]>;
        }));
    }

    protected processGetAllOrganizations(response: HttpResponseBase): Observable<GetMstOrganizationsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetMstOrganizationsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMstOrganizationsDto[]>(null as any);
    }
}

@Injectable()
export class MstPeriodServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param glDate (optional) 
     * @return Success
     */
    checkGlDate(glDate: DateTime | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/MstPeriod/CheckGlDate?";
        if (glDate === null)
            throw new Error("The parameter 'glDate' cannot be null.");
        else if (glDate !== undefined)
            url_ += "glDate=" + encodeURIComponent(glDate ? "" + glDate.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckGlDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckGlDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckGlDate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @return Success
     */
    getAllPeriodNoPage(): Observable<ListPeriodDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstPeriod/GetAllPeriodNoPage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPeriodNoPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPeriodNoPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListPeriodDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListPeriodDto[]>;
        }));
    }

    protected processGetAllPeriodNoPage(response: HttpResponseBase): Observable<ListPeriodDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ListPeriodDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListPeriodDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    loadAllPeriod(body: InputSearchMstPeriodDto | undefined): Observable<PagedResultDtoOfListPeriodDto> {
        let url_ = this.baseUrl + "/api/services/app/MstPeriod/LoadAllPeriod";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadAllPeriod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadAllPeriod(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfListPeriodDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfListPeriodDto>;
        }));
    }

    protected processLoadAllPeriod(response: HttpResponseBase): Observable<PagedResultDtoOfListPeriodDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfListPeriodDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfListPeriodDto>(null as any);
    }
}

@Injectable()
export class MstProcessTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param hasEmpty (optional) 
     * @return Success
     */
    getAll(hasEmpty: boolean | undefined): Observable<ProcessTypeGetAllOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstProcessType/GetAll?";
        if (hasEmpty === null)
            throw new Error("The parameter 'hasEmpty' cannot be null.");
        else if (hasEmpty !== undefined)
            url_ += "HasEmpty=" + encodeURIComponent("" + hasEmpty) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessTypeGetAllOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessTypeGetAllOutputDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ProcessTypeGetAllOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProcessTypeGetAllOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessTypeGetAllOutputDto[]>(null as any);
    }
}

@Injectable()
export class MstProductGroupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param code (optional) 
     * @param name (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductGroupSearch(code: string | null | undefined, name: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfMstProductGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/MstProductGroup/getProductGroupSearch?";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductGroupSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductGroupSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMstProductGroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMstProductGroupDto>;
        }));
    }

    protected processGetProductGroupSearch(response: HttpResponseBase): Observable<PagedResultDtoOfMstProductGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMstProductGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMstProductGroupDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mstProductGroupExportExcel(body: InputProductGroupDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstProductGroup/MstProductGroupExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstProductGroupExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstProductGroupExportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processMstProductGroupExportExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param p_id (optional) 
     * @return Success
     */
    mstProductGroupGetParentId(p_id: number | undefined): Observable<MstProductGroupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstProductGroup/MstProductGroupGetParentId?";
        if (p_id === null)
            throw new Error("The parameter 'p_id' cannot be null.");
        else if (p_id !== undefined)
            url_ += "p_id=" + encodeURIComponent("" + p_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstProductGroupGetParentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstProductGroupGetParentId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MstProductGroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MstProductGroupDto[]>;
        }));
    }

    protected processMstProductGroupGetParentId(response: HttpResponseBase): Observable<MstProductGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MstProductGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MstProductGroupDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mstProductGroupInsert(body: MstProductGroupDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstProductGroup/MstProductGroupInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstProductGroupInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstProductGroupInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processMstProductGroupInsert(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mstProductGroupUpdate(body: MstProductGroupDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstProductGroup/MstProductGroupUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstProductGroupUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstProductGroupUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processMstProductGroupUpdate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class MstProjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param p_id (optional) 
     * @return Success
     */
    getMstProjectById(p_id: number | undefined): Observable<MstProjectDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstProject/getMstProjectById?";
        if (p_id === null)
            throw new Error("The parameter 'p_id' cannot be null.");
        else if (p_id !== undefined)
            url_ += "p_id=" + encodeURIComponent("" + p_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMstProjectById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMstProjectById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MstProjectDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MstProjectDto[]>;
        }));
    }

    protected processGetMstProjectById(response: HttpResponseBase): Observable<MstProjectDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MstProjectDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MstProjectDto[]>(null as any);
    }

    /**
     * @param projectCode (optional) 
     * @param projectName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMstProjectSearch(projectCode: string | null | undefined, projectName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfMstProjectDto> {
        let url_ = this.baseUrl + "/api/services/app/MstProject/getMstProjectSearch?";
        if (projectCode !== undefined && projectCode !== null)
            url_ += "ProjectCode=" + encodeURIComponent("" + projectCode) + "&";
        if (projectName !== undefined && projectName !== null)
            url_ += "ProjectName=" + encodeURIComponent("" + projectName) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMstProjectSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMstProjectSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMstProjectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMstProjectDto>;
        }));
    }

    protected processGetMstProjectSearch(response: HttpResponseBase): Observable<PagedResultDtoOfMstProjectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMstProjectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMstProjectDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mstProjectExportExcel(body: InputExportProjectDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstProject/MstProjectExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstProjectExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstProjectExportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processMstProjectExportExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mstProjectInsert(body: MstProjectDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstProject/MstProjectInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstProjectInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstProjectInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processMstProjectInsert(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mstProjectUpdate(body: MstProjectDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstProject/MstProjectUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstProjectUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstProjectUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processMstProjectUpdate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mstProjectExportExcelGembox(body: InputSearchMstProject | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/MstProject/MstProjectExportExcelGembox";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstProjectExportExcelGembox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstProjectExportExcelGembox(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processMstProjectExportExcelGembox(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }
}

@Injectable()
export class MstProvinceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getByNationId(): Observable<GetByNationIdOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstProvince/GetByNationId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByNationId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByNationId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetByNationIdOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetByNationIdOutputDto[]>;
        }));
    }

    protected processGetByNationId(response: HttpResponseBase): Observable<GetByNationIdOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetByNationIdOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetByNationIdOutputDto[]>(null as any);
    }
}

@Injectable()
export class MstPurchasePurposeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param purchasePurposeName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllPurchasePurpose(purchasePurposeName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetPurchasePurposeDto> {
        let url_ = this.baseUrl + "/api/services/app/MstPurchasePurpose/getAllPurchasePurpose?";
        if (purchasePurposeName !== undefined && purchasePurposeName !== null)
            url_ += "PurchasePurposeName=" + encodeURIComponent("" + purchasePurposeName) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPurchasePurpose(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPurchasePurpose(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetPurchasePurposeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetPurchasePurposeDto>;
        }));
    }

    protected processGetAllPurchasePurpose(response: HttpResponseBase): Observable<PagedResultDtoOfGetPurchasePurposeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetPurchasePurposeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPurchasePurposeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    loadById(id: number | undefined): Observable<InputPurchasePurposeDto> {
        let url_ = this.baseUrl + "/api/services/app/MstPurchasePurpose/LoadById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InputPurchasePurposeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InputPurchasePurposeDto>;
        }));
    }

    protected processLoadById(response: HttpResponseBase): Observable<InputPurchasePurposeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InputPurchasePurposeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InputPurchasePurposeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: InputPurchasePurposeDto | undefined): Observable<ValInventoryGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/MstPurchasePurpose/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValInventoryGroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValInventoryGroupDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<ValInventoryGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValInventoryGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValInventoryGroupDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deletePurpose(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstPurchasePurpose/DeletePurpose?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePurpose(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePurpose(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePurpose(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkSaveAllImport(body: PurchasePurposeImportDto[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/MstPurchasePurpose/CheckSaveAllImport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckSaveAllImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckSaveAllImport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckSaveAllImport(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveAllImport(body: PurchasePurposeImportDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstPurchasePurpose/SaveAllImport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAllImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAllImport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveAllImport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    exportTemplate(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/MstPurchasePurpose/ExportTemplate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processExportTemplate(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }
}

@Injectable()
export class MstQuotaExpenseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param p_id (optional) 
     * @return Success
     */
    getMstQuotaExpenseById(p_id: number | undefined): Observable<MstQuotaExpenseDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstQuotaExpense/getMstQuotaExpenseById?";
        if (p_id === null)
            throw new Error("The parameter 'p_id' cannot be null.");
        else if (p_id !== undefined)
            url_ += "p_id=" + encodeURIComponent("" + p_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMstQuotaExpenseById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMstQuotaExpenseById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MstQuotaExpenseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MstQuotaExpenseDto[]>;
        }));
    }

    protected processGetMstQuotaExpenseById(response: HttpResponseBase): Observable<MstQuotaExpenseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MstQuotaExpenseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MstQuotaExpenseDto[]>(null as any);
    }

    /**
     * @param quotaCode (optional) 
     * @param quoType (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMstQuotaExpenseSearch(quotaCode: string | null | undefined, quoType: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfMstQuotaExpenseDto> {
        let url_ = this.baseUrl + "/api/services/app/MstQuotaExpense/getMstQuotaExpenseSearch?";
        if (quotaCode !== undefined && quotaCode !== null)
            url_ += "QuotaCode=" + encodeURIComponent("" + quotaCode) + "&";
        if (quoType === null)
            throw new Error("The parameter 'quoType' cannot be null.");
        else if (quoType !== undefined)
            url_ += "QuoType=" + encodeURIComponent("" + quoType) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMstQuotaExpenseSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMstQuotaExpenseSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMstQuotaExpenseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMstQuotaExpenseDto>;
        }));
    }

    protected processGetMstQuotaExpenseSearch(response: HttpResponseBase): Observable<PagedResultDtoOfMstQuotaExpenseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMstQuotaExpenseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMstQuotaExpenseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mstQuotaExpenseExportExcel(body: InputExportQuotaExpenseDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstQuotaExpense/MstQuotaExpenseExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstQuotaExpenseExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstQuotaExpenseExportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processMstQuotaExpenseExportExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mstQuotaExpenseInsert(body: MstQuotaExpenseDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstQuotaExpense/MstQuotaExpenseInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstQuotaExpenseInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstQuotaExpenseInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processMstQuotaExpenseInsert(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mstQuotaExpenseUpdate(body: MstQuotaExpenseDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstQuotaExpense/MstQuotaExpenseUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstQuotaExpenseUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstQuotaExpenseUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processMstQuotaExpenseUpdate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    getAllMstCurrency(): Observable<MasterLookupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstQuotaExpense/GetAllMstCurrency";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMstCurrency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMstCurrency(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MasterLookupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MasterLookupDto[]>;
        }));
    }

    protected processGetAllMstCurrency(response: HttpResponseBase): Observable<MasterLookupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MasterLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MasterLookupDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllMstTitle(): Observable<MasterLookupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstQuotaExpense/GetAllMstTitle";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMstTitle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMstTitle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MasterLookupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MasterLookupDto[]>;
        }));
    }

    protected processGetAllMstTitle(response: HttpResponseBase): Observable<MasterLookupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MasterLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MasterLookupDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllMstUnitOfMeasure(): Observable<MasterLookupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstQuotaExpense/GetAllMstUnitOfMeasure";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMstUnitOfMeasure(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMstUnitOfMeasure(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MasterLookupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MasterLookupDto[]>;
        }));
    }

    protected processGetAllMstUnitOfMeasure(response: HttpResponseBase): Observable<MasterLookupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MasterLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MasterLookupDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllMstInventoryGroup(): Observable<MasterLookupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstQuotaExpense/GetAllMstInventoryGroup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMstInventoryGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMstInventoryGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MasterLookupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MasterLookupDto[]>;
        }));
    }

    protected processGetAllMstInventoryGroup(response: HttpResponseBase): Observable<MasterLookupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MasterLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MasterLookupDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllMstHrOrgStructure(): Observable<MasterLookupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstQuotaExpense/GetAllMstHrOrgStructure";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMstHrOrgStructure(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMstHrOrgStructure(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MasterLookupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MasterLookupDto[]>;
        }));
    }

    protected processGetAllMstHrOrgStructure(response: HttpResponseBase): Observable<MasterLookupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MasterLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MasterLookupDto[]>(null as any);
    }
}

@Injectable()
export class MstSupplierServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getListSupplierDropdown(): Observable<SupplierDropdownDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplier/GetListSupplierDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListSupplierDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListSupplierDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierDropdownDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierDropdownDto[]>;
        }));
    }

    protected processGetListSupplierDropdown(response: HttpResponseBase): Observable<SupplierDropdownDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SupplierDropdownDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierDropdownDto[]>(null as any);
    }

    /**
     * @param supplierName (optional) 
     * @param vatRegistrationNum (optional) 
     * @param vatRegistrationInvoice (optional) 
     * @param supplierNumber (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllSupplier(supplierName: string | null | undefined, vatRegistrationNum: string | null | undefined, vatRegistrationInvoice: string | null | undefined, supplierNumber: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSupplierOutputSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplier/GetAllSupplier?";
        if (supplierName !== undefined && supplierName !== null)
            url_ += "SupplierName=" + encodeURIComponent("" + supplierName) + "&";
        if (vatRegistrationNum !== undefined && vatRegistrationNum !== null)
            url_ += "VatRegistrationNum=" + encodeURIComponent("" + vatRegistrationNum) + "&";
        if (vatRegistrationInvoice !== undefined && vatRegistrationInvoice !== null)
            url_ += "VatRegistrationInvoice=" + encodeURIComponent("" + vatRegistrationInvoice) + "&";
        if (supplierNumber !== undefined && supplierNumber !== null)
            url_ += "SupplierNumber=" + encodeURIComponent("" + supplierNumber) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSupplier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSupplier(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfSupplierOutputSelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfSupplierOutputSelectDto>;
        }));
    }

    protected processGetAllSupplier(response: HttpResponseBase): Observable<PagedResultDtoOfSupplierOutputSelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSupplierOutputSelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSupplierOutputSelectDto>(null as any);
    }

    /**
     * @param filterInvoice (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllSupplierForPayment(filterInvoice: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSupplierOutputSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplier/GetAllSupplierForPayment?";
        if (filterInvoice !== undefined && filterInvoice !== null)
            url_ += "FilterInvoice=" + encodeURIComponent("" + filterInvoice) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSupplierForPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSupplierForPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfSupplierOutputSelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfSupplierOutputSelectDto>;
        }));
    }

    protected processGetAllSupplierForPayment(response: HttpResponseBase): Observable<PagedResultDtoOfSupplierOutputSelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSupplierOutputSelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSupplierOutputSelectDto>(null as any);
    }

    /**
     * @param supplierId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllSupplierSiteBySupplierId(supplierId: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSupplierSiteOutputSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplier/GetAllSupplierSiteBySupplierId?";
        if (supplierId === null)
            throw new Error("The parameter 'supplierId' cannot be null.");
        else if (supplierId !== undefined)
            url_ += "SupplierId=" + encodeURIComponent("" + supplierId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSupplierSiteBySupplierId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSupplierSiteBySupplierId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfSupplierSiteOutputSelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfSupplierSiteOutputSelectDto>;
        }));
    }

    protected processGetAllSupplierSiteBySupplierId(response: HttpResponseBase): Observable<PagedResultDtoOfSupplierSiteOutputSelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSupplierSiteOutputSelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSupplierSiteOutputSelectDto>(null as any);
    }

    /**
     * @param supplierSiteId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllSupplierContactBySupplierSiteId(supplierSiteId: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSupplierContacOutputSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplier/GetAllSupplierContactBySupplierSiteId?";
        if (supplierSiteId === null)
            throw new Error("The parameter 'supplierSiteId' cannot be null.");
        else if (supplierSiteId !== undefined)
            url_ += "SupplierSiteId=" + encodeURIComponent("" + supplierSiteId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSupplierContactBySupplierSiteId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSupplierContactBySupplierSiteId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfSupplierContacOutputSelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfSupplierContacOutputSelectDto>;
        }));
    }

    protected processGetAllSupplierContactBySupplierSiteId(response: HttpResponseBase): Observable<PagedResultDtoOfSupplierContacOutputSelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSupplierContacOutputSelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSupplierContacOutputSelectDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteContact(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplier/DeleteContact?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    loadById(id: number | undefined): Observable<SupplierContactSaveDto> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplier/LoadById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierContactSaveDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierContactSaveDto>;
        }));
    }

    protected processLoadById(response: HttpResponseBase): Observable<SupplierContactSaveDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SupplierContactSaveDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierContactSaveDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSupplierName(id: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplier/GetSupplierName?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSupplierName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSupplierName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetSupplierName(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: SupplierContactSaveDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplier/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param supplierName (optional) 
     * @return Success
     */
    getAllSupplierNotPaged(supplierName: string | null | undefined): Observable<SupplierOutputSelectDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplier/GetAllSupplierNotPaged?";
        if (supplierName !== undefined && supplierName !== null)
            url_ += "SupplierName=" + encodeURIComponent("" + supplierName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSupplierNotPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSupplierNotPaged(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierOutputSelectDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierOutputSelectDto[]>;
        }));
    }

    protected processGetAllSupplierNotPaged(response: HttpResponseBase): Observable<SupplierOutputSelectDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SupplierOutputSelectDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierOutputSelectDto[]>(null as any);
    }

    /**
     * @param supplierId (optional) 
     * @param siteName (optional) 
     * @return Success
     */
    getAllSupplierSiteBySupplierIdNotPaged(supplierId: number | undefined, siteName: string | null | undefined): Observable<SupplierSiteOutputSelectDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplier/GetAllSupplierSiteBySupplierIdNotPaged?";
        if (supplierId === null)
            throw new Error("The parameter 'supplierId' cannot be null.");
        else if (supplierId !== undefined)
            url_ += "SupplierId=" + encodeURIComponent("" + supplierId) + "&";
        if (siteName !== undefined && siteName !== null)
            url_ += "SiteName=" + encodeURIComponent("" + siteName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSupplierSiteBySupplierIdNotPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSupplierSiteBySupplierIdNotPaged(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierSiteOutputSelectDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierSiteOutputSelectDto[]>;
        }));
    }

    protected processGetAllSupplierSiteBySupplierIdNotPaged(response: HttpResponseBase): Observable<SupplierSiteOutputSelectDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SupplierSiteOutputSelectDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierSiteOutputSelectDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveSupplier(body: SupplierSaveDto | undefined): Observable<ValSupplierSaveDto> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplier/SaveSupplier";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveSupplier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveSupplier(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValSupplierSaveDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValSupplierSaveDto>;
        }));
    }

    protected processSaveSupplier(response: HttpResponseBase): Observable<ValSupplierSaveDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValSupplierSaveDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValSupplierSaveDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteSupplier(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplier/DeleteSupplier?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSupplier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSupplier(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteSupplier(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    loadSupplierById(id: number | undefined): Observable<SupplierSaveDto> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplier/LoadSupplierById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadSupplierById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadSupplierById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierSaveDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierSaveDto>;
        }));
    }

    protected processLoadSupplierById(response: HttpResponseBase): Observable<SupplierSaveDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SupplierSaveDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierSaveDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveSite(body: SupplierSiteSaveDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplier/SaveSite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveSite(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveSite(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveSite(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteSite(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplier/DeleteSite?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSite(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSite(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteSite(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    loadSiteById(id: number | undefined): Observable<SupplierSiteSaveDto> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplier/LoadSiteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadSiteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadSiteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierSiteSaveDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierSiteSaveDto>;
        }));
    }

    protected processLoadSiteById(response: HttpResponseBase): Observable<SupplierSiteSaveDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SupplierSiteSaveDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierSiteSaveDto>(null as any);
    }
}

@Injectable()
export class MstSupplierRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllSupplier(filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSupplierRequestInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplierRequest/GetAllSupplier?";
        if (filterText !== undefined && filterText !== null)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSupplier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSupplier(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfSupplierRequestInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfSupplierRequestInfoDto>;
        }));
    }

    protected processGetAllSupplier(response: HttpResponseBase): Observable<PagedResultDtoOfSupplierRequestInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSupplierRequestInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSupplierRequestInfoDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSupplierRequestById(id: number | undefined): Observable<SupplierRequestInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplierRequest/GetSupplierRequestById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSupplierRequestById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSupplierRequestById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierRequestInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierRequestInfoDto>;
        }));
    }

    protected processGetSupplierRequestById(response: HttpResponseBase): Observable<SupplierRequestInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SupplierRequestInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierRequestInfoDto>(null as any);
    }

    /**
     * @param requestUniqueId (optional) 
     * @return Success
     */
    getSupplierByGuId(requestUniqueId: string | undefined): Observable<SupplierRequestInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplierRequest/GetSupplierByGuId?";
        if (requestUniqueId === null)
            throw new Error("The parameter 'requestUniqueId' cannot be null.");
        else if (requestUniqueId !== undefined)
            url_ += "requestUniqueId=" + encodeURIComponent("" + requestUniqueId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSupplierByGuId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSupplierByGuId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierRequestInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierRequestInfoDto>;
        }));
    }

    protected processGetSupplierByGuId(response: HttpResponseBase): Observable<SupplierRequestInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SupplierRequestInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierRequestInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditSupplierRequest(body: SupplierRequestInfoDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplierRequest/CreateOrEditSupplierRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditSupplierRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditSupplierRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateOrEditSupplierRequest(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteSupplierRequest(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplierRequest/DeleteSupplierRequest?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSupplierRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSupplierRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteSupplierRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rejectRequest(body: SupplierRequestInfoDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplierRequest/RejectRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRejectRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approve(body: SupplierRequestInfoDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplierRequest/Approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApprove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApprove(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processApprove(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resentEmailToUser(body: SupplierRequestInfoDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstSupplierRequest/ResentEmailToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResentEmailToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResentEmailToUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResentEmailToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class MstUnitOfMeasureServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MstUnitOfMeasure/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param unitOfMeasure (optional) 
     * @param uOMCode (optional) 
     * @param uOMClass (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllMeasureDto(unitOfMeasure: string | null | undefined, uOMCode: string | null | undefined, uOMClass: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfUnitOfMeasureDto> {
        let url_ = this.baseUrl + "/api/services/app/MstUnitOfMeasure/getAllMeasureDto?";
        if (unitOfMeasure !== undefined && unitOfMeasure !== null)
            url_ += "UnitOfMeasure=" + encodeURIComponent("" + unitOfMeasure) + "&";
        if (uOMCode !== undefined && uOMCode !== null)
            url_ += "UOMCode=" + encodeURIComponent("" + uOMCode) + "&";
        if (uOMClass !== undefined && uOMClass !== null)
            url_ += "UOMClass=" + encodeURIComponent("" + uOMClass) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMeasureDto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMeasureDto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfUnitOfMeasureDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfUnitOfMeasureDto>;
        }));
    }

    protected processGetAllMeasureDto(response: HttpResponseBase): Observable<PagedResultDtoOfUnitOfMeasureDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUnitOfMeasureDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUnitOfMeasureDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    loadById(id: number | undefined): Observable<UnitOfMeasureDto> {
        let url_ = this.baseUrl + "/api/services/app/MstUnitOfMeasure/LoadById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitOfMeasureDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitOfMeasureDto>;
        }));
    }

    protected processLoadById(response: HttpResponseBase): Observable<UnitOfMeasureDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UnitOfMeasureDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitOfMeasureDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: UnitOfMeasureDto | undefined): Observable<ValInventoryGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/MstUnitOfMeasure/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValInventoryGroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValInventoryGroupDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<ValInventoryGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValInventoryGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValInventoryGroupDto>(null as any);
    }

    /**
     * @param unitOfMeasure (optional) 
     * @param uOMCode (optional) 
     * @param uOMClass (optional) 
     * @return Success
     */
    getAllUmoNotPaged(unitOfMeasure: string | null | undefined, uOMCode: string | null | undefined, uOMClass: string | null | undefined): Observable<UnitOfMeasureDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MstUnitOfMeasure/getAllUmoNotPaged?";
        if (unitOfMeasure !== undefined && unitOfMeasure !== null)
            url_ += "UnitOfMeasure=" + encodeURIComponent("" + unitOfMeasure) + "&";
        if (uOMCode !== undefined && uOMCode !== null)
            url_ += "UOMCode=" + encodeURIComponent("" + uOMCode) + "&";
        if (uOMClass !== undefined && uOMClass !== null)
            url_ += "UOMClass=" + encodeURIComponent("" + uOMClass) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUmoNotPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUmoNotPaged(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitOfMeasureDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitOfMeasureDto[]>;
        }));
    }

    protected processGetAllUmoNotPaged(response: HttpResponseBase): Observable<UnitOfMeasureDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UnitOfMeasureDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitOfMeasureDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mstOUMExportExcel(body: InputUOMExportDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MstUnitOfMeasure/MstOUMExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMstOUMExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMstOUMExportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processMstOUMExportExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param state (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUserNotifications(state: UserNotificationState | undefined, startDate: DateTime | null | undefined, endDate: DateTime | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetUserNotifications?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetNotificationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetNotificationsOutput>;
        }));
    }

    protected processGetUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetNotificationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationsOutput>(null as any);
    }

    /**
     * @return Success
     */
    setAllNotificationsAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetAllNotificationsAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAllNotificationsAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAllNotificationsAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetAllNotificationsAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setNotificationAsRead(body: EntityDtoOfGuid | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetNotificationAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetNotificationAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetNotificationAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetNotificationSettingsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetNotificationSettingsOutput>;
        }));
    }

    protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetNotificationSettingsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationSettingsOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateNotificationSettings(body: UpdateNotificationSettingsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/UpdateNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteNotification(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteNotification?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param state (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    deleteAllUserNotifications(state: UserNotificationState | undefined, startDate: DateTime | null | undefined, endDate: DateTime | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteAllUserNotifications?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllUserNotifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAllUserNotifications(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<ListResultDtoOfOrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfOrganizationUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfOrganizationUnitDto>;
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<ListResultDtoOfOrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfOrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfOrganizationUnitDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitUsers(id: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfOrganizationUnitUserListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfOrganizationUnitUserListDto>;
        }));
    }

    protected processGetOrganizationUnitUsers(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrganizationUnitUserListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitUserListDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitRoles(id: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitRoles?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfOrganizationUnitRoleListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfOrganizationUnitRoleListDto>;
        }));
    }

    protected processGetOrganizationUnitRoles(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrganizationUnitRoleListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitRoleListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrganizationUnit(body: CreateOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUnitDto>;
        }));
    }

    protected processCreateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOrganizationUnit(body: UpdateOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUnitDto>;
        }));
    }

    protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moveOrganizationUnit(body: MoveOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUnitDto>;
        }));
    }

    protected processMoveOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOrganizationUnit(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/DeleteOrganizationUnit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param userId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUserFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserFromOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param roleId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeRoleFromOrganizationUnit(roleId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveRoleFromOrganizationUnit?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRoleFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRoleFromOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveRoleFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUsersToOrganizationUnit(body: UsersToOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUsersToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUsersToOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddUsersToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addRolesToOrganizationUnit(body: RolesToOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddRolesToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRolesToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRolesToOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddRolesToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findUsers(body: FindOrganizationUnitUsersInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfNameValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfNameValueDto>;
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findRoles(body: FindOrganizationUnitRolesInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfNameValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfNameValueDto>;
        }));
    }

    protected processFindRoles(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(null as any);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    getPaymentInfo(upgradeEditionId: number | null | undefined): Observable<PaymentInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentInfo?";
        if (upgradeEditionId !== undefined && upgradeEditionId !== null)
            url_ += "UpgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentInfoDto>;
        }));
    }

    protected processGetPaymentInfo(response: HttpResponseBase): Observable<PaymentInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentInfoDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPayment(body: CreatePaymentDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CreatePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreatePayment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelPayment(body: CancelPaymentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CancelPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancelPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaymentHistory(sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentHistory?";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfSubscriptionPaymentListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfSubscriptionPaymentListDto>;
        }));
    }

    protected processGetPaymentHistory(response: HttpResponseBase): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSubscriptionPaymentListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSubscriptionPaymentListDto>(null as any);
    }

    /**
     * @param recurringPaymentsEnabled (optional) 
     * @return Success
     */
    getActiveGateways(recurringPaymentsEnabled: boolean | null | undefined): Observable<PaymentGatewayModel[]> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetActiveGateways?";
        if (recurringPaymentsEnabled !== undefined && recurringPaymentsEnabled !== null)
            url_ += "RecurringPaymentsEnabled=" + encodeURIComponent("" + recurringPaymentsEnabled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveGateways(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveGateways(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentGatewayModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentGatewayModel[]>;
        }));
    }

    protected processGetActiveGateways(response: HttpResponseBase): Observable<PaymentGatewayModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentGatewayModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentGatewayModel[]>(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    getPayment(paymentId: number | undefined): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPayment?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPaymentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPaymentDto>;
        }));
    }

    protected processGetPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(null as any);
    }

    /**
     * @return Success
     */
    getLastCompletedPayment(): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetLastCompletedPayment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastCompletedPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastCompletedPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPaymentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPaymentDto>;
        }));
    }

    protected processGetLastCompletedPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    buyNowSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/BuyNowSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuyNowSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuyNowSucceed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBuyNowSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    newRegistrationSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/NewRegistrationSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewRegistrationSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewRegistrationSucceed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processNewRegistrationSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    upgradeSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/UpgradeSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeSucceed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpgradeSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    extendSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/ExtendSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtendSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtendSucceed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processExtendSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    paymentFailed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/PaymentFailed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentFailed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentFailed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPaymentFailed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    switchBetweenFreeEditions(upgradeEditionId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/SwitchBetweenFreeEditions?";
        if (upgradeEditionId === null)
            throw new Error("The parameter 'upgradeEditionId' cannot be null.");
        else if (upgradeEditionId !== undefined)
            url_ += "upgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchBetweenFreeEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchBetweenFreeEditions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSwitchBetweenFreeEditions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    upgradeSubscriptionCostsLessThenMinAmount(editionId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/UpgradeSubscriptionCostsLessThenMinAmount?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeSubscriptionCostsLessThenMinAmount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeSubscriptionCostsLessThenMinAmount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpgradeSubscriptionCostsLessThenMinAmount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    hasAnyPayment(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Payment/HasAnyPayment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHasAnyPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHasAnyPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processHasAnyPayment(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

@Injectable()
export class PaymentFromSuppliersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param paymentNo (optional) 
     * @param requestDateFrom (optional) 
     * @param requestDateTo (optional) 
     * @param vendorId (optional) 
     * @param employeeId (optional) 
     * @param status (optional) 
     * @param authorizationStatus (optional) 
     * @param invoiceNumber (optional) 
     * @param poNo (optional) 
     * @param currencyCode (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllPayment(paymentNo: string | null | undefined, requestDateFrom: DateTime | null | undefined, requestDateTo: DateTime | null | undefined, vendorId: number | null | undefined, employeeId: number | null | undefined, status: number | null | undefined, authorizationStatus: string | null | undefined, invoiceNumber: string | null | undefined, poNo: string | null | undefined, currencyCode: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfPaymentFromSuppliersDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentFromSuppliers/getAllPayment?";
        if (paymentNo !== undefined && paymentNo !== null)
            url_ += "PaymentNo=" + encodeURIComponent("" + paymentNo) + "&";
        if (requestDateFrom !== undefined && requestDateFrom !== null)
            url_ += "RequestDateFrom=" + encodeURIComponent(requestDateFrom ? "" + requestDateFrom.toString() : "") + "&";
        if (requestDateTo !== undefined && requestDateTo !== null)
            url_ += "RequestDateTo=" + encodeURIComponent(requestDateTo ? "" + requestDateTo.toString() : "") + "&";
        if (vendorId !== undefined && vendorId !== null)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&";
        if (employeeId !== undefined && employeeId !== null)
            url_ += "EmployeeId=" + encodeURIComponent("" + employeeId) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (authorizationStatus !== undefined && authorizationStatus !== null)
            url_ += "AuthorizationStatus=" + encodeURIComponent("" + authorizationStatus) + "&";
        if (invoiceNumber !== undefined && invoiceNumber !== null)
            url_ += "InvoiceNumber=" + encodeURIComponent("" + invoiceNumber) + "&";
        if (poNo !== undefined && poNo !== null)
            url_ += "PoNo=" + encodeURIComponent("" + poNo) + "&";
        if (currencyCode !== undefined && currencyCode !== null)
            url_ += "CurrencyCode=" + encodeURIComponent("" + currencyCode) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfPaymentFromSuppliersDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfPaymentFromSuppliersDto>;
        }));
    }

    protected processGetAllPayment(response: HttpResponseBase): Observable<PagedResultDtoOfPaymentFromSuppliersDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfPaymentFromSuppliersDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPaymentFromSuppliersDto>(null as any);
    }

    /**
     * @param invoiceNum (optional) 
     * @param vendorId (optional) 
     * @param vendorSiteId (optional) 
     * @param currencyCode (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllInvoices(invoiceNum: string | null | undefined, vendorId: number | null | undefined, vendorSiteId: number | null | undefined, currencyCode: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetInvoiceHeadersDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentFromSuppliers/getAllInvoices?";
        if (invoiceNum !== undefined && invoiceNum !== null)
            url_ += "InvoiceNum=" + encodeURIComponent("" + invoiceNum) + "&";
        if (vendorId !== undefined && vendorId !== null)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&";
        if (vendorSiteId !== undefined && vendorSiteId !== null)
            url_ += "VendorSiteId=" + encodeURIComponent("" + vendorSiteId) + "&";
        if (currencyCode !== undefined && currencyCode !== null)
            url_ += "CurrencyCode=" + encodeURIComponent("" + currencyCode) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInvoices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInvoices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetInvoiceHeadersDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetInvoiceHeadersDto>;
        }));
    }

    protected processGetAllInvoices(response: HttpResponseBase): Observable<PagedResultDtoOfGetInvoiceHeadersDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetInvoiceHeadersDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetInvoiceHeadersDto>(null as any);
    }

    /**
     * @param poNo (optional) 
     * @param vendorId (optional) 
     * @param vendorSiteId (optional) 
     * @param receiptNoteType (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPOsForPaymentRequestFromNCC(poNo: string | null | undefined, vendorId: number | null | undefined, vendorSiteId: number | null | undefined, receiptNoteType: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetPoHeadersDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentFromSuppliers/getPOsForPaymentRequestFromNCC?";
        if (poNo !== undefined && poNo !== null)
            url_ += "PoNo=" + encodeURIComponent("" + poNo) + "&";
        if (vendorId !== undefined && vendorId !== null)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&";
        if (vendorSiteId !== undefined && vendorSiteId !== null)
            url_ += "VendorSiteId=" + encodeURIComponent("" + vendorSiteId) + "&";
        if (receiptNoteType === null)
            throw new Error("The parameter 'receiptNoteType' cannot be null.");
        else if (receiptNoteType !== undefined)
            url_ += "ReceiptNoteType=" + encodeURIComponent("" + receiptNoteType) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPOsForPaymentRequestFromNCC(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPOsForPaymentRequestFromNCC(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetPoHeadersDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetPoHeadersDto>;
        }));
    }

    protected processGetPOsForPaymentRequestFromNCC(response: HttpResponseBase): Observable<PagedResultDtoOfGetPoHeadersDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetPoHeadersDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPoHeadersDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isDataValid(body: InputPaymentFromSuppliersDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/PaymentFromSuppliers/IsDataValid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsDataValid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsDataValid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processIsDataValid(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditPayment(body: InputPaymentFromSuppliersDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PaymentFromSuppliers/CreateOrEditPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEditPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPayment(body: InputPaymentFromSuppliersDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PaymentFromSuppliers/createPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreatePayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param headerid (optional) 
     * @return Success
     */
    getAllAttachmentsByHeaderID(headerid: number | null | undefined): Observable<PaymentFromSupplierAttachmentsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PaymentFromSuppliers/getAllAttachmentsByHeaderID?";
        if (headerid !== undefined && headerid !== null)
            url_ += "headerid=" + encodeURIComponent("" + headerid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAttachmentsByHeaderID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAttachmentsByHeaderID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentFromSupplierAttachmentsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentFromSupplierAttachmentsDto[]>;
        }));
    }

    protected processGetAllAttachmentsByHeaderID(response: HttpResponseBase): Observable<PaymentFromSupplierAttachmentsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentFromSupplierAttachmentsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentFromSupplierAttachmentsDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePayment(body: InputPaymentFromSuppliersDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PaymentFromSuppliers/updatePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PaymentFromSuppliers/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cancelPayment(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PaymentFromSuppliers/CancelPayment?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancelPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    sendPaymentToTMV(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PaymentFromSuppliers/SendPaymentToTMV?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPaymentToTMV(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPaymentToTMV(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendPaymentToTMV(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPaymentReportById(id: number | null | undefined): Observable<GetPaymentReportDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentFromSuppliers/getPaymentReportById?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentReportById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentReportById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPaymentReportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPaymentReportDto>;
        }));
    }

    protected processGetPaymentReportById(response: HttpResponseBase): Observable<GetPaymentReportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPaymentReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPaymentReportDto>(null as any);
    }
}

@Injectable()
export class PaymentHeadersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param paymentNo (optional) 
     * @param invoiceNo (optional) 
     * @param poNo (optional) 
     * @param requestDateFrom (optional) 
     * @param requestDateTo (optional) 
     * @param vendorId (optional) 
     * @param employeeId (optional) 
     * @param status (optional) 
     * @param authorizationStatus (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllPayment(paymentNo: string | null | undefined, invoiceNo: string | null | undefined, poNo: string | null | undefined, requestDateFrom: DateTime | null | undefined, requestDateTo: DateTime | null | undefined, vendorId: number | null | undefined, employeeId: number | null | undefined, status: number | null | undefined, authorizationStatus: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfPaymentHeadersDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentHeaders/getAllPayment?";
        if (paymentNo !== undefined && paymentNo !== null)
            url_ += "PaymentNo=" + encodeURIComponent("" + paymentNo) + "&";
        if (invoiceNo !== undefined && invoiceNo !== null)
            url_ += "InvoiceNo=" + encodeURIComponent("" + invoiceNo) + "&";
        if (poNo !== undefined && poNo !== null)
            url_ += "PoNo=" + encodeURIComponent("" + poNo) + "&";
        if (requestDateFrom !== undefined && requestDateFrom !== null)
            url_ += "RequestDateFrom=" + encodeURIComponent(requestDateFrom ? "" + requestDateFrom.toString() : "") + "&";
        if (requestDateTo !== undefined && requestDateTo !== null)
            url_ += "RequestDateTo=" + encodeURIComponent(requestDateTo ? "" + requestDateTo.toString() : "") + "&";
        if (vendorId !== undefined && vendorId !== null)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&";
        if (employeeId !== undefined && employeeId !== null)
            url_ += "EmployeeId=" + encodeURIComponent("" + employeeId) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (authorizationStatus !== undefined && authorizationStatus !== null)
            url_ += "AuthorizationStatus=" + encodeURIComponent("" + authorizationStatus) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfPaymentHeadersDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfPaymentHeadersDto>;
        }));
    }

    protected processGetAllPayment(response: HttpResponseBase): Observable<PagedResultDtoOfPaymentHeadersDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfPaymentHeadersDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPaymentHeadersDto>(null as any);
    }

    /**
     * @param invoiceNum (optional) 
     * @param vendorId (optional) 
     * @param vendorSiteId (optional) 
     * @param currencyCode (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllInvoices(invoiceNum: string | null | undefined, vendorId: number | null | undefined, vendorSiteId: number | null | undefined, currencyCode: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetInvoiceHeadersDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentHeaders/getAllInvoices?";
        if (invoiceNum !== undefined && invoiceNum !== null)
            url_ += "InvoiceNum=" + encodeURIComponent("" + invoiceNum) + "&";
        if (vendorId !== undefined && vendorId !== null)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&";
        if (vendorSiteId !== undefined && vendorSiteId !== null)
            url_ += "VendorSiteId=" + encodeURIComponent("" + vendorSiteId) + "&";
        if (currencyCode !== undefined && currencyCode !== null)
            url_ += "CurrencyCode=" + encodeURIComponent("" + currencyCode) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInvoices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInvoices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetInvoiceHeadersDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetInvoiceHeadersDto>;
        }));
    }

    protected processGetAllInvoices(response: HttpResponseBase): Observable<PagedResultDtoOfGetInvoiceHeadersDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetInvoiceHeadersDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetInvoiceHeadersDto>(null as any);
    }

    /**
     * @param poNo (optional) 
     * @param vendorId (optional) 
     * @param vendorSiteId (optional) 
     * @param invoiceId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllPrepaymentForInvoices(poNo: string | null | undefined, vendorId: number | null | undefined, vendorSiteId: number | null | undefined, invoiceId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetPrepaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentHeaders/getAllPrepaymentForInvoices?";
        if (poNo !== undefined && poNo !== null)
            url_ += "PoNo=" + encodeURIComponent("" + poNo) + "&";
        if (vendorId !== undefined && vendorId !== null)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&";
        if (vendorSiteId !== undefined && vendorSiteId !== null)
            url_ += "VendorSiteId=" + encodeURIComponent("" + vendorSiteId) + "&";
        if (invoiceId !== undefined && invoiceId !== null)
            url_ += "InvoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPrepaymentForInvoices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPrepaymentForInvoices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetPrepaymentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetPrepaymentDto>;
        }));
    }

    protected processGetAllPrepaymentForInvoices(response: HttpResponseBase): Observable<PagedResultDtoOfGetPrepaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetPrepaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPrepaymentDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDataForPrint(id: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/PaymentHeaders/getDataForPrint?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataForPrint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataForPrint(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetDataForPrint(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param invoiceId (optional) 
     * @param body (optional) 
     * @return Success
     */
    applyPrepaymentForInvoices(invoiceId: number | undefined, body: GetPrepaymentDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PaymentHeaders/ApplyPrepaymentForInvoices?";
        if (invoiceId === null)
            throw new Error("The parameter 'invoiceId' cannot be null.");
        else if (invoiceId !== undefined)
            url_ += "invoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApplyPrepaymentForInvoices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApplyPrepaymentForInvoices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processApplyPrepaymentForInvoices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditPayment(body: InputPaymentHeadersDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/PaymentHeaders/CreateOrEditPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateOrEditPayment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @return Success
     */
    getTMVUserList(): Observable<GetEmployeesDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PaymentHeaders/GetTMVUserList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTMVUserList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTMVUserList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEmployeesDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEmployeesDto[]>;
        }));
    }

    protected processGetTMVUserList(response: HttpResponseBase): Observable<GetEmployeesDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetEmployeesDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEmployeesDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPaymentById(id: number | null | undefined): Observable<PaymentHeadersDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentHeaders/getPaymentById?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentHeadersDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentHeadersDto>;
        }));
    }

    protected processGetPaymentById(response: HttpResponseBase): Observable<PaymentHeadersDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentHeadersDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentHeadersDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPayment(body: InputPaymentHeadersDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/PaymentHeaders/createPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreatePayment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param headerid (optional) 
     * @return Success
     */
    getAllAttachmentsByHeaderID(headerid: number | null | undefined): Observable<PaymentAttachmentsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PaymentHeaders/getAllAttachmentsByHeaderID?";
        if (headerid !== undefined && headerid !== null)
            url_ += "headerid=" + encodeURIComponent("" + headerid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAttachmentsByHeaderID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAttachmentsByHeaderID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentAttachmentsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentAttachmentsDto[]>;
        }));
    }

    protected processGetAllAttachmentsByHeaderID(response: HttpResponseBase): Observable<PaymentAttachmentsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentAttachmentsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentAttachmentsDto[]>(null as any);
    }

    /**
     * @param paymentNo (optional) 
     * @param requestDateFrom (optional) 
     * @param requestDateTo (optional) 
     * @param vendorId (optional) 
     * @param employeeId (optional) 
     * @param status (optional) 
     * @param authorizationStatus (optional) 
     * @param invoiceNumber (optional) 
     * @param poNo (optional) 
     * @param currencyCode (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllPaymentFromSupplier(paymentNo: string | null | undefined, requestDateFrom: DateTime | null | undefined, requestDateTo: DateTime | null | undefined, vendorId: number | null | undefined, employeeId: number | null | undefined, status: number | null | undefined, authorizationStatus: string | null | undefined, invoiceNumber: string | null | undefined, poNo: string | null | undefined, currencyCode: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PaymentFromSuppliersDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PaymentHeaders/getAllPaymentFromSupplier?";
        if (paymentNo !== undefined && paymentNo !== null)
            url_ += "PaymentNo=" + encodeURIComponent("" + paymentNo) + "&";
        if (requestDateFrom !== undefined && requestDateFrom !== null)
            url_ += "RequestDateFrom=" + encodeURIComponent(requestDateFrom ? "" + requestDateFrom.toString() : "") + "&";
        if (requestDateTo !== undefined && requestDateTo !== null)
            url_ += "RequestDateTo=" + encodeURIComponent(requestDateTo ? "" + requestDateTo.toString() : "") + "&";
        if (vendorId !== undefined && vendorId !== null)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&";
        if (employeeId !== undefined && employeeId !== null)
            url_ += "EmployeeId=" + encodeURIComponent("" + employeeId) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (authorizationStatus !== undefined && authorizationStatus !== null)
            url_ += "AuthorizationStatus=" + encodeURIComponent("" + authorizationStatus) + "&";
        if (invoiceNumber !== undefined && invoiceNumber !== null)
            url_ += "InvoiceNumber=" + encodeURIComponent("" + invoiceNumber) + "&";
        if (poNo !== undefined && poNo !== null)
            url_ += "PoNo=" + encodeURIComponent("" + poNo) + "&";
        if (currencyCode !== undefined && currencyCode !== null)
            url_ += "CurrencyCode=" + encodeURIComponent("" + currencyCode) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPaymentFromSupplier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPaymentFromSupplier(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentFromSuppliersDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentFromSuppliersDto[]>;
        }));
    }

    protected processGetAllPaymentFromSupplier(response: HttpResponseBase): Observable<PaymentFromSuppliersDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentFromSuppliersDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentFromSuppliersDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePayment(body: InputPaymentHeadersDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/PaymentHeaders/updatePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdatePayment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PaymentHeaders/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cancelPayment(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PaymentHeaders/CancelPayment?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancelPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param headerid (optional) 
     * @return Success
     */
    getAllPaymentLineByHeaderID(headerid: number | null | undefined): Observable<PagedResultDtoOfInputPaymentLinesDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentHeaders/getAllPaymentLineByHeaderID?";
        if (headerid !== undefined && headerid !== null)
            url_ += "headerid=" + encodeURIComponent("" + headerid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPaymentLineByHeaderID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPaymentLineByHeaderID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfInputPaymentLinesDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfInputPaymentLinesDto>;
        }));
    }

    protected processGetAllPaymentLineByHeaderID(response: HttpResponseBase): Observable<PagedResultDtoOfInputPaymentLinesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfInputPaymentLinesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfInputPaymentLinesDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPaymentReportById(id: number | null | undefined): Observable<GetPaymentReportDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentHeaders/getPaymentReportById?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentReportById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentReportById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPaymentReportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPaymentReportDto>;
        }));
    }

    protected processGetPaymentReportById(response: HttpResponseBase): Observable<GetPaymentReportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPaymentReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPaymentReportDto>(null as any);
    }

    /**
     * @param supplierId (optional) 
     * @param supplierSiteId (optional) 
     * @param currencyCode (optional) 
     * @return Success
     */
    getSupplierBankAccountInfo(supplierId: number | null | undefined, supplierSiteId: number | null | undefined, currencyCode: string | null | undefined): Observable<SupplierBankAccountDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentHeaders/getSupplierBankAccountInfo?";
        if (supplierId !== undefined && supplierId !== null)
            url_ += "supplierId=" + encodeURIComponent("" + supplierId) + "&";
        if (supplierSiteId !== undefined && supplierSiteId !== null)
            url_ += "supplierSiteId=" + encodeURIComponent("" + supplierSiteId) + "&";
        if (currencyCode !== undefined && currencyCode !== null)
            url_ += "currencyCode=" + encodeURIComponent("" + currencyCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSupplierBankAccountInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSupplierBankAccountInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierBankAccountDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierBankAccountDto>;
        }));
    }

    protected processGetSupplierBankAccountInfo(response: HttpResponseBase): Observable<SupplierBankAccountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SupplierBankAccountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierBankAccountDto>(null as any);
    }
}

@Injectable()
export class PayPalPaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param paymentId (optional) 
     * @param paypalOrderId (optional) 
     * @return Success
     */
    confirmPayment(paymentId: number | undefined, paypalOrderId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/ConfirmPayment?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        if (paypalOrderId !== undefined && paypalOrderId !== null)
            url_ += "paypalOrderId=" + encodeURIComponent("" + paypalOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConfirmPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<PayPalConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PayPalConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PayPalConfigurationDto>;
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<PayPalConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayPalConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayPalConfigurationDto>(null as any);
    }
}

@Injectable()
export class PcsMainDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllDashboardActionForView(): Observable<MainDashboardActionsForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PcsMainDashboard/GetAllDashboardActionForView";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDashboardActionForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDashboardActionForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MainDashboardActionsForViewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MainDashboardActionsForViewDto[]>;
        }));
    }

    protected processGetAllDashboardActionForView(response: HttpResponseBase): Observable<MainDashboardActionsForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MainDashboardActionsForViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MainDashboardActionsForViewDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllSysFunc(): Observable<GetAllSystemFunctionForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PcsMainDashboard/GetAllSysFunc";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSysFunc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSysFunc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllSystemFunctionForViewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllSystemFunctionForViewDto[]>;
        }));
    }

    protected processGetAllSysFunc(response: HttpResponseBase): Observable<GetAllSystemFunctionForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAllSystemFunctionForViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllSystemFunctionForViewDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllUserFunctions(): Observable<GetAllUserFunctionsForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PcsMainDashboard/GetAllUserFunctions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserFunctions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserFunctions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllUserFunctionsForViewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllUserFunctionsForViewDto[]>;
        }));
    }

    protected processGetAllUserFunctions(response: HttpResponseBase): Observable<GetAllUserFunctionsForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAllUserFunctionsForViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllUserFunctionsForViewDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createUserFunctionList(body: CreateOrEditUserFunctionListInput[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PcsMainDashboard/CreateUserFunctionList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUserFunctionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUserFunctionList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateUserFunctionList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class PcsUserRequestExcelDataReaderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    readDataFromExcel(body: string | null | undefined): Observable<UserRequestExcelDataDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PcsUserRequestExcelDataReader/ReadDataFromExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadDataFromExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadDataFromExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRequestExcelDataDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRequestExcelDataDto[]>;
        }));
    }

    protected processReadDataFromExcel(response: HttpResponseBase): Observable<UserRequestExcelDataDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserRequestExcelDataDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRequestExcelDataDto[]>(null as any);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfFlatPermissionWithLevelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfFlatPermissionWithLevelDto>;
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfFlatPermissionWithLevelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfFlatPermissionWithLevelDto>(null as any);
    }
}

@Injectable()
export class PersonnelServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param name (optional) 
     * @param persionalName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllHrOrgStructure(name: string | null | undefined, persionalName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfMstHrOrgStructureOutputSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/Personnel/GetAllHrOrgStructure?";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (persionalName !== undefined && persionalName !== null)
            url_ += "PersionalName=" + encodeURIComponent("" + persionalName) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHrOrgStructure(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHrOrgStructure(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMstHrOrgStructureOutputSelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMstHrOrgStructureOutputSelectDto>;
        }));
    }

    protected processGetAllHrOrgStructure(response: HttpResponseBase): Observable<PagedResultDtoOfMstHrOrgStructureOutputSelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMstHrOrgStructureOutputSelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMstHrOrgStructureOutputSelectDto>(null as any);
    }

    /**
     * @param hrOrgStructureId (optional) 
     * @param name (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllPersonnelByHrOrgStructureId(hrOrgStructureId: string | null | undefined, name: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfPersonnelOutputSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/Personnel/GetAllPersonnelByHrOrgStructureId?";
        if (hrOrgStructureId !== undefined && hrOrgStructureId !== null)
            url_ += "HrOrgStructureId=" + encodeURIComponent("" + hrOrgStructureId) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPersonnelByHrOrgStructureId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPersonnelByHrOrgStructureId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfPersonnelOutputSelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfPersonnelOutputSelectDto>;
        }));
    }

    protected processGetAllPersonnelByHrOrgStructureId(response: HttpResponseBase): Observable<PagedResultDtoOfPersonnelOutputSelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfPersonnelOutputSelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPersonnelOutputSelectDto>(null as any);
    }
}

@Injectable()
export class PrcContractHeaderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param headerId (optional) 
     * @return Success
     */
    deleteContract(headerId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractHeader/DeleteContract?";
        if (headerId === null)
            throw new Error("The parameter 'headerId' cannot be null.");
        else if (headerId !== undefined)
            url_ += "headerId=" + encodeURIComponent("" + headerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContract(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContract(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteContract(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: GetAllContractHeaderDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractHeader/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param contractNo (optional) 
     * @param effectiveFrom (optional) 
     * @param effectiveTo (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllData(contractNo: string | null | undefined, effectiveFrom: DateTime | null | undefined, effectiveTo: DateTime | null | undefined, page: number | undefined, pageSize: number | undefined): Observable<PagedResultDtoOfGetAllContractHeaderDto> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractHeader/GetAllData?";
        if (contractNo !== undefined && contractNo !== null)
            url_ += "ContractNo=" + encodeURIComponent("" + contractNo) + "&";
        if (effectiveFrom !== undefined && effectiveFrom !== null)
            url_ += "EffectiveFrom=" + encodeURIComponent(effectiveFrom ? "" + effectiveFrom.toString() : "") + "&";
        if (effectiveTo !== undefined && effectiveTo !== null)
            url_ += "EffectiveTo=" + encodeURIComponent(effectiveTo ? "" + effectiveTo.toString() : "") + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAllContractHeaderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAllContractHeaderDto>;
        }));
    }

    protected processGetAllData(response: HttpResponseBase): Observable<PagedResultDtoOfGetAllContractHeaderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAllContractHeaderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAllContractHeaderDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getContractDataById(id: number | undefined): Observable<GetAllContractHeaderDto> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractHeader/GetContractDataById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContractDataById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContractDataById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllContractHeaderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllContractHeaderDto>;
        }));
    }

    protected processGetContractDataById(response: HttpResponseBase): Observable<GetAllContractHeaderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllContractHeaderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllContractHeaderDto>(null as any);
    }
}

@Injectable()
export class PrcContractLineServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param prcContractHeaderId (optional) 
     * @return Success
     */
    getByHeaderId(prcContractHeaderId: number | undefined): Observable<GetContactLineByIdOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractLine/GetByHeaderId?";
        if (prcContractHeaderId === null)
            throw new Error("The parameter 'prcContractHeaderId' cannot be null.");
        else if (prcContractHeaderId !== undefined)
            url_ += "PrcContractHeaderId=" + encodeURIComponent("" + prcContractHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByHeaderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByHeaderId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetContactLineByIdOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetContactLineByIdOutputDto[]>;
        }));
    }

    protected processGetByHeaderId(response: HttpResponseBase): Observable<GetContactLineByIdOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetContactLineByIdOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetContactLineByIdOutputDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveToTempTable(body: ImpInventoryItemPriceDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractLine/SaveToTempTable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveToTempTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveToTempTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveToTempTable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param headerId (optional) 
     * @return Success
     */
    importAndGetData(headerId: number | undefined): Observable<ImpInventoryItemPriceDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractLine/ImportAndGetData?";
        if (headerId === null)
            throw new Error("The parameter 'headerId' cannot be null.");
        else if (headerId !== undefined)
            url_ += "headerId=" + encodeURIComponent("" + headerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportAndGetData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportAndGetData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpInventoryItemPriceDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpInventoryItemPriceDto[]>;
        }));
    }

    protected processImportAndGetData(response: HttpResponseBase): Observable<ImpInventoryItemPriceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ImpInventoryItemPriceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpInventoryItemPriceDto[]>(null as any);
    }
}

@Injectable()
export class PrcContractTemplateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param contractNo (optional) 
     * @param effectiveFrom (optional) 
     * @param effectiveTo (optional) 
     * @param creationTime (optional) 
     * @param appendixNo (optional) 
     * @param approveBy (optional) 
     * @param isInternal (optional) 
     * @param approvalStatus (optional) 
     * @param inventoryGroupId (optional) 
     * @param supplierId (optional) 
     * @param userId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPrcContractTemplateSearch(contractNo: string | null | undefined, effectiveFrom: DateTime | null | undefined, effectiveTo: DateTime | null | undefined, creationTime: DateTime | null | undefined, appendixNo: string | null | undefined, approveBy: string | null | undefined, isInternal: boolean | null | undefined, approvalStatus: string | null | undefined, inventoryGroupId: number | null | undefined, supplierId: number | null | undefined, userId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfPrcContractTemplateDto> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/getPrcContractTemplateSearch?";
        if (contractNo !== undefined && contractNo !== null)
            url_ += "ContractNo=" + encodeURIComponent("" + contractNo) + "&";
        if (effectiveFrom !== undefined && effectiveFrom !== null)
            url_ += "EffectiveFrom=" + encodeURIComponent(effectiveFrom ? "" + effectiveFrom.toString() : "") + "&";
        if (effectiveTo !== undefined && effectiveTo !== null)
            url_ += "EffectiveTo=" + encodeURIComponent(effectiveTo ? "" + effectiveTo.toString() : "") + "&";
        if (creationTime !== undefined && creationTime !== null)
            url_ += "CreationTime=" + encodeURIComponent(creationTime ? "" + creationTime.toString() : "") + "&";
        if (appendixNo !== undefined && appendixNo !== null)
            url_ += "AppendixNo=" + encodeURIComponent("" + appendixNo) + "&";
        if (approveBy !== undefined && approveBy !== null)
            url_ += "ApproveBy=" + encodeURIComponent("" + approveBy) + "&";
        if (isInternal !== undefined && isInternal !== null)
            url_ += "IsInternal=" + encodeURIComponent("" + isInternal) + "&";
        if (approvalStatus !== undefined && approvalStatus !== null)
            url_ += "ApprovalStatus=" + encodeURIComponent("" + approvalStatus) + "&";
        if (inventoryGroupId !== undefined && inventoryGroupId !== null)
            url_ += "InventoryGroupId=" + encodeURIComponent("" + inventoryGroupId) + "&";
        if (supplierId !== undefined && supplierId !== null)
            url_ += "SupplierId=" + encodeURIComponent("" + supplierId) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrcContractTemplateSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrcContractTemplateSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfPrcContractTemplateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfPrcContractTemplateDto>;
        }));
    }

    protected processGetPrcContractTemplateSearch(response: HttpResponseBase): Observable<PagedResultDtoOfPrcContractTemplateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfPrcContractTemplateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPrcContractTemplateDto>(null as any);
    }

    /**
     * @param contractNo (optional) 
     * @param effectiveFrom (optional) 
     * @param effectiveTo (optional) 
     * @param creationTime (optional) 
     * @param appendixNo (optional) 
     * @param approveBy (optional) 
     * @param isInternal (optional) 
     * @param approvalStatus (optional) 
     * @param inventoryGroupId (optional) 
     * @param supplierId (optional) 
     * @param userId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPrcContractTemplateSearchAppendix(contractNo: string | null | undefined, effectiveFrom: DateTime | null | undefined, effectiveTo: DateTime | null | undefined, creationTime: DateTime | null | undefined, appendixNo: string | null | undefined, approveBy: string | null | undefined, isInternal: boolean | null | undefined, approvalStatus: string | null | undefined, inventoryGroupId: number | null | undefined, supplierId: number | null | undefined, userId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PrcAppendixContractDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/getPrcContractTemplateSearchAppendix?";
        if (contractNo !== undefined && contractNo !== null)
            url_ += "ContractNo=" + encodeURIComponent("" + contractNo) + "&";
        if (effectiveFrom !== undefined && effectiveFrom !== null)
            url_ += "EffectiveFrom=" + encodeURIComponent(effectiveFrom ? "" + effectiveFrom.toString() : "") + "&";
        if (effectiveTo !== undefined && effectiveTo !== null)
            url_ += "EffectiveTo=" + encodeURIComponent(effectiveTo ? "" + effectiveTo.toString() : "") + "&";
        if (creationTime !== undefined && creationTime !== null)
            url_ += "CreationTime=" + encodeURIComponent(creationTime ? "" + creationTime.toString() : "") + "&";
        if (appendixNo !== undefined && appendixNo !== null)
            url_ += "AppendixNo=" + encodeURIComponent("" + appendixNo) + "&";
        if (approveBy !== undefined && approveBy !== null)
            url_ += "ApproveBy=" + encodeURIComponent("" + approveBy) + "&";
        if (isInternal !== undefined && isInternal !== null)
            url_ += "IsInternal=" + encodeURIComponent("" + isInternal) + "&";
        if (approvalStatus !== undefined && approvalStatus !== null)
            url_ += "ApprovalStatus=" + encodeURIComponent("" + approvalStatus) + "&";
        if (inventoryGroupId !== undefined && inventoryGroupId !== null)
            url_ += "InventoryGroupId=" + encodeURIComponent("" + inventoryGroupId) + "&";
        if (supplierId !== undefined && supplierId !== null)
            url_ += "SupplierId=" + encodeURIComponent("" + supplierId) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrcContractTemplateSearchAppendix(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrcContractTemplateSearchAppendix(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrcAppendixContractDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrcAppendixContractDto[]>;
        }));
    }

    protected processGetPrcContractTemplateSearchAppendix(response: HttpResponseBase): Observable<PrcAppendixContractDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PrcAppendixContractDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrcAppendixContractDto[]>(null as any);
    }

    /**
     * @param contractNo (optional) 
     * @param effectiveFrom (optional) 
     * @param effectiveTo (optional) 
     * @param creationTime (optional) 
     * @param appendixNo (optional) 
     * @param approveBy (optional) 
     * @param isInternal (optional) 
     * @param approvalStatus (optional) 
     * @param inventoryGroupId (optional) 
     * @param supplierId (optional) 
     * @param userId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPrcContractTemplateSearchAppendixItems(contractNo: string | null | undefined, effectiveFrom: DateTime | null | undefined, effectiveTo: DateTime | null | undefined, creationTime: DateTime | null | undefined, appendixNo: string | null | undefined, approveBy: string | null | undefined, isInternal: boolean | null | undefined, approvalStatus: string | null | undefined, inventoryGroupId: number | null | undefined, supplierId: number | null | undefined, userId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PrcAppendixContractItemsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/getPrcContractTemplateSearchAppendixItems?";
        if (contractNo !== undefined && contractNo !== null)
            url_ += "ContractNo=" + encodeURIComponent("" + contractNo) + "&";
        if (effectiveFrom !== undefined && effectiveFrom !== null)
            url_ += "EffectiveFrom=" + encodeURIComponent(effectiveFrom ? "" + effectiveFrom.toString() : "") + "&";
        if (effectiveTo !== undefined && effectiveTo !== null)
            url_ += "EffectiveTo=" + encodeURIComponent(effectiveTo ? "" + effectiveTo.toString() : "") + "&";
        if (creationTime !== undefined && creationTime !== null)
            url_ += "CreationTime=" + encodeURIComponent(creationTime ? "" + creationTime.toString() : "") + "&";
        if (appendixNo !== undefined && appendixNo !== null)
            url_ += "AppendixNo=" + encodeURIComponent("" + appendixNo) + "&";
        if (approveBy !== undefined && approveBy !== null)
            url_ += "ApproveBy=" + encodeURIComponent("" + approveBy) + "&";
        if (isInternal !== undefined && isInternal !== null)
            url_ += "IsInternal=" + encodeURIComponent("" + isInternal) + "&";
        if (approvalStatus !== undefined && approvalStatus !== null)
            url_ += "ApprovalStatus=" + encodeURIComponent("" + approvalStatus) + "&";
        if (inventoryGroupId !== undefined && inventoryGroupId !== null)
            url_ += "InventoryGroupId=" + encodeURIComponent("" + inventoryGroupId) + "&";
        if (supplierId !== undefined && supplierId !== null)
            url_ += "SupplierId=" + encodeURIComponent("" + supplierId) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrcContractTemplateSearchAppendixItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrcContractTemplateSearchAppendixItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrcAppendixContractItemsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrcAppendixContractItemsDto[]>;
        }));
    }

    protected processGetPrcContractTemplateSearchAppendixItems(response: HttpResponseBase): Observable<PrcAppendixContractItemsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PrcAppendixContractItemsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrcAppendixContractItemsDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    prcContractTemplateInsert(body: PrcContractTemplateDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/PrcContractTemplateInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrcContractTemplateInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrcContractTemplateInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPrcContractTemplateInsert(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    prcContractTemplateUpdate(body: PrcContractTemplateDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/PrcContractTemplateUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrcContractTemplateUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrcContractTemplateUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPrcContractTemplateUpdate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    prcContractAppendixInsert(body: PrcAppendixContractDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/PrcContractAppendixInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrcContractAppendixInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrcContractAppendixInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPrcContractAppendixInsert(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    prcContractAppendixUpdate(body: PrcAppendixContractDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/PrcContractAppendixUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrcContractAppendixUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrcContractAppendixUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPrcContractAppendixUpdate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    prcContractAppendixItemsInsert(body: PrcAppendixContractItemsDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/PrcContractAppendixItemsInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrcContractAppendixItemsInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrcContractAppendixItemsInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPrcContractAppendixItemsInsert(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    prcContractAppendixItemsUpdate(body: PrcAppendixContractItemsDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/PrcContractAppendixItemsUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrcContractAppendixItemsUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrcContractAppendixItemsUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPrcContractAppendixItemsUpdate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    getAllMstInventoryItems(): Observable<PrcAppendixContractItemsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/GetAllMstInventoryItems";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMstInventoryItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMstInventoryItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrcAppendixContractItemsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrcAppendixContractItemsDto[]>;
        }));
    }

    protected processGetAllMstInventoryItems(response: HttpResponseBase): Observable<PrcAppendixContractItemsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PrcAppendixContractItemsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrcAppendixContractItemsDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllVendor(): Observable<VendorComboboxDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/getAllVendor";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVendor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorComboboxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorComboboxDto[]>;
        }));
    }

    protected processGetAllVendor(response: HttpResponseBase): Observable<VendorComboboxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VendorComboboxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorComboboxDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllInventoryGroup(): Observable<MasterLookupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/getAllInventoryGroup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInventoryGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInventoryGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MasterLookupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MasterLookupDto[]>;
        }));
    }

    protected processGetAllInventoryGroup(response: HttpResponseBase): Observable<MasterLookupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MasterLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MasterLookupDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllPaymentTerm(): Observable<MasterLookupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/getAllPaymentTerm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPaymentTerm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPaymentTerm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MasterLookupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MasterLookupDto[]>;
        }));
    }

    protected processGetAllPaymentTerm(response: HttpResponseBase): Observable<MasterLookupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MasterLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MasterLookupDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    prcContractTemplateDelete(id: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/PrcContractTemplateDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrcContractTemplateDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrcContractTemplateDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPrcContractTemplateDelete(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    prcContractAppendixDelete(id: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/PrcContractAppendixDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrcContractAppendixDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrcContractAppendixDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPrcContractAppendixDelete(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    prcContractAppendixItemsDelete(id: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/PrcContractAppendixItemsDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrcContractAppendixItemsDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrcContractAppendixItemsDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPrcContractAppendixItemsDelete(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    prcContractTemplateCheckEditSupplier(input: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/PrcContractTemplateCheckEditSupplier?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrcContractTemplateCheckEditSupplier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrcContractTemplateCheckEditSupplier(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processPrcContractTemplateCheckEditSupplier(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    importData(body: string | null | undefined): Observable<PrcContractTemplateImportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/ImportData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrcContractTemplateImportDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrcContractTemplateImportDto[]>;
        }));
    }

    protected processImportData(response: HttpResponseBase): Observable<PrcContractTemplateImportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PrcContractTemplateImportDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrcContractTemplateImportDto[]>(null as any);
    }

    /**
     * @param p_AppendixId (optional) 
     * @param body (optional) 
     * @return Success
     */
    importListDetails(p_AppendixId: number | undefined, body: PrcContractTemplateImportDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/ImportListDetails?";
        if (p_AppendixId === null)
            throw new Error("The parameter 'p_AppendixId' cannot be null.");
        else if (p_AppendixId !== undefined)
            url_ += "p_AppendixId=" + encodeURIComponent("" + p_AppendixId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportListDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportListDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportListDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    prcContractTemplateInsertNew(body: PrcContractTemplateInsertDto | undefined): Observable<PrcContractTemplateInsertOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/PrcContractTemplateInsertNew";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrcContractTemplateInsertNew(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrcContractTemplateInsertNew(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrcContractTemplateInsertOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrcContractTemplateInsertOutputDto>;
        }));
    }

    protected processPrcContractTemplateInsertNew(response: HttpResponseBase): Observable<PrcContractTemplateInsertOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrcContractTemplateInsertOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrcContractTemplateInsertOutputDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    prcAppendixContractInsertNew(body: PrcAppendixContractInsertDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/PrcAppendixContractInsertNew";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrcAppendixContractInsertNew(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrcAppendixContractInsertNew(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processPrcAppendixContractInsertNew(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    prcAppendixContractUpdatetNew(body: PrcAppendixContractInsertDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/PrcAppendixContractUpdatetNew";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrcAppendixContractUpdatetNew(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrcAppendixContractUpdatetNew(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPrcAppendixContractUpdatetNew(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    prcContractAppendixItemsDeleteAll(id: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/PrcContractAppendixItemsDeleteAll?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrcContractAppendixItemsDeleteAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrcContractAppendixItemsDeleteAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPrcContractAppendixItemsDeleteAll(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param appendixId (optional) 
     * @return Success
     */
    getAppendixDataById(appendixId: number | undefined): Observable<PrcAppendixContractInsertDto> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/getAppendixDataById?";
        if (appendixId === null)
            throw new Error("The parameter 'appendixId' cannot be null.");
        else if (appendixId !== undefined)
            url_ += "appendixId=" + encodeURIComponent("" + appendixId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppendixDataById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppendixDataById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrcAppendixContractInsertDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrcAppendixContractInsertDto>;
        }));
    }

    protected processGetAppendixDataById(response: HttpResponseBase): Observable<PrcAppendixContractInsertDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrcAppendixContractInsertDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrcAppendixContractInsertDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    importMultipleContract(body: string | null | undefined): Observable<PrcContractTemplateImportMultipleDto> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/ImportMultipleContract";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportMultipleContract(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportMultipleContract(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrcContractTemplateImportMultipleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrcContractTemplateImportMultipleDto>;
        }));
    }

    protected processImportMultipleContract(response: HttpResponseBase): Observable<PrcContractTemplateImportMultipleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrcContractTemplateImportMultipleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrcContractTemplateImportMultipleDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    prcContractTemplateInsMultiple(body: PrcContractTemplateImportMultipleDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/PrcContractTemplateInsMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrcContractTemplateInsMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrcContractTemplateInsMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPrcContractTemplateInsMultiple(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createRequestBackdate(body: InputContractBackdateDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PrcContractTemplate/createRequestBackdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRequestBackdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRequestBackdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateRequestBackdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class PrepaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param poNo (optional) 
     * @param vendorId (optional) 
     * @param vendorSiteId (optional) 
     * @param invoiceId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllPrepayment(poNo: string | null | undefined, vendorId: number | null | undefined, vendorSiteId: number | null | undefined, invoiceId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfPaymentPrepaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Prepayment/getAllPrepayment?";
        if (poNo !== undefined && poNo !== null)
            url_ += "PoNo=" + encodeURIComponent("" + poNo) + "&";
        if (vendorId !== undefined && vendorId !== null)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&";
        if (vendorSiteId !== undefined && vendorSiteId !== null)
            url_ += "VendorSiteId=" + encodeURIComponent("" + vendorSiteId) + "&";
        if (invoiceId !== undefined && invoiceId !== null)
            url_ += "InvoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPrepayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPrepayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfPaymentPrepaymentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfPaymentPrepaymentDto>;
        }));
    }

    protected processGetAllPrepayment(response: HttpResponseBase): Observable<PagedResultDtoOfPaymentPrepaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfPaymentPrepaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPaymentPrepaymentDto>(null as any);
    }

    /**
     * @param poNo (optional) 
     * @param vendorId (optional) 
     * @param vendorSiteId (optional) 
     * @param invoiceId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllPOs(poNo: string | null | undefined, vendorId: number | null | undefined, vendorSiteId: number | null | undefined, invoiceId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetPoHeadersDto> {
        let url_ = this.baseUrl + "/api/services/app/Prepayment/getAllPOs?";
        if (poNo !== undefined && poNo !== null)
            url_ += "PoNo=" + encodeURIComponent("" + poNo) + "&";
        if (vendorId !== undefined && vendorId !== null)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&";
        if (vendorSiteId !== undefined && vendorSiteId !== null)
            url_ += "VendorSiteId=" + encodeURIComponent("" + vendorSiteId) + "&";
        if (invoiceId !== undefined && invoiceId !== null)
            url_ += "InvoiceId=" + encodeURIComponent("" + invoiceId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPOs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPOs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetPoHeadersDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetPoHeadersDto>;
        }));
    }

    protected processGetAllPOs(response: HttpResponseBase): Observable<PagedResultDtoOfGetPoHeadersDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetPoHeadersDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPoHeadersDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Prepayment/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    loadById(id: number | undefined): Observable<PaymentPrepaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Prepayment/LoadById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentPrepaymentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentPrepaymentDto>;
        }));
    }

    protected processLoadById(response: HttpResponseBase): Observable<PaymentPrepaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentPrepaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentPrepaymentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: PaymentPrepaymentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Prepayment/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isDataValid(body: PaymentPrepaymentDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Prepayment/IsDataValid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsDataValid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsDataValid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processIsDataValid(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class ProductImportExcelServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param fileBytes (optional) 
     * @param fileName (optional) 
     * @return Success
     */
    getListProductFromExcel(fileBytes: string | null | undefined, fileName: string | null | undefined): Observable<ProductImportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ProductImportExcel/GetListProductFromExcel?";
        if (fileBytes !== undefined && fileBytes !== null)
            url_ += "fileBytes=" + encodeURIComponent("" + fileBytes) + "&";
        if (fileName !== undefined && fileName !== null)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListProductFromExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListProductFromExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductImportDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductImportDto[]>;
        }));
    }

    protected processGetListProductFromExcel(response: HttpResponseBase): Observable<ProductImportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductImportDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductImportDto[]>(null as any);
    }

    /**
     * @param byteFile (optional) 
     * @param productName (optional) 
     * @param index (optional) 
     * @return Success
     */
    getFileName(byteFile: string | null | undefined, productName: string | null | undefined, index: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ProductImportExcel/GetFileName?";
        if (byteFile !== undefined && byteFile !== null)
            url_ += "byteFile=" + encodeURIComponent("" + byteFile) + "&";
        if (productName !== undefined && productName !== null)
            url_ += "productName=" + encodeURIComponent("" + productName) + "&";
        if (index === null)
            throw new Error("The parameter 'index' cannot be null.");
        else if (index !== undefined)
            url_ += "index=" + encodeURIComponent("" + index) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFileName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFileName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetFileName(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentUserSupplierId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetCurrentUserSupplierId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserSupplierId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserSupplierId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetCurrentUserSupplierId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @return Success
     */
    getCurrentUserProfileForEdit(): Observable<CurrentUserProfileEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetCurrentUserProfileForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserProfileForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserProfileForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentUserProfileEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentUserProfileEditDto>;
        }));
    }

    protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<CurrentUserProfileEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentUserProfileEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrentUserProfileEditDto>(null as any);
    }

    /**
     * @return Success
     */
    disableGoogleAuthenticator(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/DisableGoogleAuthenticator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableGoogleAuthenticator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableGoogleAuthenticator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDisableGoogleAuthenticator(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    updateGoogleAuthenticatorKey(): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateGoogleAuthenticatorKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGoogleAuthenticatorKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGoogleAuthenticatorKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateGoogleAuthenticatorKeyOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateGoogleAuthenticatorKeyOutput>;
        }));
    }

    protected processUpdateGoogleAuthenticatorKey(response: HttpResponseBase): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateGoogleAuthenticatorKeyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateGoogleAuthenticatorKeyOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendVerificationSms(body: SendVerificationSmsInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/SendVerificationSms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendVerificationSms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendVerificationSms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendVerificationSms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifySmsCode(body: VerifySmsCodeInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/VerifySmsCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySmsCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySmsCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processVerifySmsCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    prepareCollectedData(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/PrepareCollectedData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepareCollectedData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepareCollectedData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPrepareCollectedData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCurrentUserProfile(body: CurrentUserProfileEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentUserProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProfilePicture(body: UpdateProfilePictureInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateProfilePicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getPasswordComplexitySetting(): Observable<GetPasswordComplexitySettingOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetPasswordComplexitySetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordComplexitySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordComplexitySetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPasswordComplexitySettingOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPasswordComplexitySettingOutput>;
        }));
    }

    protected processGetPasswordComplexitySetting(response: HttpResponseBase): Observable<GetPasswordComplexitySettingOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPasswordComplexitySettingOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPasswordComplexitySettingOutput>(null as any);
    }

    /**
     * @return Success
     */
    getProfilePicture(): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfilePictureOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfilePictureOutput>;
        }));
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(null as any);
    }

    /**
     * @param username (optional) 
     * @return Success
     */
    getProfilePictureByUserName(username: string | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePictureByUserName?";
        if (username !== undefined && username !== null)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureByUserName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfilePictureOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfilePictureOutput>;
        }));
    }

    protected processGetProfilePictureByUserName(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(null as any);
    }

    /**
     * @param userId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getFriendProfilePicture(userId: number | undefined, tenantId: number | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetFriendProfilePicture?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFriendProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFriendProfilePicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfilePictureOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfilePictureOutput>;
        }));
    }

    protected processGetFriendProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getProfilePictureByUser(userId: number | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePictureByUser?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfilePictureOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfilePictureOutput>;
        }));
    }

    protected processGetProfilePictureByUser(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ProjectCodeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProjectCode/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param fillterText (optional) 
     * @param periodId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllProjectCode(fillterText: string | null | undefined, periodId: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfBmsMstProjectCodeDto> {
        let url_ = this.baseUrl + "/api/services/app/ProjectCode/getAllProjectCode?";
        if (fillterText !== undefined && fillterText !== null)
            url_ += "FillterText=" + encodeURIComponent("" + fillterText) + "&";
        if (periodId === null)
            throw new Error("The parameter 'periodId' cannot be null.");
        else if (periodId !== undefined)
            url_ += "PeriodId=" + encodeURIComponent("" + periodId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProjectCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProjectCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBmsMstProjectCodeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBmsMstProjectCodeDto>;
        }));
    }

    protected processGetAllProjectCode(response: HttpResponseBase): Observable<PagedResultDtoOfBmsMstProjectCodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBmsMstProjectCodeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBmsMstProjectCodeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    loadById(id: number | undefined): Observable<InputProjectCodeDto> {
        let url_ = this.baseUrl + "/api/services/app/ProjectCode/LoadById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InputProjectCodeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InputProjectCodeDto>;
        }));
    }

    protected processLoadById(response: HttpResponseBase): Observable<InputProjectCodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InputProjectCodeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InputProjectCodeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: InputProjectCodeDto | undefined): Observable<ValProjectCodeDto> {
        let url_ = this.baseUrl + "/api/services/app/ProjectCode/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValProjectCodeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValProjectCodeDto>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<ValProjectCodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValProjectCodeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValProjectCodeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveMultiple(body: SaveMultipleProjectCodeDto | undefined): Observable<ValProjectCodeMultipleSave> {
        let url_ = this.baseUrl + "/api/services/app/ProjectCode/SaveMultiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveMultiple(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValProjectCodeMultipleSave>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValProjectCodeMultipleSave>;
        }));
    }

    protected processSaveMultiple(response: HttpResponseBase): Observable<ValProjectCodeMultipleSave> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValProjectCodeMultipleSave.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValProjectCodeMultipleSave>(null as any);
    }
}

@Injectable()
export class PurchaseOrdersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPurchaseOrders(body: InputPurchaseOrdersHeadersDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseOrders/createPurchaseOrders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePurchaseOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePurchaseOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreatePurchaseOrders(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param descriptions (optional) 
     * @param body (optional) 
     * @return Success
     */
    createPOFromPR(descriptions: string | null | undefined, body: GetPurchaseRequestForCreatePODto[] | null | undefined): Observable<GetListPoNumberDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseOrders/createPOFromPR?";
        if (descriptions !== undefined && descriptions !== null)
            url_ += "descriptions=" + encodeURIComponent("" + descriptions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePOFromPR(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePOFromPR(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetListPoNumberDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetListPoNumberDto[]>;
        }));
    }

    protected processCreatePOFromPR(response: HttpResponseBase): Observable<GetListPoNumberDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetListPoNumberDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetListPoNumberDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPoFromUr(body: GetAllUserRequestForPrDto[] | null | undefined): Observable<GetListPoNumberDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseOrders/createPoFromUr";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePoFromUr(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePoFromUr(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetListPoNumberDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetListPoNumberDto[]>;
        }));
    }

    protected processCreatePoFromUr(response: HttpResponseBase): Observable<GetListPoNumberDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetListPoNumberDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetListPoNumberDto[]>(null as any);
    }

    /**
     * @param poId (optional) 
     * @param body (optional) 
     * @return Success
     */
    addPrToPoExist(poId: number | undefined, body: GetPurchaseRequestForCreatePODto[] | null | undefined): Observable<GetListPoNumberDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseOrders/addPrToPoExist?";
        if (poId === null)
            throw new Error("The parameter 'poId' cannot be null.");
        else if (poId !== undefined)
            url_ += "poId=" + encodeURIComponent("" + poId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPrToPoExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPrToPoExist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetListPoNumberDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetListPoNumberDto[]>;
        }));
    }

    protected processAddPrToPoExist(response: HttpResponseBase): Observable<GetListPoNumberDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetListPoNumberDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetListPoNumberDto[]>(null as any);
    }

    /**
     * @param ordersNo (optional) 
     * @param supplierId (optional) 
     * @param billToLocationId (optional) 
     * @param shipToLocationId (optional) 
     * @param inventoryGroupId (optional) 
     * @param buyerId (optional) 
     * @param isInternal (optional) 
     * @param status (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllPurchaseOrders(ordersNo: string | null | undefined, supplierId: number | null | undefined, billToLocationId: number | null | undefined, shipToLocationId: number | null | undefined, inventoryGroupId: number | null | undefined, buyerId: number | null | undefined, isInternal: boolean | null | undefined, status: string | null | undefined, fromDate: DateTime | null | undefined, toDate: DateTime | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetPurchaseOrdersDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseOrders/getAllPurchaseOrders?";
        if (ordersNo !== undefined && ordersNo !== null)
            url_ += "OrdersNo=" + encodeURIComponent("" + ordersNo) + "&";
        if (supplierId !== undefined && supplierId !== null)
            url_ += "SupplierId=" + encodeURIComponent("" + supplierId) + "&";
        if (billToLocationId !== undefined && billToLocationId !== null)
            url_ += "BillToLocationId=" + encodeURIComponent("" + billToLocationId) + "&";
        if (shipToLocationId !== undefined && shipToLocationId !== null)
            url_ += "ShipToLocationId=" + encodeURIComponent("" + shipToLocationId) + "&";
        if (inventoryGroupId !== undefined && inventoryGroupId !== null)
            url_ += "InventoryGroupId=" + encodeURIComponent("" + inventoryGroupId) + "&";
        if (buyerId !== undefined && buyerId !== null)
            url_ += "BuyerId=" + encodeURIComponent("" + buyerId) + "&";
        if (isInternal !== undefined && isInternal !== null)
            url_ += "IsInternal=" + encodeURIComponent("" + isInternal) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toString() : "") + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPurchaseOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPurchaseOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetPurchaseOrdersDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetPurchaseOrdersDto>;
        }));
    }

    protected processGetAllPurchaseOrders(response: HttpResponseBase): Observable<PagedResultDtoOfGetPurchaseOrdersDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetPurchaseOrdersDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPurchaseOrdersDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPoHeadersForEdit(id: number | undefined): Observable<GetPoHeadersForEditDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseOrders/getPoHeadersForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPoHeadersForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPoHeadersForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPoHeadersForEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPoHeadersForEditDto>;
        }));
    }

    protected processGetPoHeadersForEdit(response: HttpResponseBase): Observable<GetPoHeadersForEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPoHeadersForEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPoHeadersForEditDto>(null as any);
    }

    /**
     * @return Success
     */
    saveDataFromImportData(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseOrders/saveDataFromImportData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDataFromImportData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDataFromImportData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveDataFromImportData(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @return Success
     */
    exportTemplate(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseOrders/ExportTemplate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processExportTemplate(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }

    /**
     * @param contractNo (optional) 
     * @param supplierId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllContractForCreatePo(contractNo: string | null | undefined, supplierId: number | null | undefined, fromDate: DateTime | null | undefined, toDate: DateTime | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetContractForCreatePoDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseOrders/getAllContractForCreatePo?";
        if (contractNo !== undefined && contractNo !== null)
            url_ += "ContractNo=" + encodeURIComponent("" + contractNo) + "&";
        if (supplierId !== undefined && supplierId !== null)
            url_ += "SupplierId=" + encodeURIComponent("" + supplierId) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toString() : "") + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllContractForCreatePo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllContractForCreatePo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetContractForCreatePoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetContractForCreatePoDto>;
        }));
    }

    protected processGetAllContractForCreatePo(response: HttpResponseBase): Observable<PagedResultDtoOfGetContractForCreatePoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetContractForCreatePoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetContractForCreatePoDto>(null as any);
    }

    /**
     * @param type (optional) 
     * @param note (optional) 
     * @param body (optional) 
     * @return Success
     */
    supplierComfirm(type: number | undefined, note: string | null | undefined, body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseOrders/supplierComfirm?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (note !== undefined && note !== null)
            url_ += "note=" + encodeURIComponent("" + note) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSupplierComfirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSupplierComfirm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSupplierComfirm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param poNumber (optional) 
     * @return Success
     */
    getListPoForAddPrToPos(poNumber: string | null | undefined): Observable<GetListPoForAddPrToPoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseOrders/getListPoForAddPrToPos?";
        if (poNumber !== undefined && poNumber !== null)
            url_ += "poNumber=" + encodeURIComponent("" + poNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListPoForAddPrToPos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListPoForAddPrToPos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetListPoForAddPrToPoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetListPoForAddPrToPoDto[]>;
        }));
    }

    protected processGetListPoForAddPrToPos(response: HttpResponseBase): Observable<GetListPoForAddPrToPoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetListPoForAddPrToPoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetListPoForAddPrToPoDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportPo(body: InputSearchPoDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseOrders/exportPo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportPo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportPo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processExportPo(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deletePurchaseOrders(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseOrders/deletePurchaseOrders?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePurchaseOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePurchaseOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePurchaseOrders(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class PurchasePurposeImportExcelServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param fileBytes (optional) 
     * @param fileName (optional) 
     * @return Success
     */
    getListPurchasePurposeFromExcel(fileBytes: string | null | undefined, fileName: string | null | undefined): Observable<PurchasePurposeImportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PurchasePurposeImportExcel/GetListPurchasePurposeFromExcel?";
        if (fileBytes !== undefined && fileBytes !== null)
            url_ += "fileBytes=" + encodeURIComponent("" + fileBytes) + "&";
        if (fileName !== undefined && fileName !== null)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListPurchasePurposeFromExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListPurchasePurposeFromExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchasePurposeImportDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchasePurposeImportDto[]>;
        }));
    }

    protected processGetListPurchasePurposeFromExcel(response: HttpResponseBase): Observable<PurchasePurposeImportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PurchasePurposeImportDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchasePurposeImportDto[]>(null as any);
    }
}

@Injectable()
export class PurchaseRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param requisitionNo (optional) 
     * @param preparerId (optional) 
     * @param buyerId (optional) 
     * @param inventoryGroupId (optional) 
     * @param status (optional) 
     * @param isInternal (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllPurchaseRequest(requisitionNo: string | null | undefined, preparerId: number | null | undefined, buyerId: number | null | undefined, inventoryGroupId: number | null | undefined, status: string | null | undefined, isInternal: boolean | null | undefined, fromDate: DateTime | null | undefined, toDate: DateTime | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetPurchaseRequestDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseRequest/getAllPurchaseRequest?";
        if (requisitionNo !== undefined && requisitionNo !== null)
            url_ += "RequisitionNo=" + encodeURIComponent("" + requisitionNo) + "&";
        if (preparerId !== undefined && preparerId !== null)
            url_ += "PreparerId=" + encodeURIComponent("" + preparerId) + "&";
        if (buyerId !== undefined && buyerId !== null)
            url_ += "BuyerId=" + encodeURIComponent("" + buyerId) + "&";
        if (inventoryGroupId !== undefined && inventoryGroupId !== null)
            url_ += "InventoryGroupId=" + encodeURIComponent("" + inventoryGroupId) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (isInternal !== undefined && isInternal !== null)
            url_ += "IsInternal=" + encodeURIComponent("" + isInternal) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toString() : "") + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPurchaseRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPurchaseRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetPurchaseRequestDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetPurchaseRequestDto>;
        }));
    }

    protected processGetAllPurchaseRequest(response: HttpResponseBase): Observable<PagedResultDtoOfGetPurchaseRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetPurchaseRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPurchaseRequestDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPurchaseRequest(body: InputPurchaseRequestHeaderDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseRequest/createPurchaseRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePurchaseRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePurchaseRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreatePurchaseRequest(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPurchaseRequestById(id: number | undefined): Observable<GetPurchaseRequestForEditDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseRequest/getPurchaseRequestById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPurchaseRequestById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPurchaseRequestById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPurchaseRequestForEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPurchaseRequestForEditDto>;
        }));
    }

    protected processGetPurchaseRequestById(response: HttpResponseBase): Observable<GetPurchaseRequestForEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPurchaseRequestForEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPurchaseRequestForEditDto>(null as any);
    }

    /**
     * @param userName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getListRequester(userName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetRequesterDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseRequest/getListRequester?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListRequester(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListRequester(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetRequesterDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetRequesterDto>;
        }));
    }

    protected processGetListRequester(response: HttpResponseBase): Observable<PagedResultDtoOfGetRequesterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetRequesterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRequesterDto>(null as any);
    }

    /**
     * @return Success
     */
    getAllUsers(): Observable<GetRequesterDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseRequest/getAllUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRequesterDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRequesterDto[]>;
        }));
    }

    protected processGetAllUsers(response: HttpResponseBase): Observable<GetRequesterDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetRequesterDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRequesterDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deletePurchaseRequest(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseRequest/deletePurchaseRequest?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePurchaseRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePurchaseRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePurchaseRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param account (optional) 
     * @return Success
     */
    checkAccountDistributions(account: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseRequest/checkAccountDistributions?";
        if (account !== undefined && account !== null)
            url_ += "account=" + encodeURIComponent("" + account) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckAccountDistributions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckAccountDistributions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckAccountDistributions(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPrFromUr(body: GetAllUserRequestForPrDto[] | null | undefined): Observable<GetListPrNumberDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseRequest/createPrFromUr";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePrFromUr(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePrFromUr(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetListPrNumberDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetListPrNumberDto[]>;
        }));
    }

    protected processCreatePrFromUr(response: HttpResponseBase): Observable<GetListPrNumberDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetListPrNumberDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetListPrNumberDto[]>(null as any);
    }

    /**
     * @param requisitionNo (optional) 
     * @param preparerId (optional) 
     * @param buyerId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param supplierId (optional) 
     * @param supplierSiteId (optional) 
     * @param inventoryGroupId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllPurchaseRequestForCreatePO(requisitionNo: string | null | undefined, preparerId: number | null | undefined, buyerId: number | null | undefined, fromDate: DateTime | null | undefined, toDate: DateTime | null | undefined, supplierId: number | null | undefined, supplierSiteId: number | null | undefined, inventoryGroupId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetPurchaseRequestForCreatePODto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseRequest/getAllPurchaseRequestForCreatePO?";
        if (requisitionNo !== undefined && requisitionNo !== null)
            url_ += "RequisitionNo=" + encodeURIComponent("" + requisitionNo) + "&";
        if (preparerId !== undefined && preparerId !== null)
            url_ += "PreparerId=" + encodeURIComponent("" + preparerId) + "&";
        if (buyerId !== undefined && buyerId !== null)
            url_ += "BuyerId=" + encodeURIComponent("" + buyerId) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toString() : "") + "&";
        if (supplierId !== undefined && supplierId !== null)
            url_ += "SupplierId=" + encodeURIComponent("" + supplierId) + "&";
        if (supplierSiteId !== undefined && supplierSiteId !== null)
            url_ += "SupplierSiteId=" + encodeURIComponent("" + supplierSiteId) + "&";
        if (inventoryGroupId !== undefined && inventoryGroupId !== null)
            url_ += "InventoryGroupId=" + encodeURIComponent("" + inventoryGroupId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPurchaseRequestForCreatePO(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPurchaseRequestForCreatePO(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetPurchaseRequestForCreatePODto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetPurchaseRequestForCreatePODto>;
        }));
    }

    protected processGetAllPurchaseRequestForCreatePO(response: HttpResponseBase): Observable<PagedResultDtoOfGetPurchaseRequestForCreatePODto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetPurchaseRequestForCreatePODto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPurchaseRequestForCreatePODto>(null as any);
    }

    /**
     * @param prHeaderId (optional) 
     * @return Success
     */
    getPrDistributionsForCreatePO(prHeaderId: number | undefined): Observable<GetPrDistributionsForCreatePoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseRequest/getPrDistributionsForCreatePO?";
        if (prHeaderId === null)
            throw new Error("The parameter 'prHeaderId' cannot be null.");
        else if (prHeaderId !== undefined)
            url_ += "prHeaderId=" + encodeURIComponent("" + prHeaderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrDistributionsForCreatePO(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrDistributionsForCreatePO(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPrDistributionsForCreatePoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPrDistributionsForCreatePoDto[]>;
        }));
    }

    protected processGetPrDistributionsForCreatePO(response: HttpResponseBase): Observable<GetPrDistributionsForCreatePoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetPrDistributionsForCreatePoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPrDistributionsForCreatePoDto[]>(null as any);
    }

    /**
     * @return Success
     */
    saveDataFromImportExcel(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseRequest/SaveDataFromImportExcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDataFromImportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDataFromImportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveDataFromImportExcel(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @return Success
     */
    exportTemplate(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseRequest/ExportTemplate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processExportTemplate(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportPr(body: SearchPurchaseRequestDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseRequest/exportPr";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportPr(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportPr(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processExportPr(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }

    /**
     * @param inventoryGroupId (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateInventoryGroup(inventoryGroupId: number | undefined, body: GetPurchaseRequestForCreatePODto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PurchaseRequest/updateInventoryGroup?";
        if (inventoryGroupId === null)
            throw new Error("The parameter 'inventoryGroupId' cannot be null.");
        else if (inventoryGroupId !== undefined)
            url_ += "inventoryGroupId=" + encodeURIComponent("" + inventoryGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateInventoryGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateInventoryGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateInventoryGroup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class RcvReceiptNoteHeadersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param poNo (optional) 
     * @param poLineNum (optional) 
     * @param poShipmentNum (optional) 
     * @param prNo (optional) 
     * @param prLineNum (optional) 
     * @param vendorId (optional) 
     * @param vendorSiteId (optional) 
     * @param receivingLocationId (optional) 
     * @param itemNo (optional) 
     * @param tenantId (optional) 
     * @param receiptType (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllExpectedReceiptNoteLines_TMV(poNo: string | null | undefined, poLineNum: number | null | undefined, poShipmentNum: number | null | undefined, prNo: string | null | undefined, prLineNum: number | null | undefined, vendorId: number | null | undefined, vendorSiteId: number | null | undefined, receivingLocationId: number | null | undefined, itemNo: string | null | undefined, tenantId: number | null | undefined, receiptType: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetExpectedReceiptNoteLinesDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvReceiptNoteHeaders/getAllExpectedReceiptNoteLines_TMV?";
        if (poNo !== undefined && poNo !== null)
            url_ += "PoNo=" + encodeURIComponent("" + poNo) + "&";
        if (poLineNum !== undefined && poLineNum !== null)
            url_ += "PoLineNum=" + encodeURIComponent("" + poLineNum) + "&";
        if (poShipmentNum !== undefined && poShipmentNum !== null)
            url_ += "PoShipmentNum=" + encodeURIComponent("" + poShipmentNum) + "&";
        if (prNo !== undefined && prNo !== null)
            url_ += "PrNo=" + encodeURIComponent("" + prNo) + "&";
        if (prLineNum !== undefined && prLineNum !== null)
            url_ += "PrLineNum=" + encodeURIComponent("" + prLineNum) + "&";
        if (vendorId !== undefined && vendorId !== null)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&";
        if (vendorSiteId !== undefined && vendorSiteId !== null)
            url_ += "VendorSiteId=" + encodeURIComponent("" + vendorSiteId) + "&";
        if (receivingLocationId !== undefined && receivingLocationId !== null)
            url_ += "ReceivingLocationId=" + encodeURIComponent("" + receivingLocationId) + "&";
        if (itemNo !== undefined && itemNo !== null)
            url_ += "ItemNo=" + encodeURIComponent("" + itemNo) + "&";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (receiptType === null)
            throw new Error("The parameter 'receiptType' cannot be null.");
        else if (receiptType !== undefined)
            url_ += "ReceiptType=" + encodeURIComponent("" + receiptType) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllExpectedReceiptNoteLines_TMV(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllExpectedReceiptNoteLines_TMV(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetExpectedReceiptNoteLinesDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetExpectedReceiptNoteLinesDto>;
        }));
    }

    protected processGetAllExpectedReceiptNoteLines_TMV(response: HttpResponseBase): Observable<PagedResultDtoOfGetExpectedReceiptNoteLinesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetExpectedReceiptNoteLinesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetExpectedReceiptNoteLinesDto>(null as any);
    }

    /**
     * @param poNo (optional) 
     * @param poLineNum (optional) 
     * @param poShipmentNum (optional) 
     * @param vendorId (optional) 
     * @param vendorSiteId (optional) 
     * @param itemNo (optional) 
     * @param tenantId (optional) 
     * @param receiptNoteType (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllExpectedReceiptNoteLines(poNo: string | null | undefined, poLineNum: number | null | undefined, poShipmentNum: number | null | undefined, vendorId: number | null | undefined, vendorSiteId: number | null | undefined, itemNo: string | null | undefined, tenantId: number | null | undefined, receiptNoteType: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetExpectedReceiptNoteLinesDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvReceiptNoteHeaders/getAllExpectedReceiptNoteLines?";
        if (poNo !== undefined && poNo !== null)
            url_ += "PoNo=" + encodeURIComponent("" + poNo) + "&";
        if (poLineNum !== undefined && poLineNum !== null)
            url_ += "PoLineNum=" + encodeURIComponent("" + poLineNum) + "&";
        if (poShipmentNum !== undefined && poShipmentNum !== null)
            url_ += "PoShipmentNum=" + encodeURIComponent("" + poShipmentNum) + "&";
        if (vendorId !== undefined && vendorId !== null)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&";
        if (vendorSiteId !== undefined && vendorSiteId !== null)
            url_ += "VendorSiteId=" + encodeURIComponent("" + vendorSiteId) + "&";
        if (itemNo !== undefined && itemNo !== null)
            url_ += "ItemNo=" + encodeURIComponent("" + itemNo) + "&";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (receiptNoteType === null)
            throw new Error("The parameter 'receiptNoteType' cannot be null.");
        else if (receiptNoteType !== undefined)
            url_ += "ReceiptNoteType=" + encodeURIComponent("" + receiptNoteType) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllExpectedReceiptNoteLines(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllExpectedReceiptNoteLines(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetExpectedReceiptNoteLinesDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetExpectedReceiptNoteLinesDto>;
        }));
    }

    protected processGetAllExpectedReceiptNoteLines(response: HttpResponseBase): Observable<PagedResultDtoOfGetExpectedReceiptNoteLinesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetExpectedReceiptNoteLinesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetExpectedReceiptNoteLinesDto>(null as any);
    }

    /**
     * @param receiptNoteNum (optional) 
     * @param vendorId (optional) 
     * @param vendorSiteId (optional) 
     * @param status (optional) 
     * @param receiptNoteType (optional) 
     * @param shippedDateFrom (optional) 
     * @param shippedDateTo (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllReceiptNotes(receiptNoteNum: string | null | undefined, vendorId: number | null | undefined, vendorSiteId: number | null | undefined, status: number | null | undefined, receiptNoteType: number | undefined, shippedDateFrom: DateTime | null | undefined, shippedDateTo: DateTime | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetRcvReceiptNoteHeadersDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvReceiptNoteHeaders/getAllReceiptNotes?";
        if (receiptNoteNum !== undefined && receiptNoteNum !== null)
            url_ += "ReceiptNoteNum=" + encodeURIComponent("" + receiptNoteNum) + "&";
        if (vendorId !== undefined && vendorId !== null)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&";
        if (vendorSiteId !== undefined && vendorSiteId !== null)
            url_ += "VendorSiteId=" + encodeURIComponent("" + vendorSiteId) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (receiptNoteType === null)
            throw new Error("The parameter 'receiptNoteType' cannot be null.");
        else if (receiptNoteType !== undefined)
            url_ += "ReceiptNoteType=" + encodeURIComponent("" + receiptNoteType) + "&";
        if (shippedDateFrom !== undefined && shippedDateFrom !== null)
            url_ += "ShippedDateFrom=" + encodeURIComponent(shippedDateFrom ? "" + shippedDateFrom.toString() : "") + "&";
        if (shippedDateTo !== undefined && shippedDateTo !== null)
            url_ += "ShippedDateTo=" + encodeURIComponent(shippedDateTo ? "" + shippedDateTo.toString() : "") + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllReceiptNotes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllReceiptNotes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetRcvReceiptNoteHeadersDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetRcvReceiptNoteHeadersDto>;
        }));
    }

    protected processGetAllReceiptNotes(response: HttpResponseBase): Observable<PagedResultDtoOfGetRcvReceiptNoteHeadersDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetRcvReceiptNoteHeadersDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRcvReceiptNoteHeadersDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateReceiptNoteHeader(body: InputRcvReceiptNoteHeadersDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RcvReceiptNoteHeaders/updateReceiptNoteHeader";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateReceiptNoteHeader(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateReceiptNoteHeader(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateReceiptNoteHeader(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createReceiptNotes(body: InputRcvReceiptNoteHeadersDto | undefined): Observable<InputRcvReceiptNoteHeadersDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvReceiptNoteHeaders/createReceiptNotes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateReceiptNotes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateReceiptNotes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InputRcvReceiptNoteHeadersDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InputRcvReceiptNoteHeadersDto>;
        }));
    }

    protected processCreateReceiptNotes(response: HttpResponseBase): Observable<InputRcvReceiptNoteHeadersDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InputRcvReceiptNoteHeadersDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InputRcvReceiptNoteHeadersDto>(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    getUserList(tenantId: number | null | undefined): Observable<AbpUserDto[]> {
        let url_ = this.baseUrl + "/api/services/app/RcvReceiptNoteHeaders/GetUserList?";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AbpUserDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AbpUserDto[]>;
        }));
    }

    protected processGetUserList(response: HttpResponseBase): Observable<AbpUserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AbpUserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AbpUserDto[]>(null as any);
    }

    /**
     * @param idList (optional) 
     * @return Success
     */
    getReceiptNoteLinesForReceipt(idList: string | null | undefined): Observable<PagedResultDtoOfGetRcvReceiptNoteLineForEditDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvReceiptNoteHeaders/getReceiptNoteLinesForReceipt?";
        if (idList !== undefined && idList !== null)
            url_ += "idList=" + encodeURIComponent("" + idList) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReceiptNoteLinesForReceipt(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReceiptNoteLinesForReceipt(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetRcvReceiptNoteLineForEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetRcvReceiptNoteLineForEditDto>;
        }));
    }

    protected processGetReceiptNoteLinesForReceipt(response: HttpResponseBase): Observable<PagedResultDtoOfGetRcvReceiptNoteLineForEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetRcvReceiptNoteLineForEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRcvReceiptNoteLineForEditDto>(null as any);
    }

    /**
     * @param receiptNoteNum (optional) 
     * @return Success
     */
    getReceiptNoteByNumForReceipt(receiptNoteNum: string | null | undefined): Observable<GetRcvReceiptNoteHeaderForEditDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvReceiptNoteHeaders/getReceiptNoteByNumForReceipt?";
        if (receiptNoteNum !== undefined && receiptNoteNum !== null)
            url_ += "ReceiptNoteNum=" + encodeURIComponent("" + receiptNoteNum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReceiptNoteByNumForReceipt(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReceiptNoteByNumForReceipt(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRcvReceiptNoteHeaderForEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRcvReceiptNoteHeaderForEditDto>;
        }));
    }

    protected processGetReceiptNoteByNumForReceipt(response: HttpResponseBase): Observable<GetRcvReceiptNoteHeaderForEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRcvReceiptNoteHeaderForEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRcvReceiptNoteHeaderForEditDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cancelReceiptNote(id: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/RcvReceiptNoteHeaders/cancelReceiptNote?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelReceiptNote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelReceiptNote(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCancelReceiptNote(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param idList (optional) 
     * @return Success
     */
    getReceiptNoteByIdForReceipt(idList: number[] | null | undefined): Observable<GetRcvReceiptNoteHeaderForEditDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvReceiptNoteHeaders/getReceiptNoteByIdForReceipt?";
        if (idList !== undefined && idList !== null)
            idList && idList.forEach(item => { url_ += "idList=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReceiptNoteByIdForReceipt(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReceiptNoteByIdForReceipt(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRcvReceiptNoteHeaderForEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRcvReceiptNoteHeaderForEditDto>;
        }));
    }

    protected processGetReceiptNoteByIdForReceipt(response: HttpResponseBase): Observable<GetRcvReceiptNoteHeaderForEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRcvReceiptNoteHeaderForEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRcvReceiptNoteHeaderForEditDto>(null as any);
    }

    /**
     * @param receiptNoteNum (optional) 
     * @param vendorId (optional) 
     * @param vendorSiteId (optional) 
     * @param status (optional) 
     * @param receiptNoteType (optional) 
     * @param shippedDateFrom (optional) 
     * @param shippedDateTo (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getReceiptNoteByNumForView(receiptNoteNum: string | null | undefined, vendorId: number | null | undefined, vendorSiteId: number | null | undefined, status: number | null | undefined, receiptNoteType: number | undefined, shippedDateFrom: DateTime | null | undefined, shippedDateTo: DateTime | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetRcvReceiptNoteHeadersDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvReceiptNoteHeaders/getReceiptNoteByNumForView?";
        if (receiptNoteNum !== undefined && receiptNoteNum !== null)
            url_ += "ReceiptNoteNum=" + encodeURIComponent("" + receiptNoteNum) + "&";
        if (vendorId !== undefined && vendorId !== null)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&";
        if (vendorSiteId !== undefined && vendorSiteId !== null)
            url_ += "VendorSiteId=" + encodeURIComponent("" + vendorSiteId) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (receiptNoteType === null)
            throw new Error("The parameter 'receiptNoteType' cannot be null.");
        else if (receiptNoteType !== undefined)
            url_ += "ReceiptNoteType=" + encodeURIComponent("" + receiptNoteType) + "&";
        if (shippedDateFrom !== undefined && shippedDateFrom !== null)
            url_ += "ShippedDateFrom=" + encodeURIComponent(shippedDateFrom ? "" + shippedDateFrom.toString() : "") + "&";
        if (shippedDateTo !== undefined && shippedDateTo !== null)
            url_ += "ShippedDateTo=" + encodeURIComponent(shippedDateTo ? "" + shippedDateTo.toString() : "") + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReceiptNoteByNumForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReceiptNoteByNumForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRcvReceiptNoteHeadersDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRcvReceiptNoteHeadersDto>;
        }));
    }

    protected processGetReceiptNoteByNumForView(response: HttpResponseBase): Observable<GetRcvReceiptNoteHeadersDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRcvReceiptNoteHeadersDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRcvReceiptNoteHeadersDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getReceiptNoteByIdForView(id: number | undefined): Observable<GetRcvReceiptNoteHeadersDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvReceiptNoteHeaders/getReceiptNoteByIdForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReceiptNoteByIdForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReceiptNoteByIdForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRcvReceiptNoteHeadersDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRcvReceiptNoteHeadersDto>;
        }));
    }

    protected processGetReceiptNoteByIdForView(response: HttpResponseBase): Observable<GetRcvReceiptNoteHeadersDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRcvReceiptNoteHeadersDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRcvReceiptNoteHeadersDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getReceiptNoteDetail(id: number | undefined): Observable<PagedResultDtoOfInputRcvReceiptNoteLinesDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvReceiptNoteHeaders/getReceiptNoteDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReceiptNoteDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReceiptNoteDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfInputRcvReceiptNoteLinesDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfInputRcvReceiptNoteLinesDto>;
        }));
    }

    protected processGetReceiptNoteDetail(response: HttpResponseBase): Observable<PagedResultDtoOfInputRcvReceiptNoteLinesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfInputRcvReceiptNoteLinesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfInputRcvReceiptNoteLinesDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param pFormType (optional) 
     * @return Success
     */
    getReceiptNoteReportById(id: number | null | undefined, pFormType: number | undefined): Observable<GetReceiptNoteReportDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvReceiptNoteHeaders/getReceiptNoteReportById?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (pFormType === null)
            throw new Error("The parameter 'pFormType' cannot be null.");
        else if (pFormType !== undefined)
            url_ += "pFormType=" + encodeURIComponent("" + pFormType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReceiptNoteReportById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReceiptNoteReportById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetReceiptNoteReportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetReceiptNoteReportDto>;
        }));
    }

    protected processGetReceiptNoteReportById(response: HttpResponseBase): Observable<GetReceiptNoteReportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetReceiptNoteReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetReceiptNoteReportDto>(null as any);
    }

    /**
     * @param poNo (optional) 
     * @param vendorId (optional) 
     * @param vendorSiteId (optional) 
     * @param receiptNoteType (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPOsForReceiptNote(poNo: string | null | undefined, vendorId: number | null | undefined, vendorSiteId: number | null | undefined, receiptNoteType: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetPoHeadersDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvReceiptNoteHeaders/getPOsForReceiptNote?";
        if (poNo !== undefined && poNo !== null)
            url_ += "PoNo=" + encodeURIComponent("" + poNo) + "&";
        if (vendorId !== undefined && vendorId !== null)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&";
        if (vendorSiteId !== undefined && vendorSiteId !== null)
            url_ += "VendorSiteId=" + encodeURIComponent("" + vendorSiteId) + "&";
        if (receiptNoteType === null)
            throw new Error("The parameter 'receiptNoteType' cannot be null.");
        else if (receiptNoteType !== undefined)
            url_ += "ReceiptNoteType=" + encodeURIComponent("" + receiptNoteType) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPOsForReceiptNote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPOsForReceiptNote(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetPoHeadersDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetPoHeadersDto>;
        }));
    }

    protected processGetPOsForReceiptNote(response: HttpResponseBase): Observable<PagedResultDtoOfGetPoHeadersDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetPoHeadersDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPoHeadersDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportRN(body: SearchAllReceiptNotesDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvReceiptNoteHeaders/exportRN";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportRN(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportRN(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processExportRN(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }
}

@Injectable()
export class RcvRoutingHeadersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllRoutings(): Observable<GetRcvRoutingHeadersDto[]> {
        let url_ = this.baseUrl + "/api/services/app/RcvRoutingHeaders/getAllRoutings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRoutings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRoutings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRcvRoutingHeadersDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRcvRoutingHeadersDto[]>;
        }));
    }

    protected processGetAllRoutings(response: HttpResponseBase): Observable<GetRcvRoutingHeadersDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetRcvRoutingHeadersDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRcvRoutingHeadersDto[]>(null as any);
    }
}

@Injectable()
export class RcvShipmentHeadersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param poNo (optional) 
     * @param poLineNum (optional) 
     * @param poShipmentNum (optional) 
     * @param prNo (optional) 
     * @param prLineNum (optional) 
     * @param vendorId (optional) 
     * @param vendorSiteId (optional) 
     * @param receivingLocationId (optional) 
     * @param itemNo (optional) 
     * @param tenantId (optional) 
     * @param receiptType (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllExpectedReceipts_Store(poNo: string | null | undefined, poLineNum: number | null | undefined, poShipmentNum: number | null | undefined, prNo: string | null | undefined, prLineNum: number | null | undefined, vendorId: number | null | undefined, vendorSiteId: number | null | undefined, receivingLocationId: number | null | undefined, itemNo: string | null | undefined, tenantId: number | null | undefined, receiptType: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfExpectedReceiptsDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvShipmentHeaders/getAllExpectedReceipts_Store?";
        if (poNo !== undefined && poNo !== null)
            url_ += "PoNo=" + encodeURIComponent("" + poNo) + "&";
        if (poLineNum !== undefined && poLineNum !== null)
            url_ += "PoLineNum=" + encodeURIComponent("" + poLineNum) + "&";
        if (poShipmentNum !== undefined && poShipmentNum !== null)
            url_ += "PoShipmentNum=" + encodeURIComponent("" + poShipmentNum) + "&";
        if (prNo !== undefined && prNo !== null)
            url_ += "PrNo=" + encodeURIComponent("" + prNo) + "&";
        if (prLineNum !== undefined && prLineNum !== null)
            url_ += "PrLineNum=" + encodeURIComponent("" + prLineNum) + "&";
        if (vendorId !== undefined && vendorId !== null)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&";
        if (vendorSiteId !== undefined && vendorSiteId !== null)
            url_ += "VendorSiteId=" + encodeURIComponent("" + vendorSiteId) + "&";
        if (receivingLocationId !== undefined && receivingLocationId !== null)
            url_ += "ReceivingLocationId=" + encodeURIComponent("" + receivingLocationId) + "&";
        if (itemNo !== undefined && itemNo !== null)
            url_ += "ItemNo=" + encodeURIComponent("" + itemNo) + "&";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (receiptType === null)
            throw new Error("The parameter 'receiptType' cannot be null.");
        else if (receiptType !== undefined)
            url_ += "ReceiptType=" + encodeURIComponent("" + receiptType) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllExpectedReceipts_Store(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllExpectedReceipts_Store(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfExpectedReceiptsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfExpectedReceiptsDto>;
        }));
    }

    protected processGetAllExpectedReceipts_Store(response: HttpResponseBase): Observable<PagedResultDtoOfExpectedReceiptsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfExpectedReceiptsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfExpectedReceiptsDto>(null as any);
    }

    /**
     * @param receiptNum (optional) 
     * @param vendorId (optional) 
     * @param vendorSiteId (optional) 
     * @param status (optional) 
     * @param authorizationStatus (optional) 
     * @param receiptType (optional) 
     * @param receivedDateFrom (optional) 
     * @param receivedDateTo (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllReceipts(receiptNum: string | null | undefined, vendorId: number | null | undefined, vendorSiteId: number | null | undefined, status: number | null | undefined, authorizationStatus: string | null | undefined, receiptType: number | undefined, receivedDateFrom: DateTime | null | undefined, receivedDateTo: DateTime | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfInputRcvShipmentHeadersDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvShipmentHeaders/getAllReceipts?";
        if (receiptNum !== undefined && receiptNum !== null)
            url_ += "ReceiptNum=" + encodeURIComponent("" + receiptNum) + "&";
        if (vendorId !== undefined && vendorId !== null)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&";
        if (vendorSiteId !== undefined && vendorSiteId !== null)
            url_ += "VendorSiteId=" + encodeURIComponent("" + vendorSiteId) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (authorizationStatus !== undefined && authorizationStatus !== null)
            url_ += "AuthorizationStatus=" + encodeURIComponent("" + authorizationStatus) + "&";
        if (receiptType === null)
            throw new Error("The parameter 'receiptType' cannot be null.");
        else if (receiptType !== undefined)
            url_ += "ReceiptType=" + encodeURIComponent("" + receiptType) + "&";
        if (receivedDateFrom !== undefined && receivedDateFrom !== null)
            url_ += "ReceivedDateFrom=" + encodeURIComponent(receivedDateFrom ? "" + receivedDateFrom.toString() : "") + "&";
        if (receivedDateTo !== undefined && receivedDateTo !== null)
            url_ += "ReceivedDateTo=" + encodeURIComponent(receivedDateTo ? "" + receivedDateTo.toString() : "") + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllReceipts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllReceipts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfInputRcvShipmentHeadersDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfInputRcvShipmentHeadersDto>;
        }));
    }

    protected processGetAllReceipts(response: HttpResponseBase): Observable<PagedResultDtoOfInputRcvShipmentHeadersDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfInputRcvShipmentHeadersDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfInputRcvShipmentHeadersDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateReceiptHeader(body: InputRcvShipmentHeadersDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RcvShipmentHeaders/updateReceiptHeader";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateReceiptHeader(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateReceiptHeader(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateReceiptHeader(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createGoodsReceipt(body: InputRcvShipmentHeadersDto | undefined): Observable<InputRcvShipmentHeadersDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvShipmentHeaders/createGoodsReceipt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateGoodsReceipt(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateGoodsReceipt(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InputRcvShipmentHeadersDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InputRcvShipmentHeadersDto>;
        }));
    }

    protected processCreateGoodsReceipt(response: HttpResponseBase): Observable<InputRcvShipmentHeadersDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InputRcvShipmentHeadersDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InputRcvShipmentHeadersDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    returnGoodsReceipt(body: InputRcvShipmentHeadersDto | undefined): Observable<InputRcvShipmentHeadersDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvShipmentHeaders/returnGoodsReceipt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReturnGoodsReceipt(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReturnGoodsReceipt(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InputRcvShipmentHeadersDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InputRcvShipmentHeadersDto>;
        }));
    }

    protected processReturnGoodsReceipt(response: HttpResponseBase): Observable<InputRcvShipmentHeadersDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InputRcvShipmentHeadersDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InputRcvShipmentHeadersDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getGoodsReceiptDetail(id: number | undefined): Observable<PagedResultDtoOfGetRcvShipmentLineForEditDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvShipmentHeaders/getGoodsReceiptDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGoodsReceiptDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGoodsReceiptDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetRcvShipmentLineForEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetRcvShipmentLineForEditDto>;
        }));
    }

    protected processGetGoodsReceiptDetail(response: HttpResponseBase): Observable<PagedResultDtoOfGetRcvShipmentLineForEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetRcvShipmentLineForEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRcvShipmentLineForEditDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getGoodsReceiptByIdForView(id: number | undefined): Observable<GetRcvShipmentHeaderForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvShipmentHeaders/getGoodsReceiptByIdForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGoodsReceiptByIdForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGoodsReceiptByIdForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRcvShipmentHeaderForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRcvShipmentHeaderForViewDto>;
        }));
    }

    protected processGetGoodsReceiptByIdForView(response: HttpResponseBase): Observable<GetRcvShipmentHeaderForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRcvShipmentHeaderForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRcvShipmentHeaderForViewDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getGoodsReceiptById(id: number | undefined): Observable<GetRcvShipmentHeaderForEditDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvShipmentHeaders/getGoodsReceiptById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGoodsReceiptById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGoodsReceiptById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRcvShipmentHeaderForEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRcvShipmentHeaderForEditDto>;
        }));
    }

    protected processGetGoodsReceiptById(response: HttpResponseBase): Observable<GetRcvShipmentHeaderForEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRcvShipmentHeaderForEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRcvShipmentHeaderForEditDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getGoodsReceiptForReturnById(id: number | undefined): Observable<GetRcvShipmentHeaderForEditDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvShipmentHeaders/getGoodsReceiptForReturnById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGoodsReceiptForReturnById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGoodsReceiptForReturnById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRcvShipmentHeaderForEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRcvShipmentHeaderForEditDto>;
        }));
    }

    protected processGetGoodsReceiptForReturnById(response: HttpResponseBase): Observable<GetRcvShipmentHeaderForEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRcvShipmentHeaderForEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRcvShipmentHeaderForEditDto>(null as any);
    }

    /**
     * @param headerid (optional) 
     * @return Success
     */
    getAllAttachmentsByHeaderID(headerid: number | null | undefined): Observable<RcvShipmentAttachmentsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/RcvShipmentHeaders/getAllAttachmentsByHeaderID?";
        if (headerid !== undefined && headerid !== null)
            url_ += "headerid=" + encodeURIComponent("" + headerid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAttachmentsByHeaderID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAttachmentsByHeaderID(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RcvShipmentAttachmentsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RcvShipmentAttachmentsDto[]>;
        }));
    }

    protected processGetAllAttachmentsByHeaderID(response: HttpResponseBase): Observable<RcvShipmentAttachmentsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RcvShipmentAttachmentsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RcvShipmentAttachmentsDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cancelReceipt(id: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/RcvShipmentHeaders/CancelReceipt?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelReceipt(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelReceipt(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCancelReceipt(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportGR(body: SearchAllReceiptsDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvShipmentHeaders/exportGR";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportGR(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportGR(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processExportGR(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    exportGRDetail(id: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvShipmentHeaders/exportGRDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportGRDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportGRDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processExportGRDetail(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }

    /**
     * @param receiptNum (optional) 
     * @param vendorId (optional) 
     * @param poNo (optional) 
     * @param partNo (optional) 
     * @param receiptType (optional) 
     * @param receivedDateFrom (optional) 
     * @param receivedDateTo (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllReturns(receiptNum: string | null | undefined, vendorId: number | null | undefined, poNo: string | null | undefined, partNo: string | null | undefined, receiptType: number | undefined, receivedDateFrom: DateTime | null | undefined, receivedDateTo: DateTime | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfReturnLinesDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvShipmentHeaders/getAllReturns?";
        if (receiptNum !== undefined && receiptNum !== null)
            url_ += "ReceiptNum=" + encodeURIComponent("" + receiptNum) + "&";
        if (vendorId !== undefined && vendorId !== null)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&";
        if (poNo !== undefined && poNo !== null)
            url_ += "PoNo=" + encodeURIComponent("" + poNo) + "&";
        if (partNo !== undefined && partNo !== null)
            url_ += "PartNo=" + encodeURIComponent("" + partNo) + "&";
        if (receiptType === null)
            throw new Error("The parameter 'receiptType' cannot be null.");
        else if (receiptType !== undefined)
            url_ += "ReceiptType=" + encodeURIComponent("" + receiptType) + "&";
        if (receivedDateFrom !== undefined && receivedDateFrom !== null)
            url_ += "ReceivedDateFrom=" + encodeURIComponent(receivedDateFrom ? "" + receivedDateFrom.toString() : "") + "&";
        if (receivedDateTo !== undefined && receivedDateTo !== null)
            url_ += "ReceivedDateTo=" + encodeURIComponent(receivedDateTo ? "" + receivedDateTo.toString() : "") + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllReturns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllReturns(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfReturnLinesDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfReturnLinesDto>;
        }));
    }

    protected processGetAllReturns(response: HttpResponseBase): Observable<PagedResultDtoOfReturnLinesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfReturnLinesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfReturnLinesDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportReturns(body: SearchAllReturnsDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/RcvShipmentHeaders/exportReturns";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportReturns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportReturns(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processExportReturns(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }
}

@Injectable()
export class RequestApprovalServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    search(body: RequestApprovalSearchInputDto | undefined): Observable<PagedResultDtoOfRequestApprovalSearchOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/RequestApproval/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfRequestApprovalSearchOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfRequestApprovalSearchOutputDto>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<PagedResultDtoOfRequestApprovalSearchOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfRequestApprovalSearchOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRequestApprovalSearchOutputDto>(null as any);
    }

    /**
     * @param stepId (optional) 
     * @param requestNote (optional) 
     * @param replyNote (optional) 
     * @return Success
     */
    requestOrReplyInfo(stepId: number | undefined, requestNote: string | null | undefined, replyNote: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/RequestApproval/RequestOrReplyInfo?";
        if (stepId === null)
            throw new Error("The parameter 'stepId' cannot be null.");
        else if (stepId !== undefined)
            url_ += "stepId=" + encodeURIComponent("" + stepId) + "&";
        if (requestNote !== undefined && requestNote !== null)
            url_ += "requestNote=" + encodeURIComponent("" + requestNote) + "&";
        if (replyNote !== undefined && replyNote !== null)
            url_ += "replyNote=" + encodeURIComponent("" + replyNote) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestOrReplyInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestOrReplyInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRequestOrReplyInfo(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param headerId (optional) 
     * @param replyNote (optional) 
     * @return Success
     */
    replyFromHeader(headerId: number | undefined, replyNote: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RequestApproval/ReplyFromHeader?";
        if (headerId === null)
            throw new Error("The parameter 'headerId' cannot be null.");
        else if (headerId !== undefined)
            url_ += "headerId=" + encodeURIComponent("" + headerId) + "&";
        if (replyNote !== undefined && replyNote !== null)
            url_ += "replyNote=" + encodeURIComponent("" + replyNote) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplyFromHeader(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplyFromHeader(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReplyFromHeader(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class RequestApprovalTreeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrReject(body: ApproveOrRejectInputDto | undefined): Observable<ApproveOrRejectOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/ApproveOrReject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrReject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrReject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApproveOrRejectOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApproveOrRejectOutputDto>;
        }));
    }

    protected processApproveOrReject(response: HttpResponseBase): Observable<ApproveOrRejectOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApproveOrRejectOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApproveOrRejectOutputDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createRequestApprovalTree(body: CreateRequestApprovalInputDto | undefined): Observable<CreateRequestApprovalOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/CreateRequestApprovalTree";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRequestApprovalTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRequestApprovalTree(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateRequestApprovalOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateRequestApprovalOutputDto>;
        }));
    }

    protected processCreateRequestApprovalTree(response: HttpResponseBase): Observable<CreateRequestApprovalOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateRequestApprovalOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateRequestApprovalOutputDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param typeCode (optional) 
     * @return Success
     */
    getNextApprovalId(id: number | undefined, typeCode: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/GetNextApprovalId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (typeCode !== undefined && typeCode !== null)
            url_ += "typeCode=" + encodeURIComponent("" + typeCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNextApprovalId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNextApprovalId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetNextApprovalId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    requestNextApprovalTree(body: RequestNextApprovalTreeInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/RequestNextApprovalTree";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestNextApprovalTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestNextApprovalTree(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRequestNextApprovalTree(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param reqId (optional) 
     * @param processTypeCode (optional) 
     * @return Success
     */
    getApprovalRequestHistory(reqId: number | undefined, processTypeCode: string | null | undefined): Observable<RequestApprovalHistoryOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/GetApprovalRequestHistory?";
        if (reqId === null)
            throw new Error("The parameter 'reqId' cannot be null.");
        else if (reqId !== undefined)
            url_ += "ReqId=" + encodeURIComponent("" + reqId) + "&";
        if (processTypeCode !== undefined && processTypeCode !== null)
            url_ += "ProcessTypeCode=" + encodeURIComponent("" + processTypeCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApprovalRequestHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApprovalRequestHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestApprovalHistoryOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestApprovalHistoryOutputDto[]>;
        }));
    }

    protected processGetApprovalRequestHistory(response: HttpResponseBase): Observable<RequestApprovalHistoryOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RequestApprovalHistoryOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestApprovalHistoryOutputDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    forward(body: ForwardInputDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/Forward";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForward(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processForward(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    forwardAndApprove(body: FowardApproveInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/ForwardAndApprove";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForwardAndApprove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForwardAndApprove(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processForwardAndApprove(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getUserById(userId: number | null | undefined): Observable<User> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/GetUserById?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processGetUserById(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(null as any);
    }

    /**
     * @param note (optional) 
     * @param body (optional) 
     * @return Success
     */
    skipSelectedSteps(note: string | null | undefined, body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/SkipSelectedSteps?";
        if (note !== undefined && note !== null)
            url_ += "note=" + encodeURIComponent("" + note) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSkipSelectedSteps(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSkipSelectedSteps(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSkipSelectedSteps(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    confirmRequestForSending(body: RequestNextApprovalTreeInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/ConfirmRequestForSending";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmRequestForSending(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmRequestForSending(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConfirmRequestForSending(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param stepId (optional) 
     * @param newUserId (optional) 
     * @param note (optional) 
     * @return Success
     */
    forwardAndSkip(stepId: number | undefined, newUserId: number | undefined, note: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/ForwardAndSkip?";
        if (stepId === null)
            throw new Error("The parameter 'stepId' cannot be null.");
        else if (stepId !== undefined)
            url_ += "stepId=" + encodeURIComponent("" + stepId) + "&";
        if (newUserId === null)
            throw new Error("The parameter 'newUserId' cannot be null.");
        else if (newUserId !== undefined)
            url_ += "newUserId=" + encodeURIComponent("" + newUserId) + "&";
        if (note !== undefined && note !== null)
            url_ += "note=" + encodeURIComponent("" + note) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForwardAndSkip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForwardAndSkip(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processForwardAndSkip(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param reqId (optional) 
     * @param processTypeCode (optional) 
     * @return Success
     */
    undoRequest(reqId: number | undefined, processTypeCode: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/UndoRequest?";
        if (reqId === null)
            throw new Error("The parameter 'reqId' cannot be null.");
        else if (reqId !== undefined)
            url_ += "reqId=" + encodeURIComponent("" + reqId) + "&";
        if (processTypeCode !== undefined && processTypeCode !== null)
            url_ += "processTypeCode=" + encodeURIComponent("" + processTypeCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUndoRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUndoRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUndoRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param userId (optional) 
     * @param reqId (optional) 
     * @param processTypeCode (optional) 
     * @param dayOfProcess (optional) 
     * @return Success
     */
    addNewStepToTree(userId: number | undefined, reqId: number | undefined, processTypeCode: string | null | undefined, dayOfProcess: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/AddNewStepToTree?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (reqId === null)
            throw new Error("The parameter 'reqId' cannot be null.");
        else if (reqId !== undefined)
            url_ += "reqId=" + encodeURIComponent("" + reqId) + "&";
        if (processTypeCode !== undefined && processTypeCode !== null)
            url_ += "processTypeCode=" + encodeURIComponent("" + processTypeCode) + "&";
        if (dayOfProcess === null)
            throw new Error("The parameter 'dayOfProcess' cannot be null.");
        else if (dayOfProcess !== undefined)
            url_ += "dayOfProcess=" + encodeURIComponent("" + dayOfProcess) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewStepToTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewStepToTree(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddNewStepToTree(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param stepId (optional) 
     * @return Success
     */
    deleteStep(stepId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/DeleteStep?";
        if (stepId === null)
            throw new Error("The parameter 'stepId' cannot be null.");
        else if (stepId !== undefined)
            url_ += "stepId=" + encodeURIComponent("" + stepId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteStep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteStep(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteStep(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param stepId (optional) 
     * @param updateSeq (optional) 
     * @return Success
     */
    saveChangeStepPosition(stepId: number | undefined, updateSeq: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/SaveChangeStepPosition?";
        if (stepId === null)
            throw new Error("The parameter 'stepId' cannot be null.");
        else if (stepId !== undefined)
            url_ += "stepId=" + encodeURIComponent("" + stepId) + "&";
        if (updateSeq === null)
            throw new Error("The parameter 'updateSeq' cannot be null.");
        else if (updateSeq !== undefined)
            url_ += "updateSeq=" + encodeURIComponent("" + updateSeq) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveChangeStepPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveChangeStepPosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveChangeStepPosition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param processTypeCode (optional) 
     * @param body (optional) 
     * @return Success
     */
    checkRequestNextMultipleApprovalTree(processTypeCode: string | null | undefined, body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/CheckRequestNextMultipleApprovalTree?";
        if (processTypeCode !== undefined && processTypeCode !== null)
            url_ += "processTypeCode=" + encodeURIComponent("" + processTypeCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckRequestNextMultipleApprovalTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckRequestNextMultipleApprovalTree(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCheckRequestNextMultipleApprovalTree(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param userId (optional) 
     * @param processTypeCode (optional) 
     * @param dayOfProcess (optional) 
     * @param body (optional) 
     * @return Success
     */
    addNewStepToTreeForMulltipleHeader(userId: number | undefined, processTypeCode: string | null | undefined, dayOfProcess: number | undefined, body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/AddNewStepToTreeForMulltipleHeader?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (processTypeCode !== undefined && processTypeCode !== null)
            url_ += "processTypeCode=" + encodeURIComponent("" + processTypeCode) + "&";
        if (dayOfProcess === null)
            throw new Error("The parameter 'dayOfProcess' cannot be null.");
        else if (dayOfProcess !== undefined)
            url_ += "dayOfProcess=" + encodeURIComponent("" + dayOfProcess) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewStepToTreeForMulltipleHeader(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewStepToTreeForMulltipleHeader(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddNewStepToTreeForMulltipleHeader(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param firstSeq (optional) 
     * @param updateSeq (optional) 
     * @param processTypeCode (optional) 
     * @param body (optional) 
     * @return Success
     */
    saveChangeStepPositionForMulltipleHeader(firstSeq: number | undefined, updateSeq: number | undefined, processTypeCode: string | null | undefined, body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/SaveChangeStepPositionForMulltipleHeader?";
        if (firstSeq === null)
            throw new Error("The parameter 'firstSeq' cannot be null.");
        else if (firstSeq !== undefined)
            url_ += "firstSeq=" + encodeURIComponent("" + firstSeq) + "&";
        if (updateSeq === null)
            throw new Error("The parameter 'updateSeq' cannot be null.");
        else if (updateSeq !== undefined)
            url_ += "updateSeq=" + encodeURIComponent("" + updateSeq) + "&";
        if (processTypeCode !== undefined && processTypeCode !== null)
            url_ += "processTypeCode=" + encodeURIComponent("" + processTypeCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveChangeStepPositionForMulltipleHeader(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveChangeStepPositionForMulltipleHeader(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveChangeStepPositionForMulltipleHeader(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param processTypeCode (optional) 
     * @param body (optional) 
     * @return Success
     */
    sentRequestForMultipleHeader(processTypeCode: string | null | undefined, body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/SentRequestForMultipleHeader?";
        if (processTypeCode !== undefined && processTypeCode !== null)
            url_ += "processTypeCode=" + encodeURIComponent("" + processTypeCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSentRequestForMultipleHeader(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSentRequestForMultipleHeader(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSentRequestForMultipleHeader(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param note (optional) 
     * @param skipSeq (optional) 
     * @param processTypeCode (optional) 
     * @param body (optional) 
     * @return Success
     */
    skipStepForMultipleHeader(note: string | null | undefined, skipSeq: number | undefined, processTypeCode: string | null | undefined, body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/SkipStepForMultipleHeader?";
        if (note !== undefined && note !== null)
            url_ += "note=" + encodeURIComponent("" + note) + "&";
        if (skipSeq === null)
            throw new Error("The parameter 'skipSeq' cannot be null.");
        else if (skipSeq !== undefined)
            url_ += "skipSeq=" + encodeURIComponent("" + skipSeq) + "&";
        if (processTypeCode !== undefined && processTypeCode !== null)
            url_ += "processTypeCode=" + encodeURIComponent("" + processTypeCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSkipStepForMultipleHeader(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSkipStepForMultipleHeader(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSkipStepForMultipleHeader(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param skipSeq (optional) 
     * @param processTypeCode (optional) 
     * @param reqIds (optional) 
     * @return Success
     */
    deleteStepForMultipleHeader(skipSeq: number | undefined, processTypeCode: string | null | undefined, reqIds: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/DeleteStepForMultipleHeader?";
        if (skipSeq === null)
            throw new Error("The parameter 'skipSeq' cannot be null.");
        else if (skipSeq !== undefined)
            url_ += "skipSeq=" + encodeURIComponent("" + skipSeq) + "&";
        if (processTypeCode !== undefined && processTypeCode !== null)
            url_ += "processTypeCode=" + encodeURIComponent("" + processTypeCode) + "&";
        if (reqIds !== undefined && reqIds !== null)
            reqIds && reqIds.forEach(item => { url_ += "reqIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteStepForMultipleHeader(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteStepForMultipleHeader(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteStepForMultipleHeader(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param skipSeq (optional) 
     * @param newUserId (optional) 
     * @param note (optional) 
     * @param processTypeCode (optional) 
     * @param body (optional) 
     * @return Success
     */
    skipAndForwardForMultipleHeader(skipSeq: number | undefined, newUserId: number | undefined, note: string | null | undefined, processTypeCode: string | null | undefined, body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/SkipAndForwardForMultipleHeader?";
        if (skipSeq === null)
            throw new Error("The parameter 'skipSeq' cannot be null.");
        else if (skipSeq !== undefined)
            url_ += "skipSeq=" + encodeURIComponent("" + skipSeq) + "&";
        if (newUserId === null)
            throw new Error("The parameter 'newUserId' cannot be null.");
        else if (newUserId !== undefined)
            url_ += "newUserId=" + encodeURIComponent("" + newUserId) + "&";
        if (note !== undefined && note !== null)
            url_ += "note=" + encodeURIComponent("" + note) + "&";
        if (processTypeCode !== undefined && processTypeCode !== null)
            url_ += "processTypeCode=" + encodeURIComponent("" + processTypeCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSkipAndForwardForMultipleHeader(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSkipAndForwardForMultipleHeader(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSkipAndForwardForMultipleHeader(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveOrRejectMUltipleHeader(body: ApproveOrRejectInputDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/ApproveOrRejectMUltipleHeader";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveOrRejectMUltipleHeader(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveOrRejectMUltipleHeader(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processApproveOrRejectMUltipleHeader(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param processTypeCode (optional) 
     * @param reqId (optional) 
     * @param userId (optional) 
     * @return Success
     */
    assignJobToOtherBuyer(processTypeCode: string | null | undefined, reqId: number | undefined, userId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/AssignJobToOtherBuyer?";
        if (processTypeCode !== undefined && processTypeCode !== null)
            url_ += "processTypeCode=" + encodeURIComponent("" + processTypeCode) + "&";
        if (reqId === null)
            throw new Error("The parameter 'reqId' cannot be null.");
        else if (reqId !== undefined)
            url_ += "reqId=" + encodeURIComponent("" + reqId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignJobToOtherBuyer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignJobToOtherBuyer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssignJobToOtherBuyer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param filterText (optional) 
     * @return Success
     */
    getAllBuyerInfo(filterText: string | null | undefined): Observable<GetEmployeesDto[]> {
        let url_ = this.baseUrl + "/api/services/app/RequestApprovalTree/GetAllBuyerInfo?";
        if (filterText !== undefined && filterText !== null)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBuyerInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBuyerInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEmployeesDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEmployeesDto[]>;
        }));
    }

    protected processGetAllBuyerInfo(response: HttpResponseBase): Observable<GetEmployeesDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetEmployeesDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEmployeesDto[]>(null as any);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getRoles(body: GetRolesInput | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfRoleListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfRoleListDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfRoleListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleListDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRoleForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRoleForEditOutput>;
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateRole(body: CreateOrUpdateRoleInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/CreateOrUpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteRole(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/DeleteRole?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class SegmentExcelServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkSaveAllImport(body: SegmentReadDataDto[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SegmentExcel/CheckSaveAllImport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckSaveAllImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckSaveAllImport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckSaveAllImport(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param segNum (optional) 
     * @return Success
     */
    exportTemplate(segNum: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SegmentExcel/ExportTemplate?";
        if (segNum === null)
            throw new Error("The parameter 'segNum' cannot be null.");
        else if (segNum !== undefined)
            url_ += "segNum=" + encodeURIComponent("" + segNum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processExportTemplate(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }

    /**
     * @param fileBytes (optional) 
     * @param fileName (optional) 
     * @param segNum (optional) 
     * @return Success
     */
    getListSegmentFromExcel(fileBytes: string | null | undefined, fileName: string | null | undefined, segNum: string | null | undefined): Observable<SegmentReadDataDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SegmentExcel/GetListSegmentFromExcel?";
        if (fileBytes !== undefined && fileBytes !== null)
            url_ += "fileBytes=" + encodeURIComponent("" + fileBytes) + "&";
        if (fileName !== undefined && fileName !== null)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (segNum !== undefined && segNum !== null)
            url_ += "segNum=" + encodeURIComponent("" + segNum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListSegmentFromExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListSegmentFromExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SegmentReadDataDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SegmentReadDataDto[]>;
        }));
    }

    protected processGetListSegmentFromExcel(response: HttpResponseBase): Observable<SegmentReadDataDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SegmentReadDataDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SegmentReadDataDto[]>(null as any);
    }
}

@Injectable()
export class SendEmailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendMailForDelayPayment(body: DelayPaymentEmailContent | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SendEmail/SendMailForDelayPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMailForDelayPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMailForDelayPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendMailForDelayPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param poNumber (optional) 
     * @param body (optional) 
     * @return Success
     */
    sendEmailPoToSupplier(poNumber: string | null | undefined, body: SendEmailContent | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SendEmail/sendEmailPoToSupplier?";
        if (poNumber !== undefined && poNumber !== null)
            url_ += "poNumber=" + encodeURIComponent("" + poNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailPoToSupplier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailPoToSupplier(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendEmailPoToSupplier(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendEmail(body: SendEmailContent | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SendEmail/SendEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class SendMailServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendMail(body: MailContent | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SendMailService/SendMail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendMail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCurrentLoginInformationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCurrentLoginInformationsOutput>;
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(null as any);
    }

    /**
     * @return Success
     */
    updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/UpdateUserSignInToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserSignInToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignInToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateUserSignInTokenOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateUserSignInTokenOutput>;
        }));
    }

    protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateUserSignInTokenOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateUserSignInTokenOutput>(null as any);
    }
}

@Injectable()
export class StripePaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<StripeConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StripeConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StripeConfigurationDto>;
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<StripeConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StripeConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StripeConfigurationDto>(null as any);
    }

    /**
     * @param stripeSessionId (optional) 
     * @return Success
     */
    getPayment(stripeSessionId: string | null | undefined): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetPayment?";
        if (stripeSessionId !== undefined && stripeSessionId !== null)
            url_ += "StripeSessionId=" + encodeURIComponent("" + stripeSessionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPaymentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPaymentDto>;
        }));
    }

    protected processGetPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPaymentSession(body: StripeCreatePaymentSessionInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/CreatePaymentSession";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePaymentSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePaymentSession(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreatePaymentSession(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    getPaymentResult(paymentId: number | undefined): Observable<StripePaymentResultOutput> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetPaymentResult?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "PaymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StripePaymentResultOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StripePaymentResultOutput>;
        }));
    }

    protected processGetPaymentResult(response: HttpResponseBase): Observable<StripePaymentResultOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StripePaymentResultOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StripePaymentResultOutput>(null as any);
    }
}

@Injectable()
export class SubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    disableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/DisableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableRecurringPayments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDisableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    enableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/EnableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnableRecurringPayments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEnableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param subscriptionEndDateStart (optional) 
     * @param subscriptionEndDateEnd (optional) 
     * @param creationDateStart (optional) 
     * @param creationDateEnd (optional) 
     * @param editionId (optional) 
     * @param editionIdSpecified (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTenants(filter: string | null | undefined, subscriptionEndDateStart: DateTime | null | undefined, subscriptionEndDateEnd: DateTime | null | undefined, creationDateStart: DateTime | null | undefined, creationDateEnd: DateTime | null | undefined, editionId: number | null | undefined, editionIdSpecified: boolean | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTenantListDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenants?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (subscriptionEndDateStart !== undefined && subscriptionEndDateStart !== null)
            url_ += "SubscriptionEndDateStart=" + encodeURIComponent(subscriptionEndDateStart ? "" + subscriptionEndDateStart.toString() : "") + "&";
        if (subscriptionEndDateEnd !== undefined && subscriptionEndDateEnd !== null)
            url_ += "SubscriptionEndDateEnd=" + encodeURIComponent(subscriptionEndDateEnd ? "" + subscriptionEndDateEnd.toString() : "") + "&";
        if (creationDateStart !== undefined && creationDateStart !== null)
            url_ += "CreationDateStart=" + encodeURIComponent(creationDateStart ? "" + creationDateStart.toString() : "") + "&";
        if (creationDateEnd !== undefined && creationDateEnd !== null)
            url_ += "CreationDateEnd=" + encodeURIComponent(creationDateEnd ? "" + creationDateEnd.toString() : "") + "&";
        if (editionId !== undefined && editionId !== null)
            url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&";
        if (editionIdSpecified === null)
            throw new Error("The parameter 'editionIdSpecified' cannot be null.");
        else if (editionIdSpecified !== undefined)
            url_ += "EditionIdSpecified=" + encodeURIComponent("" + editionIdSpecified) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTenantListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTenantListDto>;
        }));
    }

    protected processGetTenants(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTenantListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTenant(body: CreateTenantInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/CreateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantForEdit(id: number | undefined): Observable<TenantEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantEditDto>;
        }));
    }

    protected processGetTenantForEdit(response: HttpResponseBase): Observable<TenantEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTenant(body: TenantEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTenant(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/DeleteTenant?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantFeaturesForEdit(id: number | undefined): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantFeaturesForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantFeaturesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantFeaturesForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTenantFeaturesEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTenantFeaturesEditOutput>;
        }));
    }

    protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTenantFeaturesEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTenantFeaturesEditOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTenantFeatures(body: UpdateTenantFeaturesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantFeatures(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetTenantSpecificFeatures(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/ResetTenantSpecificFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTenantSpecificFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenantSpecificFeatures(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlockTenantAdmin(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UnlockTenantAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockTenantAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockTenantAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnlockTenantAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TenantDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMemberActivity(): Observable<GetMemberActivityOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetMemberActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberActivity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMemberActivityOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMemberActivityOutput>;
        }));
    }

    protected processGetMemberActivity(response: HttpResponseBase): Observable<GetMemberActivityOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMemberActivityOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemberActivityOutput>(null as any);
    }

    /**
     * @return Success
     */
    getDashboardData(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetDashboardDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDashboardData?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDashboardDataOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDashboardDataOutput>;
        }));
    }

    protected processGetDashboardData(response: HttpResponseBase): Observable<GetDashboardDataOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDashboardDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDashboardDataOutput>(null as any);
    }

    /**
     * @return Success
     */
    getTopStats(): Observable<GetTopStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetTopStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTopStatsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTopStatsOutput>;
        }));
    }

    protected processGetTopStats(response: HttpResponseBase): Observable<GetTopStatsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTopStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTopStatsOutput>(null as any);
    }

    /**
     * @return Success
     */
    getProfitShare(): Observable<GetProfitShareOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetProfitShare";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfitShare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfitShare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfitShareOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfitShareOutput>;
        }));
    }

    protected processGetProfitShare(response: HttpResponseBase): Observable<GetProfitShareOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfitShareOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfitShareOutput>(null as any);
    }

    /**
     * @return Success
     */
    getDailySales(): Observable<GetDailySalesOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDailySales";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDailySales(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDailySales(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDailySalesOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDailySalesOutput>;
        }));
    }

    protected processGetDailySales(response: HttpResponseBase): Observable<GetDailySalesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDailySalesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDailySalesOutput>(null as any);
    }

    /**
     * @return Success
     */
    getSalesSummary(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetSalesSummaryOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetSalesSummary?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSalesSummaryOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSalesSummaryOutput>;
        }));
    }

    protected processGetSalesSummary(response: HttpResponseBase): Observable<GetSalesSummaryOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSalesSummaryOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSalesSummaryOutput>(null as any);
    }

    /**
     * @return Success
     */
    getRegionalStats(): Observable<GetRegionalStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetRegionalStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegionalStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegionalStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRegionalStatsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRegionalStatsOutput>;
        }));
    }

    protected processGetRegionalStats(response: HttpResponseBase): Observable<GetRegionalStatsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRegionalStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRegionalStatsOutput>(null as any);
    }

    /**
     * @return Success
     */
    getGeneralStats(): Observable<GetGeneralStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetGeneralStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetGeneralStatsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetGeneralStatsOutput>;
        }));
    }

    protected processGetGeneralStats(response: HttpResponseBase): Observable<GetGeneralStatsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGeneralStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGeneralStatsOutput>(null as any);
    }
}

@Injectable()
export class TenantRegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerTenant(body: RegisterTenantInput | undefined): Observable<RegisterTenantOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterTenantOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterTenantOutput>;
        }));
    }

    protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterTenantOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterTenantOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterTenantOutput>(null as any);
    }

    /**
     * @return Success
     */
    getEditionsForSelect(): Observable<EditionsSelectOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEditionsForSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EditionsSelectOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EditionsSelectOutput>;
        }));
    }

    protected processGetEditionsForSelect(response: HttpResponseBase): Observable<EditionsSelectOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EditionsSelectOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionsSelectOutput>(null as any);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getEdition(editionId: number | undefined): Observable<EditionSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEdition?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EditionSelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EditionSelectDto>;
        }));
    }

    protected processGetEdition(response: HttpResponseBase): Observable<EditionSelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EditionSelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionSelectDto>(null as any);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<TenantSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantSettingsEditDto>;
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSettingsEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllSettings(body: TenantSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    clearLogo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearLogo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    clearCustomCss(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearCustomCss";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomCss(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomCss(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearCustomCss(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getEnabledSocialLoginSettings(): Observable<ExternalLoginSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetEnabledSocialLoginSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnabledSocialLoginSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnabledSocialLoginSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalLoginSettingsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalLoginSettingsDto>;
        }));
    }

    protected processGetEnabledSocialLoginSettings(response: HttpResponseBase): Observable<ExternalLoginSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalLoginSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginSettingsDto>(null as any);
    }
}

@Injectable()
export class TimingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTimezones(defaultTimezoneScope: SettingScopes): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezones?";
        if (defaultTimezoneScope === undefined || defaultTimezoneScope === null)
            throw new Error("The parameter 'defaultTimezoneScope' must be defined and cannot be null.");
        else
            url_ += "DefaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezones(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfNameValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfNameValueDto>;
        }));
    }

    protected processGetTimezones(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfNameValueDto>(null as any);
    }

    /**
     * @param selectedTimezoneId (optional) 
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string | null | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezoneComboboxItems?";
        if (selectedTimezoneId !== undefined && selectedTimezoneId !== null)
            url_ += "SelectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezoneComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezoneComboboxItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboboxItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboboxItemDto[]>;
        }));
    }

    protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboboxItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboboxItemDto[]>(null as any);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(null as any);
    }

    /**
     * @param refreshToken (optional) 
     * @return Success
     */
    refreshToken(refreshToken: string | null | undefined): Observable<RefreshTokenResult> {
        let url_ = this.baseUrl + "/api/TokenAuth/RefreshToken?";
        if (refreshToken !== undefined && refreshToken !== null)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RefreshTokenResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RefreshTokenResult>;
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<RefreshTokenResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RefreshTokenResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RefreshTokenResult>(null as any);
    }

    /**
     * @return Success
     */
    logOut(): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/LogOut";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogOut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLogOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTwoFactorAuthCode(body: SendTwoFactorAuthCodeModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/SendTwoFactorAuthCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTwoFactorAuthCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTwoFactorAuthCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendTwoFactorAuthCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param impersonationToken (optional) 
     * @return Success
     */
    impersonatedAuthenticate(impersonationToken: string | null | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ImpersonatedAuthenticate?";
        if (impersonationToken !== undefined && impersonationToken !== null)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonatedAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonatedAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonatedAuthenticateResultModel>;
        }));
    }

    protected processImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonatedAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonatedAuthenticateResultModel>(null as any);
    }

    /**
     * @param userDelegationId (optional) 
     * @param impersonationToken (optional) 
     * @return Success
     */
    delegatedImpersonatedAuthenticate(userDelegationId: number | undefined, impersonationToken: string | null | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/DelegatedImpersonatedAuthenticate?";
        if (userDelegationId === null)
            throw new Error("The parameter 'userDelegationId' cannot be null.");
        else if (userDelegationId !== undefined)
            url_ += "userDelegationId=" + encodeURIComponent("" + userDelegationId) + "&";
        if (impersonationToken !== undefined && impersonationToken !== null)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelegatedImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelegatedImpersonatedAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonatedAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonatedAuthenticateResultModel>;
        }));
    }

    protected processDelegatedImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonatedAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonatedAuthenticateResultModel>(null as any);
    }

    /**
     * @param switchAccountToken (optional) 
     * @return Success
     */
    linkedAccountAuthenticate(switchAccountToken: string | null | undefined): Observable<SwitchedAccountAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/LinkedAccountAuthenticate?";
        if (switchAccountToken !== undefined && switchAccountToken !== null)
            url_ += "switchAccountToken=" + encodeURIComponent("" + switchAccountToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkedAccountAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkedAccountAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwitchedAccountAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwitchedAccountAuthenticateResultModel>;
        }));
    }

    protected processLinkedAccountAuthenticate(response: HttpResponseBase): Observable<SwitchedAccountAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SwitchedAccountAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchedAccountAuthenticateResultModel>(null as any);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalLoginProviderInfoModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalLoginProviderInfoModel[]>;
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalAuthenticateResultModel>;
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(null as any);
    }

    /**
     * @param message (optional) 
     * @param severity (optional) 
     * @return Success
     */
    testNotification(message: string | null | undefined, severity: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/TestNotification?";
        if (message !== undefined && message !== null)
            url_ += "message=" + encodeURIComponent("" + message) + "&";
        if (severity !== undefined && severity !== null)
            url_ += "severity=" + encodeURIComponent("" + severity) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTestNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TwitterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRequestToken(): Observable<TwitterGetRequestTokenResponse> {
        let url_ = this.baseUrl + "/api/Twitter/GetRequestToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TwitterGetRequestTokenResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TwitterGetRequestTokenResponse>;
        }));
    }

    protected processGetRequestToken(response: HttpResponseBase): Observable<TwitterGetRequestTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TwitterGetRequestTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TwitterGetRequestTokenResponse>(null as any);
    }

    /**
     * @param token (optional) 
     * @param verifier (optional) 
     * @return Success
     */
    getAccessToken(token: string | null | undefined, verifier: string | null | undefined): Observable<TwitterGetAccessTokenResponse> {
        let url_ = this.baseUrl + "/api/Twitter/GetAccessToken?";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        if (verifier !== undefined && verifier !== null)
            url_ += "verifier=" + encodeURIComponent("" + verifier) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccessToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccessToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TwitterGetAccessTokenResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TwitterGetAccessTokenResponse>;
        }));
    }

    protected processGetAccessToken(response: HttpResponseBase): Observable<TwitterGetAccessTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TwitterGetAccessTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TwitterGetAccessTokenResponse>(null as any);
    }
}

@Injectable()
export class UiCustomizationSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUiManagementSettings(): Observable<ThemeSettingsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/GetUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUiManagementSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ThemeSettingsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ThemeSettingsDto[]>;
        }));
    }

    protected processGetUiManagementSettings(response: HttpResponseBase): Observable<ThemeSettingsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ThemeSettingsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThemeSettingsDto[]>(null as any);
    }

    /**
     * @param themeName (optional) 
     * @return Success
     */
    changeThemeWithDefaultValues(themeName: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/ChangeThemeWithDefaultValues?";
        if (themeName !== undefined && themeName !== null)
            url_ += "themeName=" + encodeURIComponent("" + themeName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeThemeWithDefaultValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeThemeWithDefaultValues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeThemeWithDefaultValues(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUiManagementSettings(body: ThemeSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUiManagementSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDefaultUiManagementSettings(body: ThemeSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateDefaultUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDefaultUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDefaultUiManagementSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateDefaultUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    useSystemDefaultSettings(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UseSystemDefaultSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUseSystemDefaultSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUseSystemDefaultSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUseSystemDefaultSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class UrBuyFromCatalogRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param productName (optional) 
     * @param supplierName (optional) 
     * @param inventoryGroupId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCatalogProducts(productName: string | null | undefined, supplierName: string | null | undefined, inventoryGroupId: number | null | undefined, sorting: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetAllCatalogProductForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/UrBuyFromCatalogRequest/GetAllCatalogProducts?";
        if (productName !== undefined && productName !== null)
            url_ += "ProductName=" + encodeURIComponent("" + productName) + "&";
        if (supplierName !== undefined && supplierName !== null)
            url_ += "SupplierName=" + encodeURIComponent("" + supplierName) + "&";
        if (inventoryGroupId !== undefined && inventoryGroupId !== null)
            url_ += "InventoryGroupId=" + encodeURIComponent("" + inventoryGroupId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCatalogProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCatalogProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAllCatalogProductForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAllCatalogProductForViewDto>;
        }));
    }

    protected processGetAllCatalogProducts(response: HttpResponseBase): Observable<PagedResultDtoOfGetAllCatalogProductForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAllCatalogProductForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAllCatalogProductForViewDto>(null as any);
    }

    /**
     * @return Success
     */
    getFullDirectory(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/UrBuyFromCatalogRequest/GetFullDirectory";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFullDirectory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFullDirectory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetFullDirectory(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createBuyRequest(body: CreateBuyRequestFromCatalogDto[] | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/UrBuyFromCatalogRequest/CreateBuyRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBuyRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBuyRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateBuyRequest(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class UrUserRequestManagementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param uRNumber (optional) 
     * @param inventoryGroupId (optional) 
     * @param status (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param picUserId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllUserRequests(uRNumber: string | null | undefined, inventoryGroupId: number | null | undefined, status: string | null | undefined, fromDate: DateTime | null | undefined, toDate: DateTime | null | undefined, picUserId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetAllUserRequestForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/UrUserRequestManagement/GetAllUserRequests?";
        if (uRNumber !== undefined && uRNumber !== null)
            url_ += "URNumber=" + encodeURIComponent("" + uRNumber) + "&";
        if (inventoryGroupId !== undefined && inventoryGroupId !== null)
            url_ += "InventoryGroupId=" + encodeURIComponent("" + inventoryGroupId) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toString() : "") + "&";
        if (picUserId !== undefined && picUserId !== null)
            url_ += "PicUserId=" + encodeURIComponent("" + picUserId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserRequests(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAllUserRequestForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAllUserRequestForViewDto>;
        }));
    }

    protected processGetAllUserRequests(response: HttpResponseBase): Observable<PagedResultDtoOfGetAllUserRequestForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAllUserRequestForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAllUserRequestForViewDto>(null as any);
    }

    /**
     * @param inventoryGroupId (optional) 
     * @param productCode (optional) 
     * @param currencyId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllProducts(inventoryGroupId: number | null | undefined, productCode: string | null | undefined, currencyId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetAllProductsForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/UrUserRequestManagement/GetAllProducts?";
        if (inventoryGroupId !== undefined && inventoryGroupId !== null)
            url_ += "InventoryGroupId=" + encodeURIComponent("" + inventoryGroupId) + "&";
        if (productCode !== undefined && productCode !== null)
            url_ += "ProductCode=" + encodeURIComponent("" + productCode) + "&";
        if (currencyId !== undefined && currencyId !== null)
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAllProductsForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAllProductsForViewDto>;
        }));
    }

    protected processGetAllProducts(response: HttpResponseBase): Observable<PagedResultDtoOfGetAllProductsForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAllProductsForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAllProductsForViewDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUrDetail(id: number | undefined): Observable<GetUserRequestDetailForView> {
        let url_ = this.baseUrl + "/api/services/app/UrUserRequestManagement/GetUrDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUrDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUrDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserRequestDetailForView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserRequestDetailForView>;
        }));
    }

    protected processGetUrDetail(response: HttpResponseBase): Observable<GetUserRequestDetailForView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserRequestDetailForView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserRequestDetailForView>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UrUserRequestManagement/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEditUserRequest(body: CreateOrEditUserRequestInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/UrUserRequestManagement/CreateOrEditUserRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditUserRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditUserRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateOrEditUserRequest(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getRequesterInfo(userId: number | undefined): Observable<GetRequesterInfoForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/UrUserRequestManagement/GetRequesterInfo?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequesterInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequesterInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRequesterInfoForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRequesterInfoForViewDto>;
        }));
    }

    protected processGetRequesterInfo(response: HttpResponseBase): Observable<GetRequesterInfoForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRequesterInfoForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRequesterInfoForViewDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkValidateData(body: UserRequestExcelDataDto | undefined): Observable<UserRequestExcelDataDto> {
        let url_ = this.baseUrl + "/api/services/app/UrUserRequestManagement/CheckValidateData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckValidateData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckValidateData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRequestExcelDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRequestExcelDataDto>;
        }));
    }

    protected processCheckValidateData(response: HttpResponseBase): Observable<UserRequestExcelDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRequestExcelDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRequestExcelDataDto>(null as any);
    }

    /**
     * @return Success
     */
    exportUserRequestTempalte(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/UrUserRequestManagement/ExportUserRequestTempalte";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportUserRequestTempalte(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportUserRequestTempalte(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processExportUserRequestTempalte(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }

    /**
     * @param userRequestNumber (optional) 
     * @param preparerId (optional) 
     * @param buyerId (optional) 
     * @param supplierId (optional) 
     * @param supplierSiteId (optional) 
     * @param documentTypeId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllUserRequestForPr(userRequestNumber: string | null | undefined, preparerId: number | null | undefined, buyerId: number | null | undefined, supplierId: number | null | undefined, supplierSiteId: number | null | undefined, documentTypeId: number | null | undefined, fromDate: DateTime | null | undefined, toDate: DateTime | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetAllUserRequestForPrDto> {
        let url_ = this.baseUrl + "/api/services/app/UrUserRequestManagement/GetAllUserRequestForPr?";
        if (userRequestNumber !== undefined && userRequestNumber !== null)
            url_ += "UserRequestNumber=" + encodeURIComponent("" + userRequestNumber) + "&";
        if (preparerId !== undefined && preparerId !== null)
            url_ += "PreparerId=" + encodeURIComponent("" + preparerId) + "&";
        if (buyerId !== undefined && buyerId !== null)
            url_ += "BuyerId=" + encodeURIComponent("" + buyerId) + "&";
        if (supplierId !== undefined && supplierId !== null)
            url_ += "SupplierId=" + encodeURIComponent("" + supplierId) + "&";
        if (supplierSiteId !== undefined && supplierSiteId !== null)
            url_ += "SupplierSiteId=" + encodeURIComponent("" + supplierSiteId) + "&";
        if (documentTypeId !== undefined && documentTypeId !== null)
            url_ += "DocumentTypeId=" + encodeURIComponent("" + documentTypeId) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toString() : "") + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserRequestForPr(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserRequestForPr(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAllUserRequestForPrDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAllUserRequestForPrDto>;
        }));
    }

    protected processGetAllUserRequestForPr(response: HttpResponseBase): Observable<PagedResultDtoOfGetAllUserRequestForPrDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAllUserRequestForPrDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAllUserRequestForPrDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createUserRequestFromExcel(body: CreateUserRequestFromExcelInput[] | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/UrUserRequestManagement/CreateUserRequestFromExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUserRequestFromExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUserRequestFromExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateUserRequestFromExcel(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param reqId (optional) 
     * @param processType (optional) 
     * @return Success
     */
    getAllApprovalInfo(reqId: number | undefined, processType: string | null | undefined): Observable<GetAllApprovalInfoForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UrUserRequestManagement/GetAllApprovalInfo?";
        if (reqId === null)
            throw new Error("The parameter 'reqId' cannot be null.");
        else if (reqId !== undefined)
            url_ += "reqId=" + encodeURIComponent("" + reqId) + "&";
        if (processType !== undefined && processType !== null)
            url_ += "processType=" + encodeURIComponent("" + processType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllApprovalInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllApprovalInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllApprovalInfoForViewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllApprovalInfoForViewDto[]>;
        }));
    }

    protected processGetAllApprovalInfo(response: HttpResponseBase): Observable<GetAllApprovalInfoForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAllApprovalInfoForViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllApprovalInfoForViewDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportUserRequestToExcel(body: ExportUserRequestToExcelInput | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/UrUserRequestManagement/ExportUserRequestToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportUserRequestToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportUserRequestToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processExportUserRequestToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }

    /**
     * @param supplierFilter (optional) 
     * @return Success
     */
    getAllSuppliers(supplierFilter: string | null | undefined): Observable<CommonAllSupplier[]> {
        let url_ = this.baseUrl + "/api/services/app/UrUserRequestManagement/GetAllSuppliers?";
        if (supplierFilter !== undefined && supplierFilter !== null)
            url_ += "supplierFilter=" + encodeURIComponent("" + supplierFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSuppliers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSuppliers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonAllSupplier[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonAllSupplier[]>;
        }));
    }

    protected processGetAllSuppliers(response: HttpResponseBase): Observable<CommonAllSupplier[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonAllSupplier.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonAllSupplier[]>(null as any);
    }

    /**
     * @param reqId (optional) 
     * @param referenceType (optional) 
     * @return Success
     */
    getAllReferenceInfo(reqId: number | undefined, referenceType: string | null | undefined): Observable<GetAllReferenceInfoForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UrUserRequestManagement/GetAllReferenceInfo?";
        if (reqId === null)
            throw new Error("The parameter 'reqId' cannot be null.");
        else if (reqId !== undefined)
            url_ += "ReqId=" + encodeURIComponent("" + reqId) + "&";
        if (referenceType !== undefined && referenceType !== null)
            url_ += "ReferenceType=" + encodeURIComponent("" + referenceType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllReferenceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllReferenceInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllReferenceInfoForViewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllReferenceInfoForViewDto[]>;
        }));
    }

    protected processGetAllReferenceInfo(response: HttpResponseBase): Observable<GetAllReferenceInfoForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAllReferenceInfoForViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllReferenceInfoForViewDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllUserForCombobox(): Observable<GetAllUserForComboboxDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UrUserRequestManagement/GetAllUserForCombobox";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForCombobox(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllUserForComboboxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllUserForComboboxDto[]>;
        }));
    }

    protected processGetAllUserForCombobox(response: HttpResponseBase): Observable<GetAllUserForComboboxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAllUserForComboboxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllUserForComboboxDto[]>(null as any);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getUserById(userId: number | null | undefined): Observable<User> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserById?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processGetUserById(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getUsers(body: GetUsersInput | undefined): Observable<PagedResultDtoOfUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfUserListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfUserListDto>;
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserListDto>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param permissions (optional) 
     * @param role (optional) 
     * @param onlyLockedUsers (optional) 
     * @param sorting (optional) 
     * @param name (optional) 
     * @return Success
     */
    getUsersToExcel(filter: string | null | undefined, permissions: string[] | null | undefined, role: number | null | undefined, onlyLockedUsers: boolean | undefined, sorting: string | null | undefined, name: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsersToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (permissions !== undefined && permissions !== null)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        if (role !== undefined && role !== null)
            url_ += "Role=" + encodeURIComponent("" + role) + "&";
        if (onlyLockedUsers === null)
            throw new Error("The parameter 'onlyLockedUsers' cannot be null.");
        else if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetUsersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserForEdit(id: number | null | undefined): Observable<GetUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserForEditOutput>;
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserForEditOutput>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserPermissionsForEdit(id: number | undefined): Observable<GetUserPermissionsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserPermissionsForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissionsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissionsForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserPermissionsForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserPermissionsForEditOutput>;
        }));
    }

    protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserPermissionsForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserPermissionsForEditOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetUserSpecificPermissions(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetUserSpecificPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetUserSpecificPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetUserSpecificPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetUserSpecificPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserPermissions(body: UpdateUserPermissionsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUserPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateUser(body: CreateOrUpdateUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/CreateOrUpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteUser(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeleteUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlockUser(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UnlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class UserDelegationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getDelegatedUsers(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfUserDelegationDto> {
        let url_ = this.baseUrl + "/api/services/app/UserDelegation/GetDelegatedUsers?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDelegatedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDelegatedUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfUserDelegationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfUserDelegationDto>;
        }));
    }

    protected processGetDelegatedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserDelegationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserDelegationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserDelegationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delegateNewUser(body: CreateUserDelegationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDelegation/DelegateNewUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelegateNewUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelegateNewUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelegateNewUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeDelegation(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDelegation/RemoveDelegation?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveDelegation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveDelegation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveDelegation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getActiveUserDelegations(): Observable<UserDelegationDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UserDelegation/GetActiveUserDelegations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveUserDelegations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveUserDelegations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDelegationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDelegationDto[]>;
        }));
    }

    protected processGetActiveUserDelegations(response: HttpResponseBase): Observable<UserDelegationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDelegationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDelegationDto[]>(null as any);
    }
}

@Injectable()
export class UserLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    linkToUser(body: LinkToUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/LinkToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkToUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLinkToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getLinkedUsers(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetLinkedUsers?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkedUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfLinkedUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfLinkedUserDto>;
        }));
    }

    protected processGetLinkedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLinkedUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLinkedUserDto>(null as any);
    }

    /**
     * @return Success
     */
    getRecentlyUsedLinkedUsers(): Observable<ListResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetRecentlyUsedLinkedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyUsedLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyUsedLinkedUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfLinkedUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfLinkedUserDto>;
        }));
    }

    protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<ListResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfLinkedUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfLinkedUserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlinkUser(body: UnlinkUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/UnlinkUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlinkUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlinkUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class UserLoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRecentUserLoginAttempts(): Observable<ListResultDtoOfUserLoginAttemptDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLogin/GetRecentUserLoginAttempts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentUserLoginAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentUserLoginAttempts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfUserLoginAttemptDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfUserLoginAttemptDto>;
        }));
    }

    protected processGetRecentUserLoginAttempts(response: HttpResponseBase): Observable<ListResultDtoOfUserLoginAttemptDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfUserLoginAttemptDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfUserLoginAttemptDto>(null as any);
    }
}

@Injectable()
export class WebhookEventServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | null | undefined): Observable<WebhookEvent> {
        let url_ = this.baseUrl + "/api/services/app/WebhookEvent/Get?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WebhookEvent>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WebhookEvent>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WebhookEvent> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebhookEvent.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WebhookEvent>(null as any);
    }
}

@Injectable()
export class WebhookSendAttemptServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param subscriptionId (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllSendAttempts(subscriptionId: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetAllSendAttemptsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSendAttempt/GetAllSendAttempts?";
        if (subscriptionId !== undefined && subscriptionId !== null)
            url_ += "SubscriptionId=" + encodeURIComponent("" + subscriptionId) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSendAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSendAttempts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAllSendAttemptsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAllSendAttemptsOutput>;
        }));
    }

    protected processGetAllSendAttempts(response: HttpResponseBase): Observable<PagedResultDtoOfGetAllSendAttemptsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAllSendAttemptsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAllSendAttemptsOutput>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllSendAttemptsOfWebhookEvent(id: string | null | undefined): Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSendAttempt/GetAllSendAttemptsOfWebhookEvent?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSendAttemptsOfWebhookEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSendAttemptsOfWebhookEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput>;
        }));
    }

    protected processGetAllSendAttemptsOfWebhookEvent(response: HttpResponseBase): Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput>(null as any);
    }

    /**
     * @param sendAttemptId (optional) 
     * @return Success
     */
    resend(sendAttemptId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSendAttempt/Resend?";
        if (sendAttemptId !== undefined && sendAttemptId !== null)
            url_ += "sendAttemptId=" + encodeURIComponent("" + sendAttemptId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResend(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class WebhookSubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    publishTestWebhook(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/PublishTestWebhook";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishTestWebhook(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishTestWebhook(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPublishTestWebhook(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    getAllSubscriptions(): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetAllSubscriptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubscriptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubscriptions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfGetAllSubscriptionsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfGetAllSubscriptionsOutput>;
        }));
    }

    protected processGetAllSubscriptions(response: HttpResponseBase): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllSubscriptionsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfGetAllSubscriptionsOutput>(null as any);
    }

    /**
     * @param subscriptionId (optional) 
     * @return Success
     */
    getSubscription(subscriptionId: string | null | undefined): Observable<WebhookSubscription> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetSubscription?";
        if (subscriptionId !== undefined && subscriptionId !== null)
            url_ += "subscriptionId=" + encodeURIComponent("" + subscriptionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WebhookSubscription>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WebhookSubscription>;
        }));
    }

    protected processGetSubscription(response: HttpResponseBase): Observable<WebhookSubscription> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebhookSubscription.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WebhookSubscription>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addSubscription(body: WebhookSubscription | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/AddSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSubscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSubscription(body: WebhookSubscription | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/UpdateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateWebhookSubscription(body: ActivateWebhookSubscriptionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/ActivateWebhookSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateWebhookSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateWebhookSubscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivateWebhookSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param webhookName (optional) 
     * @return Success
     */
    isSubscribed(webhookName: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/IsSubscribed?";
        if (webhookName !== undefined && webhookName !== null)
            url_ += "webhookName=" + encodeURIComponent("" + webhookName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsSubscribed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsSubscribed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsSubscribed(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param webhookName (optional) 
     * @return Success
     */
    getAllSubscriptionsIfFeaturesGranted(webhookName: string | null | undefined): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetAllSubscriptionsIfFeaturesGranted?";
        if (webhookName !== undefined && webhookName !== null)
            url_ += "webhookName=" + encodeURIComponent("" + webhookName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubscriptionsIfFeaturesGranted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubscriptionsIfFeaturesGranted(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfGetAllSubscriptionsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfGetAllSubscriptionsOutput>;
        }));
    }

    protected processGetAllSubscriptionsIfFeaturesGranted(response: HttpResponseBase): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllSubscriptionsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfGetAllSubscriptionsOutput>(null as any);
    }

    /**
     * @return Success
     */
    getAllAvailableWebhooks(): Observable<ListResultDtoOfGetAllAvailableWebhooksOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetAllAvailableWebhooks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAvailableWebhooks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAvailableWebhooks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfGetAllAvailableWebhooksOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfGetAllAvailableWebhooksOutput>;
        }));
    }

    protected processGetAllAvailableWebhooks(response: HttpResponseBase): Observable<ListResultDtoOfGetAllAvailableWebhooksOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllAvailableWebhooksOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfGetAllAvailableWebhooksOutput>(null as any);
    }
}

@Injectable()
export class WebLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestWebLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetLatestWebLogsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetLatestWebLogsOutput>;
        }));
    }

    protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLatestWebLogsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLatestWebLogsOutput>(null as any);
    }

    /**
     * @return Success
     */
    downloadWebLogs(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWebLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName!: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export enum TenantAvailabilityState {
    Available = 1,
    InActive = 2,
    NotFound = 3,
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state!: TenantAvailabilityState;
    tenantId!: number | undefined;
    serverRootAddress!: string | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.serverRootAddress = _data["serverRootAddress"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["serverRootAddress"] = this.serverRootAddress;
        return data;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
    serverRootAddress: string | undefined;
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
    c!: string | undefined;

    constructor(data?: IResolveTenantIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ResolveTenantIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveTenantIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["c"] = this.c;
        return data;
    }
}

export interface IResolveTenantIdInput {
    c: string | undefined;
}

export class RegisterInput implements IRegisterInput {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    password!: string;
    captchaResponse!: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin!: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
    emailAddress!: string;

    constructor(data?: ISendPasswordResetCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): SendPasswordResetCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface ISendPasswordResetCodeInput {
    emailAddress: string;
}

export class ResetPasswordInput implements IResetPasswordInput {
    userId!: number;
    resetCode!: string | undefined;
    password!: string | undefined;
    returnUrl!: string | undefined;
    singleSignIn!: string | undefined;
    c!: string | undefined;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.resetCode = _data["resetCode"];
            this.password = _data["password"];
            this.returnUrl = _data["returnUrl"];
            this.singleSignIn = _data["singleSignIn"];
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        data["c"] = this.c;
        return data;
    }
}

export interface IResetPasswordInput {
    userId: number;
    resetCode: string | undefined;
    password: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
    c: string | undefined;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin!: boolean;
    userName!: string | undefined;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IResetPasswordOutput {
    canLogin: boolean;
    userName: string | undefined;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
    emailAddress!: string;

    constructor(data?: ISendEmailActivationLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): SendEmailActivationLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailActivationLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface ISendEmailActivationLinkInput {
    emailAddress: string;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId!: number;
    confirmationCode!: string | undefined;
    c!: string | undefined;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.confirmationCode = _data["confirmationCode"];
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        data["c"] = this.c;
        return data;
    }
}

export interface IActivateEmailInput {
    userId: number;
    confirmationCode: string | undefined;
    c: string | undefined;
}

export class ImpersonateInput implements IImpersonateInput {
    tenantId!: number | undefined;
    userId!: number;

    constructor(data?: IImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IImpersonateInput {
    tenantId: number | undefined;
    userId: number;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.impersonationToken = _data["impersonationToken"];
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        return data;
    }
}

export interface IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;
}

export class DelegatedImpersonateInput implements IDelegatedImpersonateInput {
    userDelegationId!: number;

    constructor(data?: IDelegatedImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userDelegationId = _data["userDelegationId"];
        }
    }

    static fromJS(data: any): DelegatedImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new DelegatedImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userDelegationId"] = this.userDelegationId;
        return data;
    }
}

export interface IDelegatedImpersonateInput {
    userDelegationId: number;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId!: number | undefined;
    targetUserId!: number;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetTenantId = _data["targetTenantId"];
            this.targetUserId = _data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data;
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.switchAccountToken = _data["switchAccountToken"];
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data;
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;
}

export class AuditLogListDto implements IAuditLogListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    impersonatorTenantId!: number | undefined;
    impersonatorUserId!: number | undefined;
    serviceName!: string | undefined;
    methodName!: string | undefined;
    parameters!: string | undefined;
    executionTime!: DateTime;
    executionDuration!: number;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    exception!: string | undefined;
    customData!: string | undefined;
    id!: number;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.impersonatorTenantId = _data["impersonatorTenantId"];
            this.impersonatorUserId = _data["impersonatorUserId"];
            this.serviceName = _data["serviceName"];
            this.methodName = _data["methodName"];
            this.parameters = _data["parameters"];
            this.executionTime = _data["executionTime"] ? DateTime.fromISO(_data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = _data["executionDuration"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.browserInfo = _data["browserInfo"];
            this.exception = _data["exception"];
            this.customData = _data["customData"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data;
    }
}

export interface IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: DateTime;
    executionDuration: number;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number;
}

export class PagedResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
    totalCount!: number;
    items!: AuditLogListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAuditLogListDto {
    totalCount: number;
    items: AuditLogListDto[] | undefined;
}

export class FileDto implements IFileDto {
    fileName!: string;
    fileType!: string | undefined;
    fileToken!: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fileToken = _data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data;
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string | undefined;
    fileToken: string;
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export enum EntityChangeType {
    Created = 0,
    Updated = 1,
    Deleted = 2,
}

export class EntityChangeListDto implements IEntityChangeListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    changeTime!: DateTime;
    entityTypeFullName!: string | undefined;
    changeType!: EntityChangeType;
    readonly changeTypeName!: string | undefined;
    entityChangeSetId!: number;
    id!: number;

    constructor(data?: IEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.changeTime = _data["changeTime"] ? DateTime.fromISO(_data["changeTime"].toString()) : <any>undefined;
            this.entityTypeFullName = _data["entityTypeFullName"];
            this.changeType = _data["changeType"];
            (<any>this).changeTypeName = _data["changeTypeName"];
            this.entityChangeSetId = _data["entityChangeSetId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["changeTime"] = this.changeTime ? this.changeTime.toString() : <any>undefined;
        data["entityTypeFullName"] = this.entityTypeFullName;
        data["changeType"] = this.changeType;
        data["changeTypeName"] = this.changeTypeName;
        data["entityChangeSetId"] = this.entityChangeSetId;
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: DateTime;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeType;
    changeTypeName: string | undefined;
    entityChangeSetId: number;
    id: number;
}

export class PagedResultDtoOfEntityChangeListDto implements IPagedResultDtoOfEntityChangeListDto {
    totalCount!: number;
    items!: EntityChangeListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EntityChangeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfEntityChangeListDto {
    totalCount: number;
    items: EntityChangeListDto[] | undefined;
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
    entityChangeId!: number;
    newValue!: string | undefined;
    originalValue!: string | undefined;
    propertyName!: string | undefined;
    propertyTypeFullName!: string | undefined;
    tenantId!: number | undefined;
    id!: number;

    constructor(data?: IEntityPropertyChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityChangeId = _data["entityChangeId"];
            this.newValue = _data["newValue"];
            this.originalValue = _data["originalValue"];
            this.propertyName = _data["propertyName"];
            this.propertyTypeFullName = _data["propertyTypeFullName"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityPropertyChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityChangeId"] = this.entityChangeId;
        data["newValue"] = this.newValue;
        data["originalValue"] = this.originalValue;
        data["propertyName"] = this.propertyName;
        data["propertyTypeFullName"] = this.propertyTypeFullName;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityPropertyChangeDto {
    entityChangeId: number;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
    tenantId: number | undefined;
    id: number;
}

export class BmsColumnDto implements IBmsColumnDto {
    id!: number;
    columnCode!: string | undefined;
    columnType!: number;

    constructor(data?: IBmsColumnDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.columnCode = _data["columnCode"];
            this.columnType = _data["columnType"];
        }
    }

    static fromJS(data: any): BmsColumnDto {
        data = typeof data === 'object' ? data : {};
        let result = new BmsColumnDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["columnCode"] = this.columnCode;
        data["columnType"] = this.columnType;
        return data;
    }
}

export interface IBmsColumnDto {
    id: number;
    columnCode: string | undefined;
    columnType: number;
}

export class BmsBudgetPlanReviewDto implements IBmsBudgetPlanReviewDto {
    id!: number;
    group!: string | undefined;
    division!: string | undefined;
    department!: string | undefined;
    category!: string | undefined;
    expenseType!: string | undefined;
    budgetName!: string | undefined;
    budgetCode!: string | undefined;
    month!: number | undefined;
    year!: number | undefined;
    jan_PlanAmount!: number | undefined;
    feb_PlanAmount!: number | undefined;
    mar_PlanAmount!: number | undefined;
    apr_PlanAmount!: number | undefined;
    may_PlanAmount!: number | undefined;
    jun_PlanAmount!: number | undefined;
    jul_PlanAmount!: number | undefined;
    aug_PlanAmount!: number | undefined;
    sep_PlanAmount!: number | undefined;
    oct_PlanAmount!: number | undefined;
    nov_PlanAmount!: number | undefined;
    dec_PlanAmount!: number | undefined;
    budgetPlanId!: number | undefined;
    carModel!: string | undefined;
    periodId!: number | undefined;
    remarkOri!: string | undefined;
    remark1Q!: string | undefined;
    remark2Q!: string | undefined;
    remark3Q!: string | undefined;
    remarkFP!: string | undefined;
    remark11P!: string | undefined;
    fY_Ori!: number | undefined;
    fY_1Q!: number | undefined;
    fY_2Q!: number | undefined;
    fY_3Q!: number | undefined;
    fY_11P!: number | undefined;
    currencyCode!: number | undefined;
    finPlan!: number | undefined;
    prRingiIssueMonth!: DateTime | undefined;
    completionMonth!: DateTime | undefined;
    saleDLRMonth!: DateTime | undefined;
    tmcCode!: string | undefined;
    tmcCategoryName!: string | undefined;
    assetClass!: string | undefined;
    pp06!: string | undefined;
    investType!: string | undefined;
    projectNonProject!: string | undefined;
    projectCode!: string | undefined;
    plNumber!: string | undefined;

    constructor(data?: IBmsBudgetPlanReviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.group = _data["group"];
            this.division = _data["division"];
            this.department = _data["department"];
            this.category = _data["category"];
            this.expenseType = _data["expenseType"];
            this.budgetName = _data["budgetName"];
            this.budgetCode = _data["budgetCode"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.jan_PlanAmount = _data["jan_PlanAmount"];
            this.feb_PlanAmount = _data["feb_PlanAmount"];
            this.mar_PlanAmount = _data["mar_PlanAmount"];
            this.apr_PlanAmount = _data["apr_PlanAmount"];
            this.may_PlanAmount = _data["may_PlanAmount"];
            this.jun_PlanAmount = _data["jun_PlanAmount"];
            this.jul_PlanAmount = _data["jul_PlanAmount"];
            this.aug_PlanAmount = _data["aug_PlanAmount"];
            this.sep_PlanAmount = _data["sep_PlanAmount"];
            this.oct_PlanAmount = _data["oct_PlanAmount"];
            this.nov_PlanAmount = _data["nov_PlanAmount"];
            this.dec_PlanAmount = _data["dec_PlanAmount"];
            this.budgetPlanId = _data["budgetPlanId"];
            this.carModel = _data["carModel"];
            this.periodId = _data["periodId"];
            this.remarkOri = _data["remarkOri"];
            this.remark1Q = _data["remark1Q"];
            this.remark2Q = _data["remark2Q"];
            this.remark3Q = _data["remark3Q"];
            this.remarkFP = _data["remarkFP"];
            this.remark11P = _data["remark11P"];
            this.fY_Ori = _data["fY_Ori"];
            this.fY_1Q = _data["fY_1Q"];
            this.fY_2Q = _data["fY_2Q"];
            this.fY_3Q = _data["fY_3Q"];
            this.fY_11P = _data["fY_11P"];
            this.currencyCode = _data["currencyCode"];
            this.finPlan = _data["finPlan"];
            this.prRingiIssueMonth = _data["prRingiIssueMonth"] ? DateTime.fromISO(_data["prRingiIssueMonth"].toString()) : <any>undefined;
            this.completionMonth = _data["completionMonth"] ? DateTime.fromISO(_data["completionMonth"].toString()) : <any>undefined;
            this.saleDLRMonth = _data["saleDLRMonth"] ? DateTime.fromISO(_data["saleDLRMonth"].toString()) : <any>undefined;
            this.tmcCode = _data["tmcCode"];
            this.tmcCategoryName = _data["tmcCategoryName"];
            this.assetClass = _data["assetClass"];
            this.pp06 = _data["pp06"];
            this.investType = _data["investType"];
            this.projectNonProject = _data["projectNonProject"];
            this.projectCode = _data["projectCode"];
            this.plNumber = _data["plNumber"];
        }
    }

    static fromJS(data: any): BmsBudgetPlanReviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new BmsBudgetPlanReviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["group"] = this.group;
        data["division"] = this.division;
        data["department"] = this.department;
        data["category"] = this.category;
        data["expenseType"] = this.expenseType;
        data["budgetName"] = this.budgetName;
        data["budgetCode"] = this.budgetCode;
        data["month"] = this.month;
        data["year"] = this.year;
        data["jan_PlanAmount"] = this.jan_PlanAmount;
        data["feb_PlanAmount"] = this.feb_PlanAmount;
        data["mar_PlanAmount"] = this.mar_PlanAmount;
        data["apr_PlanAmount"] = this.apr_PlanAmount;
        data["may_PlanAmount"] = this.may_PlanAmount;
        data["jun_PlanAmount"] = this.jun_PlanAmount;
        data["jul_PlanAmount"] = this.jul_PlanAmount;
        data["aug_PlanAmount"] = this.aug_PlanAmount;
        data["sep_PlanAmount"] = this.sep_PlanAmount;
        data["oct_PlanAmount"] = this.oct_PlanAmount;
        data["nov_PlanAmount"] = this.nov_PlanAmount;
        data["dec_PlanAmount"] = this.dec_PlanAmount;
        data["budgetPlanId"] = this.budgetPlanId;
        data["carModel"] = this.carModel;
        data["periodId"] = this.periodId;
        data["remarkOri"] = this.remarkOri;
        data["remark1Q"] = this.remark1Q;
        data["remark2Q"] = this.remark2Q;
        data["remark3Q"] = this.remark3Q;
        data["remarkFP"] = this.remarkFP;
        data["remark11P"] = this.remark11P;
        data["fY_Ori"] = this.fY_Ori;
        data["fY_1Q"] = this.fY_1Q;
        data["fY_2Q"] = this.fY_2Q;
        data["fY_3Q"] = this.fY_3Q;
        data["fY_11P"] = this.fY_11P;
        data["currencyCode"] = this.currencyCode;
        data["finPlan"] = this.finPlan;
        data["prRingiIssueMonth"] = this.prRingiIssueMonth ? this.prRingiIssueMonth.toString() : <any>undefined;
        data["completionMonth"] = this.completionMonth ? this.completionMonth.toString() : <any>undefined;
        data["saleDLRMonth"] = this.saleDLRMonth ? this.saleDLRMonth.toString() : <any>undefined;
        data["tmcCode"] = this.tmcCode;
        data["tmcCategoryName"] = this.tmcCategoryName;
        data["assetClass"] = this.assetClass;
        data["pp06"] = this.pp06;
        data["investType"] = this.investType;
        data["projectNonProject"] = this.projectNonProject;
        data["projectCode"] = this.projectCode;
        data["plNumber"] = this.plNumber;
        return data;
    }
}

export interface IBmsBudgetPlanReviewDto {
    id: number;
    group: string | undefined;
    division: string | undefined;
    department: string | undefined;
    category: string | undefined;
    expenseType: string | undefined;
    budgetName: string | undefined;
    budgetCode: string | undefined;
    month: number | undefined;
    year: number | undefined;
    jan_PlanAmount: number | undefined;
    feb_PlanAmount: number | undefined;
    mar_PlanAmount: number | undefined;
    apr_PlanAmount: number | undefined;
    may_PlanAmount: number | undefined;
    jun_PlanAmount: number | undefined;
    jul_PlanAmount: number | undefined;
    aug_PlanAmount: number | undefined;
    sep_PlanAmount: number | undefined;
    oct_PlanAmount: number | undefined;
    nov_PlanAmount: number | undefined;
    dec_PlanAmount: number | undefined;
    budgetPlanId: number | undefined;
    carModel: string | undefined;
    periodId: number | undefined;
    remarkOri: string | undefined;
    remark1Q: string | undefined;
    remark2Q: string | undefined;
    remark3Q: string | undefined;
    remarkFP: string | undefined;
    remark11P: string | undefined;
    fY_Ori: number | undefined;
    fY_1Q: number | undefined;
    fY_2Q: number | undefined;
    fY_3Q: number | undefined;
    fY_11P: number | undefined;
    currencyCode: number | undefined;
    finPlan: number | undefined;
    prRingiIssueMonth: DateTime | undefined;
    completionMonth: DateTime | undefined;
    saleDLRMonth: DateTime | undefined;
    tmcCode: string | undefined;
    tmcCategoryName: string | undefined;
    assetClass: string | undefined;
    pp06: string | undefined;
    investType: string | undefined;
    projectNonProject: string | undefined;
    projectCode: string | undefined;
    plNumber: string | undefined;
}

export class PagedResultDtoOfBmsBudgetPlanReviewDto implements IPagedResultDtoOfBmsBudgetPlanReviewDto {
    totalCount!: number;
    items!: BmsBudgetPlanReviewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBmsBudgetPlanReviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BmsBudgetPlanReviewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBmsBudgetPlanReviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBmsBudgetPlanReviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBmsBudgetPlanReviewDto {
    totalCount: number;
    items: BmsBudgetPlanReviewDto[] | undefined;
}

export class UserBudgetControlDto implements IUserBudgetControlDto {
    id!: number;
    budgetCode!: string | undefined;
    division!: string | undefined;
    department!: string | undefined;
    isCheck!: boolean;

    constructor(data?: IUserBudgetControlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.budgetCode = _data["budgetCode"];
            this.division = _data["division"];
            this.department = _data["department"];
            this.isCheck = _data["isCheck"];
        }
    }

    static fromJS(data: any): UserBudgetControlDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserBudgetControlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["budgetCode"] = this.budgetCode;
        data["division"] = this.division;
        data["department"] = this.department;
        data["isCheck"] = this.isCheck;
        return data;
    }
}

export interface IUserBudgetControlDto {
    id: number;
    budgetCode: string | undefined;
    division: string | undefined;
    department: string | undefined;
    isCheck: boolean;
}

export class BudgetControlOutputDto implements IBudgetControlOutputDto {
    listRight!: UserBudgetControlDto[] | undefined;
    listLeft!: UserBudgetControlDto[] | undefined;

    constructor(data?: IBudgetControlOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listRight"])) {
                this.listRight = [] as any;
                for (let item of _data["listRight"])
                    this.listRight!.push(UserBudgetControlDto.fromJS(item));
            }
            if (Array.isArray(_data["listLeft"])) {
                this.listLeft = [] as any;
                for (let item of _data["listLeft"])
                    this.listLeft!.push(UserBudgetControlDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BudgetControlOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetControlOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listRight)) {
            data["listRight"] = [];
            for (let item of this.listRight)
                data["listRight"].push(item.toJSON());
        }
        if (Array.isArray(this.listLeft)) {
            data["listLeft"] = [];
            for (let item of this.listLeft)
                data["listLeft"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBudgetControlOutputDto {
    listRight: UserBudgetControlDto[] | undefined;
    listLeft: UserBudgetControlDto[] | undefined;
}

export class UserChechBudgetDto implements IUserChechBudgetDto {
    userId!: number;
    userName!: string | undefined;
    userFullName!: string | undefined;
    departmentName!: string | undefined;
    divisionName!: string | undefined;
    groupName!: string | undefined;
    isFinanceMA!: boolean | undefined;
    isGroupManageRight!: boolean | undefined;
    isCheck!: boolean;

    constructor(data?: IUserChechBudgetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.userFullName = _data["userFullName"];
            this.departmentName = _data["departmentName"];
            this.divisionName = _data["divisionName"];
            this.groupName = _data["groupName"];
            this.isFinanceMA = _data["isFinanceMA"];
            this.isGroupManageRight = _data["isGroupManageRight"];
            this.isCheck = _data["isCheck"];
        }
    }

    static fromJS(data: any): UserChechBudgetDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserChechBudgetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["userFullName"] = this.userFullName;
        data["departmentName"] = this.departmentName;
        data["divisionName"] = this.divisionName;
        data["groupName"] = this.groupName;
        data["isFinanceMA"] = this.isFinanceMA;
        data["isGroupManageRight"] = this.isGroupManageRight;
        data["isCheck"] = this.isCheck;
        return data;
    }
}

export interface IUserChechBudgetDto {
    userId: number;
    userName: string | undefined;
    userFullName: string | undefined;
    departmentName: string | undefined;
    divisionName: string | undefined;
    groupName: string | undefined;
    isFinanceMA: boolean | undefined;
    isGroupManageRight: boolean | undefined;
    isCheck: boolean;
}

export class BmsUserRoleDto implements IBmsUserRoleDto {
    userId!: number;
    isFinanceMA!: boolean | undefined;
    isGroupManageRight!: boolean | undefined;

    constructor(data?: IBmsUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.isFinanceMA = _data["isFinanceMA"];
            this.isGroupManageRight = _data["isGroupManageRight"];
        }
    }

    static fromJS(data: any): BmsUserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new BmsUserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["isFinanceMA"] = this.isFinanceMA;
        data["isGroupManageRight"] = this.isGroupManageRight;
        return data;
    }
}

export interface IBmsUserRoleDto {
    userId: number;
    isFinanceMA: boolean | undefined;
    isGroupManageRight: boolean | undefined;
}

export class InputSetUserControlBudgetDto implements IInputSetUserControlBudgetDto {
    userId!: number;
    listBudgetId!: number[] | undefined;
    manageType!: number | undefined;

    constructor(data?: IInputSetUserControlBudgetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            if (Array.isArray(_data["listBudgetId"])) {
                this.listBudgetId = [] as any;
                for (let item of _data["listBudgetId"])
                    this.listBudgetId!.push(item);
            }
            this.manageType = _data["manageType"];
        }
    }

    static fromJS(data: any): InputSetUserControlBudgetDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputSetUserControlBudgetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        if (Array.isArray(this.listBudgetId)) {
            data["listBudgetId"] = [];
            for (let item of this.listBudgetId)
                data["listBudgetId"].push(item);
        }
        data["manageType"] = this.manageType;
        return data;
    }
}

export interface IInputSetUserControlBudgetDto {
    userId: number;
    listBudgetId: number[] | undefined;
    manageType: number | undefined;
}

export class BmsMstPairingSegmentDto implements IBmsMstPairingSegmentDto {
    id!: number;
    segment1Name!: string | undefined;
    segment2Name!: string | undefined;
    segment3Name!: string | undefined;
    segment4Name!: string | undefined;
    segment5Name!: string | undefined;
    pairingText!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    isActive!: boolean;
    periodName!: string | undefined;
    periodVersionName!: string | undefined;
    amountTransfer!: number | undefined;
    type!: string | undefined;

    constructor(data?: IBmsMstPairingSegmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.segment1Name = _data["segment1Name"];
            this.segment2Name = _data["segment2Name"];
            this.segment3Name = _data["segment3Name"];
            this.segment4Name = _data["segment4Name"];
            this.segment5Name = _data["segment5Name"];
            this.pairingText = _data["pairingText"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.periodName = _data["periodName"];
            this.periodVersionName = _data["periodVersionName"];
            this.amountTransfer = _data["amountTransfer"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): BmsMstPairingSegmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new BmsMstPairingSegmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["segment1Name"] = this.segment1Name;
        data["segment2Name"] = this.segment2Name;
        data["segment3Name"] = this.segment3Name;
        data["segment4Name"] = this.segment4Name;
        data["segment5Name"] = this.segment5Name;
        data["pairingText"] = this.pairingText;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["periodName"] = this.periodName;
        data["periodVersionName"] = this.periodVersionName;
        data["amountTransfer"] = this.amountTransfer;
        data["type"] = this.type;
        return data;
    }
}

export interface IBmsMstPairingSegmentDto {
    id: number;
    segment1Name: string | undefined;
    segment2Name: string | undefined;
    segment3Name: string | undefined;
    segment4Name: string | undefined;
    segment5Name: string | undefined;
    pairingText: string | undefined;
    name: string | undefined;
    description: string | undefined;
    isActive: boolean;
    periodName: string | undefined;
    periodVersionName: string | undefined;
    amountTransfer: number | undefined;
    type: string | undefined;
}

export class PagedResultDtoOfBmsMstPairingSegmentDto implements IPagedResultDtoOfBmsMstPairingSegmentDto {
    totalCount!: number;
    items!: BmsMstPairingSegmentDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBmsMstPairingSegmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BmsMstPairingSegmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBmsMstPairingSegmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBmsMstPairingSegmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBmsMstPairingSegmentDto {
    totalCount: number;
    items: BmsMstPairingSegmentDto[] | undefined;
}

export class InputPairingSegmentDto implements IInputPairingSegmentDto {
    id!: number;
    segment1Id!: number;
    segment2Id!: number;
    segment3Id!: number;
    segment4Id!: number;
    segment5Id!: number;
    pairingText!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    isActive!: boolean;
    periodVersion!: number;
    periodId!: number;
    amountTransfer!: number | undefined;
    type!: number | undefined;

    constructor(data?: IInputPairingSegmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.segment1Id = _data["segment1Id"];
            this.segment2Id = _data["segment2Id"];
            this.segment3Id = _data["segment3Id"];
            this.segment4Id = _data["segment4Id"];
            this.segment5Id = _data["segment5Id"];
            this.pairingText = _data["pairingText"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.periodVersion = _data["periodVersion"];
            this.periodId = _data["periodId"];
            this.amountTransfer = _data["amountTransfer"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): InputPairingSegmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputPairingSegmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["segment1Id"] = this.segment1Id;
        data["segment2Id"] = this.segment2Id;
        data["segment3Id"] = this.segment3Id;
        data["segment4Id"] = this.segment4Id;
        data["segment5Id"] = this.segment5Id;
        data["pairingText"] = this.pairingText;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["periodVersion"] = this.periodVersion;
        data["periodId"] = this.periodId;
        data["amountTransfer"] = this.amountTransfer;
        data["type"] = this.type;
        return data;
    }
}

export interface IInputPairingSegmentDto {
    id: number;
    segment1Id: number;
    segment2Id: number;
    segment3Id: number;
    segment4Id: number;
    segment5Id: number;
    pairingText: string | undefined;
    name: string | undefined;
    description: string | undefined;
    isActive: boolean;
    periodVersion: number;
    periodId: number;
    amountTransfer: number | undefined;
    type: number | undefined;
}

export class ValPairingSegmentDto implements IValPairingSegmentDto {
    name!: string | undefined;
    code!: string | undefined;

    constructor(data?: IValPairingSegmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): ValPairingSegmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValPairingSegmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IValPairingSegmentDto {
    name: string | undefined;
    code: string | undefined;
}

export class DepartmentSelectDto implements IDepartmentSelectDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: IDepartmentSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DepartmentSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IDepartmentSelectDto {
    id: number;
    name: string | undefined;
}

export class SegmentReadDataDto implements ISegmentReadDataDto {
    periodName!: string | undefined;
    periodId!: number;
    periodVersionName!: string | undefined;
    periodVersion!: number;
    code!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    remark!: string | undefined;
    typeCostName!: string | undefined;
    typeCostId!: number;
    projectTypeName!: string | undefined;
    projectTypeId!: number;
    departmentName!: string | undefined;
    departmentId!: number;
    divisionId!: number;
    groupSeg4Id!: number;
    groupSeg4Name!: string | undefined;
    isActive!: boolean;
    segment1Name!: string | undefined;
    segment1Code!: string | undefined;
    segment1Id!: number;
    segment2Name!: string | undefined;
    segment2Code!: string | undefined;
    segment2Id!: number;
    segment3Name!: string | undefined;
    segment3Code!: string | undefined;
    segment3Id!: number;
    segment4Name!: string | undefined;
    segment4Code!: string | undefined;
    segment4Id!: number;
    segment5Name!: string | undefined;
    segment5Code!: string | undefined;
    segment5Id!: number;
    type!: number;

    constructor(data?: ISegmentReadDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.periodName = _data["periodName"];
            this.periodId = _data["periodId"];
            this.periodVersionName = _data["periodVersionName"];
            this.periodVersion = _data["periodVersion"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.remark = _data["remark"];
            this.typeCostName = _data["typeCostName"];
            this.typeCostId = _data["typeCostId"];
            this.projectTypeName = _data["projectTypeName"];
            this.projectTypeId = _data["projectTypeId"];
            this.departmentName = _data["departmentName"];
            this.departmentId = _data["departmentId"];
            this.divisionId = _data["divisionId"];
            this.groupSeg4Id = _data["groupSeg4Id"];
            this.groupSeg4Name = _data["groupSeg4Name"];
            this.isActive = _data["isActive"];
            this.segment1Name = _data["segment1Name"];
            this.segment1Code = _data["segment1Code"];
            this.segment1Id = _data["segment1Id"];
            this.segment2Name = _data["segment2Name"];
            this.segment2Code = _data["segment2Code"];
            this.segment2Id = _data["segment2Id"];
            this.segment3Name = _data["segment3Name"];
            this.segment3Code = _data["segment3Code"];
            this.segment3Id = _data["segment3Id"];
            this.segment4Name = _data["segment4Name"];
            this.segment4Code = _data["segment4Code"];
            this.segment4Id = _data["segment4Id"];
            this.segment5Name = _data["segment5Name"];
            this.segment5Code = _data["segment5Code"];
            this.segment5Id = _data["segment5Id"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): SegmentReadDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new SegmentReadDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["periodName"] = this.periodName;
        data["periodId"] = this.periodId;
        data["periodVersionName"] = this.periodVersionName;
        data["periodVersion"] = this.periodVersion;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["remark"] = this.remark;
        data["typeCostName"] = this.typeCostName;
        data["typeCostId"] = this.typeCostId;
        data["projectTypeName"] = this.projectTypeName;
        data["projectTypeId"] = this.projectTypeId;
        data["departmentName"] = this.departmentName;
        data["departmentId"] = this.departmentId;
        data["divisionId"] = this.divisionId;
        data["groupSeg4Id"] = this.groupSeg4Id;
        data["groupSeg4Name"] = this.groupSeg4Name;
        data["isActive"] = this.isActive;
        data["segment1Name"] = this.segment1Name;
        data["segment1Code"] = this.segment1Code;
        data["segment1Id"] = this.segment1Id;
        data["segment2Name"] = this.segment2Name;
        data["segment2Code"] = this.segment2Code;
        data["segment2Id"] = this.segment2Id;
        data["segment3Name"] = this.segment3Name;
        data["segment3Code"] = this.segment3Code;
        data["segment3Id"] = this.segment3Id;
        data["segment4Name"] = this.segment4Name;
        data["segment4Code"] = this.segment4Code;
        data["segment4Id"] = this.segment4Id;
        data["segment5Name"] = this.segment5Name;
        data["segment5Code"] = this.segment5Code;
        data["segment5Id"] = this.segment5Id;
        data["type"] = this.type;
        return data;
    }
}

export interface ISegmentReadDataDto {
    periodName: string | undefined;
    periodId: number;
    periodVersionName: string | undefined;
    periodVersion: number;
    code: string | undefined;
    name: string | undefined;
    description: string | undefined;
    remark: string | undefined;
    typeCostName: string | undefined;
    typeCostId: number;
    projectTypeName: string | undefined;
    projectTypeId: number;
    departmentName: string | undefined;
    departmentId: number;
    divisionId: number;
    groupSeg4Id: number;
    groupSeg4Name: string | undefined;
    isActive: boolean;
    segment1Name: string | undefined;
    segment1Code: string | undefined;
    segment1Id: number;
    segment2Name: string | undefined;
    segment2Code: string | undefined;
    segment2Id: number;
    segment3Name: string | undefined;
    segment3Code: string | undefined;
    segment3Id: number;
    segment4Name: string | undefined;
    segment4Code: string | undefined;
    segment4Id: number;
    segment5Name: string | undefined;
    segment5Code: string | undefined;
    segment5Id: number;
    type: number;
}

export class BmsMstPeriodDto implements IBmsMstPeriodDto {
    id!: number;
    periodName!: string | undefined;
    periodYear!: number;
    fromDate!: DateTime;
    todate!: DateTime;
    description!: string | undefined;
    isActive!: boolean;
    statusString!: string | undefined;

    constructor(data?: IBmsMstPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.periodName = _data["periodName"];
            this.periodYear = _data["periodYear"];
            this.fromDate = _data["fromDate"] ? DateTime.fromISO(_data["fromDate"].toString()) : <any>undefined;
            this.todate = _data["todate"] ? DateTime.fromISO(_data["todate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.statusString = _data["statusString"];
        }
    }

    static fromJS(data: any): BmsMstPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new BmsMstPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["periodName"] = this.periodName;
        data["periodYear"] = this.periodYear;
        data["fromDate"] = this.fromDate ? this.fromDate.toString() : <any>undefined;
        data["todate"] = this.todate ? this.todate.toString() : <any>undefined;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["statusString"] = this.statusString;
        return data;
    }
}

export interface IBmsMstPeriodDto {
    id: number;
    periodName: string | undefined;
    periodYear: number;
    fromDate: DateTime;
    todate: DateTime;
    description: string | undefined;
    isActive: boolean;
    statusString: string | undefined;
}

export class PagedResultDtoOfBmsMstPeriodDto implements IPagedResultDtoOfBmsMstPeriodDto {
    totalCount!: number;
    items!: BmsMstPeriodDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBmsMstPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BmsMstPeriodDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBmsMstPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBmsMstPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBmsMstPeriodDto {
    totalCount: number;
    items: BmsMstPeriodDto[] | undefined;
}

export class InputBmsMstPeriodDto implements IInputBmsMstPeriodDto {
    id!: number;
    periodName!: string | undefined;
    periodYear!: number;
    fromDate!: DateTime;
    todate!: DateTime;
    description!: string | undefined;
    isActive!: boolean;

    constructor(data?: IInputBmsMstPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.periodName = _data["periodName"];
            this.periodYear = _data["periodYear"];
            this.fromDate = _data["fromDate"] ? DateTime.fromISO(_data["fromDate"].toString()) : <any>undefined;
            this.todate = _data["todate"] ? DateTime.fromISO(_data["todate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): InputBmsMstPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputBmsMstPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["periodName"] = this.periodName;
        data["periodYear"] = this.periodYear;
        data["fromDate"] = this.fromDate ? this.fromDate.toString() : <any>undefined;
        data["todate"] = this.todate ? this.todate.toString() : <any>undefined;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IInputBmsMstPeriodDto {
    id: number;
    periodName: string | undefined;
    periodYear: number;
    fromDate: DateTime;
    todate: DateTime;
    description: string | undefined;
    isActive: boolean;
}

export class ValPeriodSaveDto implements IValPeriodSaveDto {
    name!: string | undefined;
    code!: string | undefined;

    constructor(data?: IValPeriodSaveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): ValPeriodSaveDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValPeriodSaveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IValPeriodSaveDto {
    name: string | undefined;
    code: string | undefined;
}

export class MstSegment1Dto implements IMstSegment1Dto {
    id!: number;
    code!: string | undefined;
    name!: string | undefined;
    typeCostName!: string | undefined;
    periodName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IMstSegment1Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.typeCostName = _data["typeCostName"];
            this.periodName = _data["periodName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): MstSegment1Dto {
        data = typeof data === 'object' ? data : {};
        let result = new MstSegment1Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["typeCostName"] = this.typeCostName;
        data["periodName"] = this.periodName;
        data["description"] = this.description;
        return data;
    }
}

export interface IMstSegment1Dto {
    id: number;
    code: string | undefined;
    name: string | undefined;
    typeCostName: string | undefined;
    periodName: string | undefined;
    description: string | undefined;
}

export class PagedResultDtoOfMstSegment1Dto implements IPagedResultDtoOfMstSegment1Dto {
    totalCount!: number;
    items!: MstSegment1Dto[] | undefined;

    constructor(data?: IPagedResultDtoOfMstSegment1Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MstSegment1Dto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMstSegment1Dto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMstSegment1Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMstSegment1Dto {
    totalCount: number;
    items: MstSegment1Dto[] | undefined;
}

export class InputSegment1Dto implements IInputSegment1Dto {
    id!: number;
    code!: string | undefined;
    name!: string | undefined;
    typeCostId!: number;
    periodId!: number;
    description!: string | undefined;

    constructor(data?: IInputSegment1Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.typeCostId = _data["typeCostId"];
            this.periodId = _data["periodId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): InputSegment1Dto {
        data = typeof data === 'object' ? data : {};
        let result = new InputSegment1Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["typeCostId"] = this.typeCostId;
        data["periodId"] = this.periodId;
        data["description"] = this.description;
        return data;
    }
}

export interface IInputSegment1Dto {
    id: number;
    code: string | undefined;
    name: string | undefined;
    typeCostId: number;
    periodId: number;
    description: string | undefined;
}

export class ValSegment1SaveDto implements IValSegment1SaveDto {
    name!: string | undefined;
    code!: string | undefined;

    constructor(data?: IValSegment1SaveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): ValSegment1SaveDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValSegment1SaveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IValSegment1SaveDto {
    name: string | undefined;
    code: string | undefined;
}

export class TypeCostDto implements ITypeCostDto {
    id!: number;
    typeCostName!: string | undefined;
    description!: string | undefined;

    constructor(data?: ITypeCostDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeCostName = _data["typeCostName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): TypeCostDto {
        data = typeof data === 'object' ? data : {};
        let result = new TypeCostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeCostName"] = this.typeCostName;
        data["description"] = this.description;
        return data;
    }
}

export interface ITypeCostDto {
    id: number;
    typeCostName: string | undefined;
    description: string | undefined;
}

export class PagedResultDtoOfTypeCostDto implements IPagedResultDtoOfTypeCostDto {
    totalCount!: number;
    items!: TypeCostDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTypeCostDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TypeCostDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTypeCostDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTypeCostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTypeCostDto {
    totalCount: number;
    items: TypeCostDto[] | undefined;
}

export class MstSegment1TypeCostDto implements IMstSegment1TypeCostDto {
    id!: number;
    typeCostName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IMstSegment1TypeCostDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeCostName = _data["typeCostName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): MstSegment1TypeCostDto {
        data = typeof data === 'object' ? data : {};
        let result = new MstSegment1TypeCostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeCostName"] = this.typeCostName;
        data["description"] = this.description;
        return data;
    }
}

export interface IMstSegment1TypeCostDto {
    id: number;
    typeCostName: string | undefined;
    description: string | undefined;
}

export class InputTypeCostDto implements IInputTypeCostDto {
    id!: number;
    typeCostName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IInputTypeCostDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeCostName = _data["typeCostName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): InputTypeCostDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputTypeCostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeCostName"] = this.typeCostName;
        data["description"] = this.description;
        return data;
    }
}

export interface IInputTypeCostDto {
    id: number;
    typeCostName: string | undefined;
    description: string | undefined;
}

export class MstSegment2Dto implements IMstSegment2Dto {
    id!: number;
    code!: string | undefined;
    name!: string | undefined;
    projectTypeName!: string | undefined;
    periodName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IMstSegment2Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.projectTypeName = _data["projectTypeName"];
            this.periodName = _data["periodName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): MstSegment2Dto {
        data = typeof data === 'object' ? data : {};
        let result = new MstSegment2Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["projectTypeName"] = this.projectTypeName;
        data["periodName"] = this.periodName;
        data["description"] = this.description;
        return data;
    }
}

export interface IMstSegment2Dto {
    id: number;
    code: string | undefined;
    name: string | undefined;
    projectTypeName: string | undefined;
    periodName: string | undefined;
    description: string | undefined;
}

export class PagedResultDtoOfMstSegment2Dto implements IPagedResultDtoOfMstSegment2Dto {
    totalCount!: number;
    items!: MstSegment2Dto[] | undefined;

    constructor(data?: IPagedResultDtoOfMstSegment2Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MstSegment2Dto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMstSegment2Dto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMstSegment2Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMstSegment2Dto {
    totalCount: number;
    items: MstSegment2Dto[] | undefined;
}

export class InputSegment2Dto implements IInputSegment2Dto {
    id!: number;
    code!: string | undefined;
    name!: string | undefined;
    projectTypeId!: number;
    periodId!: number;
    description!: string | undefined;

    constructor(data?: IInputSegment2Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.projectTypeId = _data["projectTypeId"];
            this.periodId = _data["periodId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): InputSegment2Dto {
        data = typeof data === 'object' ? data : {};
        let result = new InputSegment2Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["projectTypeId"] = this.projectTypeId;
        data["periodId"] = this.periodId;
        data["description"] = this.description;
        return data;
    }
}

export interface IInputSegment2Dto {
    id: number;
    code: string | undefined;
    name: string | undefined;
    projectTypeId: number;
    periodId: number;
    description: string | undefined;
}

export class ValSegment2Dto implements IValSegment2Dto {
    name!: string | undefined;
    code!: string | undefined;

    constructor(data?: IValSegment2Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): ValSegment2Dto {
        data = typeof data === 'object' ? data : {};
        let result = new ValSegment2Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IValSegment2Dto {
    name: string | undefined;
    code: string | undefined;
}

export class ProjectTypeDto implements IProjectTypeDto {
    id!: number;
    projectTypeName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IProjectTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectTypeName = _data["projectTypeName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ProjectTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectTypeName"] = this.projectTypeName;
        data["description"] = this.description;
        return data;
    }
}

export interface IProjectTypeDto {
    id: number;
    projectTypeName: string | undefined;
    description: string | undefined;
}

export class PagedResultDtoOfProjectTypeDto implements IPagedResultDtoOfProjectTypeDto {
    totalCount!: number;
    items!: ProjectTypeDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProjectTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProjectTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProjectTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProjectTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfProjectTypeDto {
    totalCount: number;
    items: ProjectTypeDto[] | undefined;
}

export class MstSegment2ProjectTypeDto implements IMstSegment2ProjectTypeDto {
    id!: number;
    projectTypeName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IMstSegment2ProjectTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectTypeName = _data["projectTypeName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): MstSegment2ProjectTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new MstSegment2ProjectTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectTypeName"] = this.projectTypeName;
        data["description"] = this.description;
        return data;
    }
}

export interface IMstSegment2ProjectTypeDto {
    id: number;
    projectTypeName: string | undefined;
    description: string | undefined;
}

export class InputProjectTypeDto implements IInputProjectTypeDto {
    id!: number;
    projectTypeName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IInputProjectTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectTypeName = _data["projectTypeName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): InputProjectTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputProjectTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectTypeName"] = this.projectTypeName;
        data["description"] = this.description;
        return data;
    }
}

export interface IInputProjectTypeDto {
    id: number;
    projectTypeName: string | undefined;
    description: string | undefined;
}

export class DivisionSelectDto implements IDivisionSelectDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: IDivisionSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DivisionSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new DivisionSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IDivisionSelectDto {
    id: number;
    name: string | undefined;
}

export class MstSegment3Dto implements IMstSegment3Dto {
    id!: number;
    code!: string | undefined;
    name!: string | undefined;
    divisionName!: string | undefined;
    departmentName!: string | undefined;
    periodName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IMstSegment3Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.divisionName = _data["divisionName"];
            this.departmentName = _data["departmentName"];
            this.periodName = _data["periodName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): MstSegment3Dto {
        data = typeof data === 'object' ? data : {};
        let result = new MstSegment3Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["divisionName"] = this.divisionName;
        data["departmentName"] = this.departmentName;
        data["periodName"] = this.periodName;
        data["description"] = this.description;
        return data;
    }
}

export interface IMstSegment3Dto {
    id: number;
    code: string | undefined;
    name: string | undefined;
    divisionName: string | undefined;
    departmentName: string | undefined;
    periodName: string | undefined;
    description: string | undefined;
}

export class PagedResultDtoOfMstSegment3Dto implements IPagedResultDtoOfMstSegment3Dto {
    totalCount!: number;
    items!: MstSegment3Dto[] | undefined;

    constructor(data?: IPagedResultDtoOfMstSegment3Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MstSegment3Dto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMstSegment3Dto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMstSegment3Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMstSegment3Dto {
    totalCount: number;
    items: MstSegment3Dto[] | undefined;
}

export class InputSegment3Dto implements IInputSegment3Dto {
    id!: number;
    code!: string | undefined;
    name!: string | undefined;
    divisionId!: number;
    departmentId!: number;
    periodId!: number;
    description!: string | undefined;

    constructor(data?: IInputSegment3Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.divisionId = _data["divisionId"];
            this.departmentId = _data["departmentId"];
            this.periodId = _data["periodId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): InputSegment3Dto {
        data = typeof data === 'object' ? data : {};
        let result = new InputSegment3Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["divisionId"] = this.divisionId;
        data["departmentId"] = this.departmentId;
        data["periodId"] = this.periodId;
        data["description"] = this.description;
        return data;
    }
}

export interface IInputSegment3Dto {
    id: number;
    code: string | undefined;
    name: string | undefined;
    divisionId: number;
    departmentId: number;
    periodId: number;
    description: string | undefined;
}

export class ValSegment3Dto implements IValSegment3Dto {
    name!: string | undefined;
    code!: string | undefined;

    constructor(data?: IValSegment3Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): ValSegment3Dto {
        data = typeof data === 'object' ? data : {};
        let result = new ValSegment3Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IValSegment3Dto {
    name: string | undefined;
    code: string | undefined;
}

export class MstSegment4Dto implements IMstSegment4Dto {
    id!: number;
    code!: string | undefined;
    name!: string | undefined;
    groupSeg4Name!: string | undefined;
    periodName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IMstSegment4Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.groupSeg4Name = _data["groupSeg4Name"];
            this.periodName = _data["periodName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): MstSegment4Dto {
        data = typeof data === 'object' ? data : {};
        let result = new MstSegment4Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["groupSeg4Name"] = this.groupSeg4Name;
        data["periodName"] = this.periodName;
        data["description"] = this.description;
        return data;
    }
}

export interface IMstSegment4Dto {
    id: number;
    code: string | undefined;
    name: string | undefined;
    groupSeg4Name: string | undefined;
    periodName: string | undefined;
    description: string | undefined;
}

export class PagedResultDtoOfMstSegment4Dto implements IPagedResultDtoOfMstSegment4Dto {
    totalCount!: number;
    items!: MstSegment4Dto[] | undefined;

    constructor(data?: IPagedResultDtoOfMstSegment4Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MstSegment4Dto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMstSegment4Dto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMstSegment4Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMstSegment4Dto {
    totalCount: number;
    items: MstSegment4Dto[] | undefined;
}

export class InputSegment4Dto implements IInputSegment4Dto {
    id!: number;
    code!: string | undefined;
    name!: string | undefined;
    groupSeg4Id!: number;
    periodId!: number;
    description!: string | undefined;

    constructor(data?: IInputSegment4Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.groupSeg4Id = _data["groupSeg4Id"];
            this.periodId = _data["periodId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): InputSegment4Dto {
        data = typeof data === 'object' ? data : {};
        let result = new InputSegment4Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["groupSeg4Id"] = this.groupSeg4Id;
        data["periodId"] = this.periodId;
        data["description"] = this.description;
        return data;
    }
}

export interface IInputSegment4Dto {
    id: number;
    code: string | undefined;
    name: string | undefined;
    groupSeg4Id: number;
    periodId: number;
    description: string | undefined;
}

export class ValSegment4Dto implements IValSegment4Dto {
    name!: string | undefined;
    code!: string | undefined;

    constructor(data?: IValSegment4Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): ValSegment4Dto {
        data = typeof data === 'object' ? data : {};
        let result = new ValSegment4Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IValSegment4Dto {
    name: string | undefined;
    code: string | undefined;
}

export class MstSegment4GroupDto implements IMstSegment4GroupDto {
    id!: number;
    groupName!: string | undefined;
    periodName!: string | undefined;
    decription!: string | undefined;

    constructor(data?: IMstSegment4GroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.groupName = _data["groupName"];
            this.periodName = _data["periodName"];
            this.decription = _data["decription"];
        }
    }

    static fromJS(data: any): MstSegment4GroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new MstSegment4GroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["groupName"] = this.groupName;
        data["periodName"] = this.periodName;
        data["decription"] = this.decription;
        return data;
    }
}

export interface IMstSegment4GroupDto {
    id: number;
    groupName: string | undefined;
    periodName: string | undefined;
    decription: string | undefined;
}

export class PagedResultDtoOfMstSegment4GroupDto implements IPagedResultDtoOfMstSegment4GroupDto {
    totalCount!: number;
    items!: MstSegment4GroupDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMstSegment4GroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MstSegment4GroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMstSegment4GroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMstSegment4GroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMstSegment4GroupDto {
    totalCount: number;
    items: MstSegment4GroupDto[] | undefined;
}

export class InputSegment4GroupDto implements IInputSegment4GroupDto {
    id!: number;
    groupName!: string | undefined;
    periodId!: number;
    decription!: string | undefined;

    constructor(data?: IInputSegment4GroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.groupName = _data["groupName"];
            this.periodId = _data["periodId"];
            this.decription = _data["decription"];
        }
    }

    static fromJS(data: any): InputSegment4GroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputSegment4GroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["groupName"] = this.groupName;
        data["periodId"] = this.periodId;
        data["decription"] = this.decription;
        return data;
    }
}

export interface IInputSegment4GroupDto {
    id: number;
    groupName: string | undefined;
    periodId: number;
    decription: string | undefined;
}

export class MstSegment5Dto implements IMstSegment5Dto {
    id!: number;
    code!: string | undefined;
    name!: string | undefined;
    isActive!: boolean;
    periodName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IMstSegment5Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.periodName = _data["periodName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): MstSegment5Dto {
        data = typeof data === 'object' ? data : {};
        let result = new MstSegment5Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["periodName"] = this.periodName;
        data["description"] = this.description;
        return data;
    }
}

export interface IMstSegment5Dto {
    id: number;
    code: string | undefined;
    name: string | undefined;
    isActive: boolean;
    periodName: string | undefined;
    description: string | undefined;
}

export class PagedResultDtoOfMstSegment5Dto implements IPagedResultDtoOfMstSegment5Dto {
    totalCount!: number;
    items!: MstSegment5Dto[] | undefined;

    constructor(data?: IPagedResultDtoOfMstSegment5Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MstSegment5Dto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMstSegment5Dto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMstSegment5Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMstSegment5Dto {
    totalCount: number;
    items: MstSegment5Dto[] | undefined;
}

export class InputSegment5Dto implements IInputSegment5Dto {
    id!: number;
    code!: string | undefined;
    name!: string | undefined;
    isActive!: boolean;
    periodId!: number;
    description!: string | undefined;

    constructor(data?: IInputSegment5Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.periodId = _data["periodId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): InputSegment5Dto {
        data = typeof data === 'object' ? data : {};
        let result = new InputSegment5Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["periodId"] = this.periodId;
        data["description"] = this.description;
        return data;
    }
}

export interface IInputSegment5Dto {
    id: number;
    code: string | undefined;
    name: string | undefined;
    isActive: boolean;
    periodId: number;
    description: string | undefined;
}

export class ValSegment5Dto implements IValSegment5Dto {
    name!: string | undefined;
    code!: string | undefined;

    constructor(data?: IValSegment5Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): ValSegment5Dto {
        data = typeof data === 'object' ? data : {};
        let result = new ValSegment5Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IValSegment5Dto {
    name: string | undefined;
    code: string | undefined;
}

export class BmsPeriodVersionDto implements IBmsPeriodVersionDto {
    id!: number;
    periodName!: string | undefined;
    versionName!: string | undefined;
    description!: string | undefined;
    isActive!: boolean;
    statusString!: string | undefined;

    constructor(data?: IBmsPeriodVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.periodName = _data["periodName"];
            this.versionName = _data["versionName"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.statusString = _data["statusString"];
        }
    }

    static fromJS(data: any): BmsPeriodVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new BmsPeriodVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["periodName"] = this.periodName;
        data["versionName"] = this.versionName;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["statusString"] = this.statusString;
        return data;
    }
}

export interface IBmsPeriodVersionDto {
    id: number;
    periodName: string | undefined;
    versionName: string | undefined;
    description: string | undefined;
    isActive: boolean;
    statusString: string | undefined;
}

export class PagedResultDtoOfBmsPeriodVersionDto implements IPagedResultDtoOfBmsPeriodVersionDto {
    totalCount!: number;
    items!: BmsPeriodVersionDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBmsPeriodVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BmsPeriodVersionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBmsPeriodVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBmsPeriodVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBmsPeriodVersionDto {
    totalCount: number;
    items: BmsPeriodVersionDto[] | undefined;
}

export class MstVersionDto implements IMstVersionDto {
    id!: number;
    versionName!: string | undefined;

    constructor(data?: IMstVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.versionName = _data["versionName"];
        }
    }

    static fromJS(data: any): MstVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MstVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["versionName"] = this.versionName;
        return data;
    }
}

export interface IMstVersionDto {
    id: number;
    versionName: string | undefined;
}

export class InputPeriodVersionDto implements IInputPeriodVersionDto {
    id!: number;
    periodId!: number;
    versionId!: number;
    description!: string | undefined;
    isActive!: boolean;

    constructor(data?: IInputPeriodVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.periodId = _data["periodId"];
            this.versionId = _data["versionId"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): InputPeriodVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputPeriodVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["periodId"] = this.periodId;
        data["versionId"] = this.versionId;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IInputPeriodVersionDto {
    id: number;
    periodId: number;
    versionId: number;
    description: string | undefined;
    isActive: boolean;
}

export class PeriodAndVersionDto implements IPeriodAndVersionDto {
    periodId!: number;
    periodName!: string | undefined;
    peritodYear!: number;
    periodVersionId!: number;
    perisodVersionName!: string | undefined;

    constructor(data?: IPeriodAndVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.periodId = _data["periodId"];
            this.periodName = _data["periodName"];
            this.peritodYear = _data["peritodYear"];
            this.periodVersionId = _data["periodVersionId"];
            this.perisodVersionName = _data["perisodVersionName"];
        }
    }

    static fromJS(data: any): PeriodAndVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodAndVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["periodId"] = this.periodId;
        data["periodName"] = this.periodName;
        data["peritodYear"] = this.peritodYear;
        data["periodVersionId"] = this.periodVersionId;
        data["perisodVersionName"] = this.perisodVersionName;
        return data;
    }
}

export interface IPeriodAndVersionDto {
    periodId: number;
    periodName: string | undefined;
    peritodYear: number;
    periodVersionId: number;
    perisodVersionName: string | undefined;
}

export class BudgetTransferDto implements IBudgetTransferDto {
    id!: number;
    date!: DateTime | undefined;
    transferNo!: string | undefined;
    amountTransfer!: number;
    purpose!: string | undefined;
    status!: string | undefined;
    statusId!: number;
    fromBudgetCode!: string | undefined;
    fromBudgetName!: string | undefined;
    fromRemaining!: number;
    toBudgetCode!: string | undefined;
    toBudgetName!: string | undefined;
    toRemaining!: number;
    type!: string | undefined;
    typeId!: number;

    constructor(data?: IBudgetTransferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : <any>undefined;
            this.transferNo = _data["transferNo"];
            this.amountTransfer = _data["amountTransfer"];
            this.purpose = _data["purpose"];
            this.status = _data["status"];
            this.statusId = _data["statusId"];
            this.fromBudgetCode = _data["fromBudgetCode"];
            this.fromBudgetName = _data["fromBudgetName"];
            this.fromRemaining = _data["fromRemaining"];
            this.toBudgetCode = _data["toBudgetCode"];
            this.toBudgetName = _data["toBudgetName"];
            this.toRemaining = _data["toRemaining"];
            this.type = _data["type"];
            this.typeId = _data["typeId"];
        }
    }

    static fromJS(data: any): BudgetTransferDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetTransferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toString() : <any>undefined;
        data["transferNo"] = this.transferNo;
        data["amountTransfer"] = this.amountTransfer;
        data["purpose"] = this.purpose;
        data["status"] = this.status;
        data["statusId"] = this.statusId;
        data["fromBudgetCode"] = this.fromBudgetCode;
        data["fromBudgetName"] = this.fromBudgetName;
        data["fromRemaining"] = this.fromRemaining;
        data["toBudgetCode"] = this.toBudgetCode;
        data["toBudgetName"] = this.toBudgetName;
        data["toRemaining"] = this.toRemaining;
        data["type"] = this.type;
        data["typeId"] = this.typeId;
        return data;
    }
}

export interface IBudgetTransferDto {
    id: number;
    date: DateTime | undefined;
    transferNo: string | undefined;
    amountTransfer: number;
    purpose: string | undefined;
    status: string | undefined;
    statusId: number;
    fromBudgetCode: string | undefined;
    fromBudgetName: string | undefined;
    fromRemaining: number;
    toBudgetCode: string | undefined;
    toBudgetName: string | undefined;
    toRemaining: number;
    type: string | undefined;
    typeId: number;
}

export class PagedResultDtoOfBudgetTransferDto implements IPagedResultDtoOfBudgetTransferDto {
    totalCount!: number;
    items!: BudgetTransferDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBudgetTransferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BudgetTransferDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBudgetTransferDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBudgetTransferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBudgetTransferDto {
    totalCount: number;
    items: BudgetTransferDto[] | undefined;
}

export class BudgetTransferItemDto implements IBudgetTransferItemDto {
    id!: number;
    description!: string | undefined;
    amount!: number;
    remarks!: string | undefined;
    budgetTransferId!: number;

    constructor(data?: IBudgetTransferItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.amount = _data["amount"];
            this.remarks = _data["remarks"];
            this.budgetTransferId = _data["budgetTransferId"];
        }
    }

    static fromJS(data: any): BudgetTransferItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetTransferItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["amount"] = this.amount;
        data["remarks"] = this.remarks;
        data["budgetTransferId"] = this.budgetTransferId;
        return data;
    }
}

export interface IBudgetTransferItemDto {
    id: number;
    description: string | undefined;
    amount: number;
    remarks: string | undefined;
    budgetTransferId: number;
}

export class InputBudgetTransferDto implements IInputBudgetTransferDto {
    id!: number;
    date!: DateTime | undefined;
    transferNo!: string | undefined;
    fromDepId!: number;
    fromPICName!: string | undefined;
    fromPICNoEmail!: string | undefined;
    fromBudgetId!: number;
    fromRemaining!: number;
    budgetName1!: string | undefined;
    fromDepName!: string | undefined;
    toDepId!: number;
    toPICName!: string | undefined;
    toPICUserId!: number;
    toPICNoEmail!: string | undefined;
    toBudgetId!: number;
    toRemaining!: number;
    budgetName2!: string | undefined;
    toDepName!: string | undefined;
    amountTransfer!: number;
    purpose!: string | undefined;
    status!: number;
    type!: number;
    budgetTransferItemDtos!: BudgetTransferItemDto[] | undefined;

    constructor(data?: IInputBudgetTransferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : <any>undefined;
            this.transferNo = _data["transferNo"];
            this.fromDepId = _data["fromDepId"];
            this.fromPICName = _data["fromPICName"];
            this.fromPICNoEmail = _data["fromPICNoEmail"];
            this.fromBudgetId = _data["fromBudgetId"];
            this.fromRemaining = _data["fromRemaining"];
            this.budgetName1 = _data["budgetName1"];
            this.fromDepName = _data["fromDepName"];
            this.toDepId = _data["toDepId"];
            this.toPICName = _data["toPICName"];
            this.toPICUserId = _data["toPICUserId"];
            this.toPICNoEmail = _data["toPICNoEmail"];
            this.toBudgetId = _data["toBudgetId"];
            this.toRemaining = _data["toRemaining"];
            this.budgetName2 = _data["budgetName2"];
            this.toDepName = _data["toDepName"];
            this.amountTransfer = _data["amountTransfer"];
            this.purpose = _data["purpose"];
            this.status = _data["status"];
            this.type = _data["type"];
            if (Array.isArray(_data["budgetTransferItemDtos"])) {
                this.budgetTransferItemDtos = [] as any;
                for (let item of _data["budgetTransferItemDtos"])
                    this.budgetTransferItemDtos!.push(BudgetTransferItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InputBudgetTransferDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputBudgetTransferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toString() : <any>undefined;
        data["transferNo"] = this.transferNo;
        data["fromDepId"] = this.fromDepId;
        data["fromPICName"] = this.fromPICName;
        data["fromPICNoEmail"] = this.fromPICNoEmail;
        data["fromBudgetId"] = this.fromBudgetId;
        data["fromRemaining"] = this.fromRemaining;
        data["budgetName1"] = this.budgetName1;
        data["fromDepName"] = this.fromDepName;
        data["toDepId"] = this.toDepId;
        data["toPICName"] = this.toPICName;
        data["toPICUserId"] = this.toPICUserId;
        data["toPICNoEmail"] = this.toPICNoEmail;
        data["toBudgetId"] = this.toBudgetId;
        data["toRemaining"] = this.toRemaining;
        data["budgetName2"] = this.budgetName2;
        data["toDepName"] = this.toDepName;
        data["amountTransfer"] = this.amountTransfer;
        data["purpose"] = this.purpose;
        data["status"] = this.status;
        data["type"] = this.type;
        if (Array.isArray(this.budgetTransferItemDtos)) {
            data["budgetTransferItemDtos"] = [];
            for (let item of this.budgetTransferItemDtos)
                data["budgetTransferItemDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInputBudgetTransferDto {
    id: number;
    date: DateTime | undefined;
    transferNo: string | undefined;
    fromDepId: number;
    fromPICName: string | undefined;
    fromPICNoEmail: string | undefined;
    fromBudgetId: number;
    fromRemaining: number;
    budgetName1: string | undefined;
    fromDepName: string | undefined;
    toDepId: number;
    toPICName: string | undefined;
    toPICUserId: number;
    toPICNoEmail: string | undefined;
    toBudgetId: number;
    toRemaining: number;
    budgetName2: string | undefined;
    toDepName: string | undefined;
    amountTransfer: number;
    purpose: string | undefined;
    status: number;
    type: number;
    budgetTransferItemDtos: BudgetTransferItemDto[] | undefined;
}

export class UserInfoToTransferBudgetDto implements IUserInfoToTransferBudgetDto {
    id!: number;
    userName!: string | undefined;
    userEmail!: string | undefined;

    constructor(data?: IUserInfoToTransferBudgetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.userEmail = _data["userEmail"];
        }
    }

    static fromJS(data: any): UserInfoToTransferBudgetDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfoToTransferBudgetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["userEmail"] = this.userEmail;
        return data;
    }
}

export interface IUserInfoToTransferBudgetDto {
    id: number;
    userName: string | undefined;
    userEmail: string | undefined;
}

export class ApprovalTransferBudgetDto implements IApprovalTransferBudgetDto {
    transferBudgetId!: number;
    reasonReject!: string | undefined;

    constructor(data?: IApprovalTransferBudgetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transferBudgetId = _data["transferBudgetId"];
            this.reasonReject = _data["reasonReject"];
        }
    }

    static fromJS(data: any): ApprovalTransferBudgetDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalTransferBudgetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferBudgetId"] = this.transferBudgetId;
        data["reasonReject"] = this.reasonReject;
        return data;
    }
}

export interface IApprovalTransferBudgetDto {
    transferBudgetId: number;
    reasonReject: string | undefined;
}

export class BmsTransferBudget implements IBmsTransferBudget {
    date!: DateTime | undefined;
    transferNo!: string | undefined;
    fromDepId!: number;
    fromPICName!: string | undefined;
    fromPICNoEmail!: string | undefined;
    fromBudgetId!: number;
    fromRemaining!: number;
    toDepId!: number;
    toPICName!: string | undefined;
    toPICUserId!: number;
    toPICNoEmail!: string | undefined;
    toBudgetId!: number;
    toRemaining!: number;
    amountTransfer!: number;
    purpose!: string | undefined;
    status!: number;
    type!: number;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IBmsTransferBudget) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : <any>undefined;
            this.transferNo = _data["transferNo"];
            this.fromDepId = _data["fromDepId"];
            this.fromPICName = _data["fromPICName"];
            this.fromPICNoEmail = _data["fromPICNoEmail"];
            this.fromBudgetId = _data["fromBudgetId"];
            this.fromRemaining = _data["fromRemaining"];
            this.toDepId = _data["toDepId"];
            this.toPICName = _data["toPICName"];
            this.toPICUserId = _data["toPICUserId"];
            this.toPICNoEmail = _data["toPICNoEmail"];
            this.toBudgetId = _data["toBudgetId"];
            this.toRemaining = _data["toRemaining"];
            this.amountTransfer = _data["amountTransfer"];
            this.purpose = _data["purpose"];
            this.status = _data["status"];
            this.type = _data["type"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BmsTransferBudget {
        data = typeof data === 'object' ? data : {};
        let result = new BmsTransferBudget();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toString() : <any>undefined;
        data["transferNo"] = this.transferNo;
        data["fromDepId"] = this.fromDepId;
        data["fromPICName"] = this.fromPICName;
        data["fromPICNoEmail"] = this.fromPICNoEmail;
        data["fromBudgetId"] = this.fromBudgetId;
        data["fromRemaining"] = this.fromRemaining;
        data["toDepId"] = this.toDepId;
        data["toPICName"] = this.toPICName;
        data["toPICUserId"] = this.toPICUserId;
        data["toPICNoEmail"] = this.toPICNoEmail;
        data["toBudgetId"] = this.toBudgetId;
        data["toRemaining"] = this.toRemaining;
        data["amountTransfer"] = this.amountTransfer;
        data["purpose"] = this.purpose;
        data["status"] = this.status;
        data["type"] = this.type;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IBmsTransferBudget {
    date: DateTime | undefined;
    transferNo: string | undefined;
    fromDepId: number;
    fromPICName: string | undefined;
    fromPICNoEmail: string | undefined;
    fromBudgetId: number;
    fromRemaining: number;
    toDepId: number;
    toPICName: string | undefined;
    toPICUserId: number;
    toPICNoEmail: string | undefined;
    toBudgetId: number;
    toRemaining: number;
    amountTransfer: number;
    purpose: string | undefined;
    status: number;
    type: number;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class CacheDto implements ICacheDto {
    name!: string | undefined;

    constructor(data?: ICacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new CacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICacheDto {
    name: string | undefined;
}

export class ListResultDtoOfCacheDto implements IListResultDtoOfCacheDto {
    items!: CacheDto[] | undefined;

    constructor(data?: IListResultDtoOfCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfCacheDto {
    items: CacheDto[] | undefined;
}

export class EntityDtoOfString implements IEntityDtoOfString {
    id!: string | undefined;

    constructor(data?: IEntityDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityDtoOfString {
    id: string | undefined;
}

export class EmailTemplateOuputDto implements IEmailTemplateOuputDto {
    emailTemplateContent!: string | undefined;

    constructor(data?: IEmailTemplateOuputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailTemplateContent = _data["emailTemplateContent"];
        }
    }

    static fromJS(data: any): EmailTemplateOuputDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailTemplateOuputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailTemplateContent"] = this.emailTemplateContent;
        return data;
    }
}

export interface IEmailTemplateOuputDto {
    emailTemplateContent: string | undefined;
}

export enum MemberTypes {
    Constructor = 1,
    Event = 2,
    Field = 4,
    Method = 8,
    Property = 16,
    TypeInfo = 32,
    Custom = 64,
    NestedType = 128,
    All = 191,
}

export enum PropertyAttributes {
    None = 0,
    SpecialName = 512,
    RTSpecialName = 1024,
    HasDefault = 4096,
    Reserved2 = 8192,
    Reserved3 = 16384,
    Reserved4 = 32768,
    ReservedMask = 62464,
}

export enum ParameterAttributes {
    None = 0,
    In = 1,
    Out = 2,
    Lcid = 4,
    Retval = 8,
    Optional = 16,
    HasDefault = 4096,
    HasFieldMarshal = 8192,
    Reserved3 = 16384,
    Reserved4 = 32768,
    ReservedMask = 61440,
}

export enum MethodAttributes {
    ReuseSlot = 0,
    PrivateScope = 1,
    Private = 2,
    FamANDAssem = 3,
    Assembly = 4,
    Family = 5,
    FamORAssem = 6,
    Public = 7,
    MemberAccessMask = 8,
    UnmanagedExport = 16,
    Static = 32,
    Final = 64,
    Virtual = 128,
    HideBySig = 256,
    NewSlot = 512,
    VtableLayoutMask = 1024,
    CheckAccessOnOverride = 2048,
    Abstract = 4096,
    SpecialName = 8192,
    RTSpecialName = 16384,
    PinvokeImpl = 32768,
    HasSecurity = 53248,
}

export enum MethodImplAttributes {
    IL = 0,
    Managed = 1,
    Native = 2,
    OPTIL = 3,
    Runtime = 4,
    CodeTypeMask = 8,
    Unmanaged = 16,
    ManagedMask = 32,
    NoInlining = 64,
    ForwardRef = 128,
    Synchronized = 256,
    NoOptimization = 512,
    PreserveSig = 4096,
    AggressiveInlining = 65535,
}

export enum CallingConventions {
    Standard = 1,
    VarArgs = 2,
    Any = 3,
    HasThis = 32,
    ExplicitThis = 64,
}

export class RuntimeMethodHandle implements IRuntimeMethodHandle {
    readonly value!: any;

    constructor(data?: IRuntimeMethodHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).value = _data["value"];
        }
    }

    static fromJS(data: any): RuntimeMethodHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeMethodHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

export interface IRuntimeMethodHandle {
    value: any;
}

export class ConstructorInfo implements IConstructorInfo {
    memberType!: MemberTypes;
    attributes!: MethodAttributes;
    methodImplementationFlags!: MethodImplAttributes;
    callingConvention!: CallingConventions;
    readonly isAbstract!: boolean;
    readonly isConstructor!: boolean;
    readonly isFinal!: boolean;
    readonly isHideBySig!: boolean;
    readonly isSpecialName!: boolean;
    readonly isStatic!: boolean;
    readonly isVirtual!: boolean;
    readonly isAssembly!: boolean;
    readonly isFamily!: boolean;
    readonly isFamilyAndAssembly!: boolean;
    readonly isFamilyOrAssembly!: boolean;
    readonly isPrivate!: boolean;
    readonly isPublic!: boolean;
    readonly isConstructedGenericMethod!: boolean;
    readonly isGenericMethod!: boolean;
    readonly isGenericMethodDefinition!: boolean;
    readonly containsGenericParameters!: boolean;
    methodHandle!: RuntimeMethodHandle;
    readonly isSecurityCritical!: boolean;
    readonly isSecuritySafeCritical!: boolean;
    readonly isSecurityTransparent!: boolean;
    readonly name!: string | undefined;
    readonly declaringType!: string | undefined;
    readonly reflectedType!: string | undefined;
    module!: Module;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly isCollectible!: boolean;
    readonly metadataToken!: number;

    constructor(data?: IConstructorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            this.attributes = _data["attributes"];
            this.methodImplementationFlags = _data["methodImplementationFlags"];
            this.callingConvention = _data["callingConvention"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isConstructor = _data["isConstructor"];
            (<any>this).isFinal = _data["isFinal"];
            (<any>this).isHideBySig = _data["isHideBySig"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isVirtual = _data["isVirtual"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isConstructedGenericMethod = _data["isConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["isGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["isGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            this.methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            (<any>this).name = _data["name"];
            (<any>this).declaringType = _data["declaringType"];
            (<any>this).reflectedType = _data["reflectedType"];
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): ConstructorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ConstructorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["attributes"] = this.attributes;
        data["methodImplementationFlags"] = this.methodImplementationFlags;
        data["callingConvention"] = this.callingConvention;
        data["isAbstract"] = this.isAbstract;
        data["isConstructor"] = this.isConstructor;
        data["isFinal"] = this.isFinal;
        data["isHideBySig"] = this.isHideBySig;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isVirtual"] = this.isVirtual;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["isGenericMethod"] = this.isGenericMethod;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType;
        data["reflectedType"] = this.reflectedType;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IConstructorInfo {
    memberType: MemberTypes;
    attributes: MethodAttributes;
    methodImplementationFlags: MethodImplAttributes;
    callingConvention: CallingConventions;
    isAbstract: boolean;
    isConstructor: boolean;
    isFinal: boolean;
    isHideBySig: boolean;
    isSpecialName: boolean;
    isStatic: boolean;
    isVirtual: boolean;
    isAssembly: boolean;
    isFamily: boolean;
    isFamilyAndAssembly: boolean;
    isFamilyOrAssembly: boolean;
    isPrivate: boolean;
    isPublic: boolean;
    isConstructedGenericMethod: boolean;
    isGenericMethod: boolean;
    isGenericMethodDefinition: boolean;
    containsGenericParameters: boolean;
    methodHandle: RuntimeMethodHandle;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
    name: string | undefined;
    declaringType: string | undefined;
    reflectedType: string | undefined;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export class CustomAttributeTypedArgument implements ICustomAttributeTypedArgument {
    argumentType!: string | undefined;
    value!: any | undefined;

    constructor(data?: ICustomAttributeTypedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.argumentType = _data["argumentType"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CustomAttributeTypedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeTypedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["argumentType"] = this.argumentType;
        data["value"] = this.value;
        return data;
    }
}

export interface ICustomAttributeTypedArgument {
    argumentType: string | undefined;
    value: any | undefined;
}

export class CustomAttributeNamedArgument implements ICustomAttributeNamedArgument {
    memberInfo!: MemberInfo;
    typedValue!: CustomAttributeTypedArgument;
    readonly memberName!: string | undefined;
    readonly isField!: boolean;

    constructor(data?: ICustomAttributeNamedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberInfo = _data["memberInfo"] ? MemberInfo.fromJS(_data["memberInfo"]) : <any>undefined;
            this.typedValue = _data["typedValue"] ? CustomAttributeTypedArgument.fromJS(_data["typedValue"]) : <any>undefined;
            (<any>this).memberName = _data["memberName"];
            (<any>this).isField = _data["isField"];
        }
    }

    static fromJS(data: any): CustomAttributeNamedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeNamedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberInfo"] = this.memberInfo ? this.memberInfo.toJSON() : <any>undefined;
        data["typedValue"] = this.typedValue ? this.typedValue.toJSON() : <any>undefined;
        data["memberName"] = this.memberName;
        data["isField"] = this.isField;
        return data;
    }
}

export interface ICustomAttributeNamedArgument {
    memberInfo: MemberInfo;
    typedValue: CustomAttributeTypedArgument;
    memberName: string | undefined;
    isField: boolean;
}

export class CustomAttributeData implements ICustomAttributeData {
    readonly attributeType!: string | undefined;
    constructor_!: ConstructorInfo;
    readonly constructorArguments!: CustomAttributeTypedArgument[] | undefined;
    readonly namedArguments!: CustomAttributeNamedArgument[] | undefined;

    constructor(data?: ICustomAttributeData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).attributeType = _data["attributeType"];
            this.constructor_ = _data["constructor"] ? ConstructorInfo.fromJS(_data["constructor"]) : <any>undefined;
            if (Array.isArray(_data["constructorArguments"])) {
                (<any>this).constructorArguments = [] as any;
                for (let item of _data["constructorArguments"])
                    (<any>this).constructorArguments!.push(CustomAttributeTypedArgument.fromJS(item));
            }
            if (Array.isArray(_data["namedArguments"])) {
                (<any>this).namedArguments = [] as any;
                for (let item of _data["namedArguments"])
                    (<any>this).namedArguments!.push(CustomAttributeNamedArgument.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomAttributeData {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeType"] = this.attributeType;
        data["constructor"] = this.constructor_ ? this.constructor_.toJSON() : <any>undefined;
        if (Array.isArray(this.constructorArguments)) {
            data["constructorArguments"] = [];
            for (let item of this.constructorArguments)
                data["constructorArguments"].push(item.toJSON());
        }
        if (Array.isArray(this.namedArguments)) {
            data["namedArguments"] = [];
            for (let item of this.namedArguments)
                data["namedArguments"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICustomAttributeData {
    attributeType: string | undefined;
    constructor_: ConstructorInfo;
    constructorArguments: CustomAttributeTypedArgument[] | undefined;
    namedArguments: CustomAttributeNamedArgument[] | undefined;
}

export enum SecurityRuleSet {
    None = 0,
    Level1 = 1,
    Level2 = 2,
}

export class Assembly implements IAssembly {
    readonly definedTypes!: string[] | undefined;
    readonly exportedTypes!: string[] | undefined;
    readonly codeBase!: string | undefined;
    entryPoint!: MethodInfo;
    readonly fullName!: string | undefined;
    readonly imageRuntimeVersion!: string | undefined;
    readonly isDynamic!: boolean;
    readonly location!: string | undefined;
    readonly reflectionOnly!: boolean;
    readonly isCollectible!: boolean;
    readonly isFullyTrusted!: boolean;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly escapedCodeBase!: string | undefined;
    manifestModule!: Module;
    readonly modules!: Module[] | undefined;
    readonly globalAssemblyCache!: boolean;
    readonly hostContext!: number;
    securityRuleSet!: SecurityRuleSet;

    constructor(data?: IAssembly) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["definedTypes"])) {
                (<any>this).definedTypes = [] as any;
                for (let item of _data["definedTypes"])
                    (<any>this).definedTypes!.push(item);
            }
            if (Array.isArray(_data["exportedTypes"])) {
                (<any>this).exportedTypes = [] as any;
                for (let item of _data["exportedTypes"])
                    (<any>this).exportedTypes!.push(item);
            }
            (<any>this).codeBase = _data["codeBase"];
            this.entryPoint = _data["entryPoint"] ? MethodInfo.fromJS(_data["entryPoint"]) : <any>undefined;
            (<any>this).fullName = _data["fullName"];
            (<any>this).imageRuntimeVersion = _data["imageRuntimeVersion"];
            (<any>this).isDynamic = _data["isDynamic"];
            (<any>this).location = _data["location"];
            (<any>this).reflectionOnly = _data["reflectionOnly"];
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).isFullyTrusted = _data["isFullyTrusted"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).escapedCodeBase = _data["escapedCodeBase"];
            this.manifestModule = _data["manifestModule"] ? Module.fromJS(_data["manifestModule"]) : <any>undefined;
            if (Array.isArray(_data["modules"])) {
                (<any>this).modules = [] as any;
                for (let item of _data["modules"])
                    (<any>this).modules!.push(Module.fromJS(item));
            }
            (<any>this).globalAssemblyCache = _data["globalAssemblyCache"];
            (<any>this).hostContext = _data["hostContext"];
            this.securityRuleSet = _data["securityRuleSet"];
        }
    }

    static fromJS(data: any): Assembly {
        data = typeof data === 'object' ? data : {};
        let result = new Assembly();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.definedTypes)) {
            data["definedTypes"] = [];
            for (let item of this.definedTypes)
                data["definedTypes"].push(item);
        }
        if (Array.isArray(this.exportedTypes)) {
            data["exportedTypes"] = [];
            for (let item of this.exportedTypes)
                data["exportedTypes"].push(item);
        }
        data["codeBase"] = this.codeBase;
        data["entryPoint"] = this.entryPoint ? this.entryPoint.toJSON() : <any>undefined;
        data["fullName"] = this.fullName;
        data["imageRuntimeVersion"] = this.imageRuntimeVersion;
        data["isDynamic"] = this.isDynamic;
        data["location"] = this.location;
        data["reflectionOnly"] = this.reflectionOnly;
        data["isCollectible"] = this.isCollectible;
        data["isFullyTrusted"] = this.isFullyTrusted;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["escapedCodeBase"] = this.escapedCodeBase;
        data["manifestModule"] = this.manifestModule ? this.manifestModule.toJSON() : <any>undefined;
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        data["globalAssemblyCache"] = this.globalAssemblyCache;
        data["hostContext"] = this.hostContext;
        data["securityRuleSet"] = this.securityRuleSet;
        return data;
    }
}

export interface IAssembly {
    definedTypes: string[] | undefined;
    exportedTypes: string[] | undefined;
    codeBase: string | undefined;
    entryPoint: MethodInfo;
    fullName: string | undefined;
    imageRuntimeVersion: string | undefined;
    isDynamic: boolean;
    location: string | undefined;
    reflectionOnly: boolean;
    isCollectible: boolean;
    isFullyTrusted: boolean;
    customAttributes: CustomAttributeData[] | undefined;
    escapedCodeBase: string | undefined;
    manifestModule: Module;
    modules: Module[] | undefined;
    globalAssemblyCache: boolean;
    hostContext: number;
    securityRuleSet: SecurityRuleSet;
}

export class ModuleHandle implements IModuleHandle {
    readonly mdStreamVersion!: number;

    constructor(data?: IModuleHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).mdStreamVersion = _data["mdStreamVersion"];
        }
    }

    static fromJS(data: any): ModuleHandle {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mdStreamVersion"] = this.mdStreamVersion;
        return data;
    }
}

export interface IModuleHandle {
    mdStreamVersion: number;
}

export class Module implements IModule {
    assembly!: Assembly;
    readonly fullyQualifiedName!: string | undefined;
    readonly name!: string | undefined;
    readonly mdStreamVersion!: number;
    readonly moduleVersionId!: string;
    readonly scopeName!: string | undefined;
    moduleHandle!: ModuleHandle;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly metadataToken!: number;

    constructor(data?: IModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assembly = _data["assembly"] ? Assembly.fromJS(_data["assembly"]) : <any>undefined;
            (<any>this).fullyQualifiedName = _data["fullyQualifiedName"];
            (<any>this).name = _data["name"];
            (<any>this).mdStreamVersion = _data["mdStreamVersion"];
            (<any>this).moduleVersionId = _data["moduleVersionId"];
            (<any>this).scopeName = _data["scopeName"];
            this.moduleHandle = _data["moduleHandle"] ? ModuleHandle.fromJS(_data["moduleHandle"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): Module {
        data = typeof data === 'object' ? data : {};
        let result = new Module();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["fullyQualifiedName"] = this.fullyQualifiedName;
        data["name"] = this.name;
        data["mdStreamVersion"] = this.mdStreamVersion;
        data["moduleVersionId"] = this.moduleVersionId;
        data["scopeName"] = this.scopeName;
        data["moduleHandle"] = this.moduleHandle ? this.moduleHandle.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IModule {
    assembly: Assembly;
    fullyQualifiedName: string | undefined;
    name: string | undefined;
    mdStreamVersion: number;
    moduleVersionId: string;
    scopeName: string | undefined;
    moduleHandle: ModuleHandle;
    customAttributes: CustomAttributeData[] | undefined;
    metadataToken: number;
}

export class MemberInfo implements IMemberInfo {
    memberType!: MemberTypes;
    readonly name!: string | undefined;
    readonly declaringType!: string | undefined;
    readonly reflectedType!: string | undefined;
    module!: Module;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly isCollectible!: boolean;
    readonly metadataToken!: number;

    constructor(data?: IMemberInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            (<any>this).name = _data["name"];
            (<any>this).declaringType = _data["declaringType"];
            (<any>this).reflectedType = _data["reflectedType"];
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): MemberInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MemberInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType;
        data["reflectedType"] = this.reflectedType;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IMemberInfo {
    memberType: MemberTypes;
    name: string | undefined;
    declaringType: string | undefined;
    reflectedType: string | undefined;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export class ParameterInfo implements IParameterInfo {
    attributes!: ParameterAttributes;
    member!: MemberInfo;
    readonly name!: string | undefined;
    readonly parameterType!: string | undefined;
    readonly position!: number;
    readonly isIn!: boolean;
    readonly isLcid!: boolean;
    readonly isOptional!: boolean;
    readonly isOut!: boolean;
    readonly isRetval!: boolean;
    readonly defaultValue!: any | undefined;
    readonly rawDefaultValue!: any | undefined;
    readonly hasDefaultValue!: boolean;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly metadataToken!: number;

    constructor(data?: IParameterInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributes = _data["attributes"];
            this.member = _data["member"] ? MemberInfo.fromJS(_data["member"]) : <any>undefined;
            (<any>this).name = _data["name"];
            (<any>this).parameterType = _data["parameterType"];
            (<any>this).position = _data["position"];
            (<any>this).isIn = _data["isIn"];
            (<any>this).isLcid = _data["isLcid"];
            (<any>this).isOptional = _data["isOptional"];
            (<any>this).isOut = _data["isOut"];
            (<any>this).isRetval = _data["isRetval"];
            (<any>this).defaultValue = _data["defaultValue"];
            (<any>this).rawDefaultValue = _data["rawDefaultValue"];
            (<any>this).hasDefaultValue = _data["hasDefaultValue"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): ParameterInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributes"] = this.attributes;
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["parameterType"] = this.parameterType;
        data["position"] = this.position;
        data["isIn"] = this.isIn;
        data["isLcid"] = this.isLcid;
        data["isOptional"] = this.isOptional;
        data["isOut"] = this.isOut;
        data["isRetval"] = this.isRetval;
        data["defaultValue"] = this.defaultValue;
        data["rawDefaultValue"] = this.rawDefaultValue;
        data["hasDefaultValue"] = this.hasDefaultValue;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IParameterInfo {
    attributes: ParameterAttributes;
    member: MemberInfo;
    name: string | undefined;
    parameterType: string | undefined;
    position: number;
    isIn: boolean;
    isLcid: boolean;
    isOptional: boolean;
    isOut: boolean;
    isRetval: boolean;
    defaultValue: any | undefined;
    rawDefaultValue: any | undefined;
    hasDefaultValue: boolean;
    customAttributes: CustomAttributeData[] | undefined;
    metadataToken: number;
}

export class ICustomAttributeProvider implements IICustomAttributeProvider {

    constructor(data?: IICustomAttributeProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ICustomAttributeProvider {
        data = typeof data === 'object' ? data : {};
        let result = new ICustomAttributeProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IICustomAttributeProvider {
}

export class MethodInfo implements IMethodInfo {
    memberType!: MemberTypes;
    returnParameter!: ParameterInfo;
    readonly returnType!: string | undefined;
    returnTypeCustomAttributes!: ICustomAttributeProvider;
    attributes!: MethodAttributes;
    methodImplementationFlags!: MethodImplAttributes;
    callingConvention!: CallingConventions;
    readonly isAbstract!: boolean;
    readonly isConstructor!: boolean;
    readonly isFinal!: boolean;
    readonly isHideBySig!: boolean;
    readonly isSpecialName!: boolean;
    readonly isStatic!: boolean;
    readonly isVirtual!: boolean;
    readonly isAssembly!: boolean;
    readonly isFamily!: boolean;
    readonly isFamilyAndAssembly!: boolean;
    readonly isFamilyOrAssembly!: boolean;
    readonly isPrivate!: boolean;
    readonly isPublic!: boolean;
    readonly isConstructedGenericMethod!: boolean;
    readonly isGenericMethod!: boolean;
    readonly isGenericMethodDefinition!: boolean;
    readonly containsGenericParameters!: boolean;
    methodHandle!: RuntimeMethodHandle;
    readonly isSecurityCritical!: boolean;
    readonly isSecuritySafeCritical!: boolean;
    readonly isSecurityTransparent!: boolean;
    readonly name!: string | undefined;
    readonly declaringType!: string | undefined;
    readonly reflectedType!: string | undefined;
    module!: Module;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly isCollectible!: boolean;
    readonly metadataToken!: number;

    constructor(data?: IMethodInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            this.returnParameter = _data["returnParameter"] ? ParameterInfo.fromJS(_data["returnParameter"]) : <any>undefined;
            (<any>this).returnType = _data["returnType"];
            this.returnTypeCustomAttributes = _data["returnTypeCustomAttributes"] ? ICustomAttributeProvider.fromJS(_data["returnTypeCustomAttributes"]) : <any>undefined;
            this.attributes = _data["attributes"];
            this.methodImplementationFlags = _data["methodImplementationFlags"];
            this.callingConvention = _data["callingConvention"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isConstructor = _data["isConstructor"];
            (<any>this).isFinal = _data["isFinal"];
            (<any>this).isHideBySig = _data["isHideBySig"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isVirtual = _data["isVirtual"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isConstructedGenericMethod = _data["isConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["isGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["isGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            this.methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            (<any>this).name = _data["name"];
            (<any>this).declaringType = _data["declaringType"];
            (<any>this).reflectedType = _data["reflectedType"];
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): MethodInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MethodInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["returnParameter"] = this.returnParameter ? this.returnParameter.toJSON() : <any>undefined;
        data["returnType"] = this.returnType;
        data["returnTypeCustomAttributes"] = this.returnTypeCustomAttributes ? this.returnTypeCustomAttributes.toJSON() : <any>undefined;
        data["attributes"] = this.attributes;
        data["methodImplementationFlags"] = this.methodImplementationFlags;
        data["callingConvention"] = this.callingConvention;
        data["isAbstract"] = this.isAbstract;
        data["isConstructor"] = this.isConstructor;
        data["isFinal"] = this.isFinal;
        data["isHideBySig"] = this.isHideBySig;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isVirtual"] = this.isVirtual;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["isGenericMethod"] = this.isGenericMethod;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType;
        data["reflectedType"] = this.reflectedType;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IMethodInfo {
    memberType: MemberTypes;
    returnParameter: ParameterInfo;
    returnType: string | undefined;
    returnTypeCustomAttributes: ICustomAttributeProvider;
    attributes: MethodAttributes;
    methodImplementationFlags: MethodImplAttributes;
    callingConvention: CallingConventions;
    isAbstract: boolean;
    isConstructor: boolean;
    isFinal: boolean;
    isHideBySig: boolean;
    isSpecialName: boolean;
    isStatic: boolean;
    isVirtual: boolean;
    isAssembly: boolean;
    isFamily: boolean;
    isFamilyAndAssembly: boolean;
    isFamilyOrAssembly: boolean;
    isPrivate: boolean;
    isPublic: boolean;
    isConstructedGenericMethod: boolean;
    isGenericMethod: boolean;
    isGenericMethodDefinition: boolean;
    containsGenericParameters: boolean;
    methodHandle: RuntimeMethodHandle;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
    name: string | undefined;
    declaringType: string | undefined;
    reflectedType: string | undefined;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export class PropertyInfo implements IPropertyInfo {
    memberType!: MemberTypes;
    readonly propertyType!: string | undefined;
    attributes!: PropertyAttributes;
    readonly isSpecialName!: boolean;
    readonly canRead!: boolean;
    readonly canWrite!: boolean;
    getMethod!: MethodInfo;
    setMethod!: MethodInfo;
    readonly name!: string | undefined;
    readonly declaringType!: string | undefined;
    readonly reflectedType!: string | undefined;
    module!: Module;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly isCollectible!: boolean;
    readonly metadataToken!: number;

    constructor(data?: IPropertyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            (<any>this).propertyType = _data["propertyType"];
            this.attributes = _data["attributes"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).canRead = _data["canRead"];
            (<any>this).canWrite = _data["canWrite"];
            this.getMethod = _data["getMethod"] ? MethodInfo.fromJS(_data["getMethod"]) : <any>undefined;
            this.setMethod = _data["setMethod"] ? MethodInfo.fromJS(_data["setMethod"]) : <any>undefined;
            (<any>this).name = _data["name"];
            (<any>this).declaringType = _data["declaringType"];
            (<any>this).reflectedType = _data["reflectedType"];
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): PropertyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["propertyType"] = this.propertyType;
        data["attributes"] = this.attributes;
        data["isSpecialName"] = this.isSpecialName;
        data["canRead"] = this.canRead;
        data["canWrite"] = this.canWrite;
        data["getMethod"] = this.getMethod ? this.getMethod.toJSON() : <any>undefined;
        data["setMethod"] = this.setMethod ? this.setMethod.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType;
        data["reflectedType"] = this.reflectedType;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IPropertyInfo {
    memberType: MemberTypes;
    propertyType: string | undefined;
    attributes: PropertyAttributes;
    isSpecialName: boolean;
    canRead: boolean;
    canWrite: boolean;
    getMethod: MethodInfo;
    setMethod: MethodInfo;
    name: string | undefined;
    declaringType: string | undefined;
    reflectedType: string | undefined;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export enum FriendshipState {
    Accepted = 1,
    Blocked = 2,
}

export class FriendDto implements IFriendDto {
    friendUserId!: number;
    friendTenantId!: number | undefined;
    friendUserName!: string | undefined;
    friendTenancyName!: string | undefined;
    friendProfilePictureId!: string | undefined;
    unreadMessageCount!: number;
    isOnline!: boolean;
    state!: FriendshipState;

    constructor(data?: IFriendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.friendUserId = _data["friendUserId"];
            this.friendTenantId = _data["friendTenantId"];
            this.friendUserName = _data["friendUserName"];
            this.friendTenancyName = _data["friendTenancyName"];
            this.friendProfilePictureId = _data["friendProfilePictureId"];
            this.unreadMessageCount = _data["unreadMessageCount"];
            this.isOnline = _data["isOnline"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): FriendDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendUserId"] = this.friendUserId;
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserName"] = this.friendUserName;
        data["friendTenancyName"] = this.friendTenancyName;
        data["friendProfilePictureId"] = this.friendProfilePictureId;
        data["unreadMessageCount"] = this.unreadMessageCount;
        data["isOnline"] = this.isOnline;
        data["state"] = this.state;
        return data;
    }
}

export interface IFriendDto {
    friendUserId: number;
    friendTenantId: number | undefined;
    friendUserName: string | undefined;
    friendTenancyName: string | undefined;
    friendProfilePictureId: string | undefined;
    unreadMessageCount: number;
    isOnline: boolean;
    state: FriendshipState;
}

export class GetUserChatFriendsWithSettingsOutput implements IGetUserChatFriendsWithSettingsOutput {
    serverTime!: DateTime;
    friends!: FriendDto[] | undefined;

    constructor(data?: IGetUserChatFriendsWithSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverTime = _data["serverTime"] ? DateTime.fromISO(_data["serverTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["friends"])) {
                this.friends = [] as any;
                for (let item of _data["friends"])
                    this.friends!.push(FriendDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserChatFriendsWithSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverTime"] = this.serverTime ? this.serverTime.toString() : <any>undefined;
        if (Array.isArray(this.friends)) {
            data["friends"] = [];
            for (let item of this.friends)
                data["friends"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetUserChatFriendsWithSettingsOutput {
    serverTime: DateTime;
    friends: FriendDto[] | undefined;
}

export enum ChatSide {
    Sender = 1,
    Receiver = 2,
}

export enum ChatMessageReadState {
    Unread = 1,
    Read = 2,
}

export class ChatMessageDto implements IChatMessageDto {
    userId!: number;
    tenantId!: number | undefined;
    targetUserId!: number;
    targetTenantId!: number | undefined;
    side!: ChatSide;
    readState!: ChatMessageReadState;
    receiverReadState!: ChatMessageReadState;
    message!: string | undefined;
    creationTime!: DateTime;
    sharedMessageId!: string | undefined;
    id!: number;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.targetUserId = _data["targetUserId"];
            this.targetTenantId = _data["targetTenantId"];
            this.side = _data["side"];
            this.readState = _data["readState"];
            this.receiverReadState = _data["receiverReadState"];
            this.message = _data["message"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.sharedMessageId = _data["sharedMessageId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["targetUserId"] = this.targetUserId;
        data["targetTenantId"] = this.targetTenantId;
        data["side"] = this.side;
        data["readState"] = this.readState;
        data["receiverReadState"] = this.receiverReadState;
        data["message"] = this.message;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["sharedMessageId"] = this.sharedMessageId;
        data["id"] = this.id;
        return data;
    }
}

export interface IChatMessageDto {
    userId: number;
    tenantId: number | undefined;
    targetUserId: number;
    targetTenantId: number | undefined;
    side: ChatSide;
    readState: ChatMessageReadState;
    receiverReadState: ChatMessageReadState;
    message: string | undefined;
    creationTime: DateTime;
    sharedMessageId: string | undefined;
    id: number;
}

export class ListResultDtoOfChatMessageDto implements IListResultDtoOfChatMessageDto {
    items!: ChatMessageDto[] | undefined;

    constructor(data?: IListResultDtoOfChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ChatMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfChatMessageDto {
    items: ChatMessageDto[] | undefined;
}

export class MarkAllUnreadMessagesOfUserAsReadInput implements IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId!: number | undefined;
    userId!: number;

    constructor(data?: IMarkAllUnreadMessagesOfUserAsReadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): MarkAllUnreadMessagesOfUserAsReadInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number | undefined;
    userId: number;
}

export class CommonAllInventoryGroup implements ICommonAllInventoryGroup {
    productGroupName!: string | undefined;
    productGroupCode!: string | undefined;
    id!: number;

    constructor(data?: ICommonAllInventoryGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productGroupName = _data["productGroupName"];
            this.productGroupCode = _data["productGroupCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CommonAllInventoryGroup {
        data = typeof data === 'object' ? data : {};
        let result = new CommonAllInventoryGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productGroupName"] = this.productGroupName;
        data["productGroupCode"] = this.productGroupCode;
        data["id"] = this.id;
        return data;
    }
}

export interface ICommonAllInventoryGroup {
    productGroupName: string | undefined;
    productGroupCode: string | undefined;
    id: number;
}

export class CommonAllCurrency implements ICommonAllCurrency {
    currencyCode!: string | undefined;
    name!: string | undefined;
    enabledFlag!: number;
    startDateActive!: DateTime | undefined;
    endDateActive!: DateTime | undefined;
    id!: number;

    constructor(data?: ICommonAllCurrency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currencyCode = _data["currencyCode"];
            this.name = _data["name"];
            this.enabledFlag = _data["enabledFlag"];
            this.startDateActive = _data["startDateActive"] ? DateTime.fromISO(_data["startDateActive"].toString()) : <any>undefined;
            this.endDateActive = _data["endDateActive"] ? DateTime.fromISO(_data["endDateActive"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CommonAllCurrency {
        data = typeof data === 'object' ? data : {};
        let result = new CommonAllCurrency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currencyCode"] = this.currencyCode;
        data["name"] = this.name;
        data["enabledFlag"] = this.enabledFlag;
        data["startDateActive"] = this.startDateActive ? this.startDateActive.toString() : <any>undefined;
        data["endDateActive"] = this.endDateActive ? this.endDateActive.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ICommonAllCurrency {
    currencyCode: string | undefined;
    name: string | undefined;
    enabledFlag: number;
    startDateActive: DateTime | undefined;
    endDateActive: DateTime | undefined;
    id: number;
}

export class CommonAllSupplier implements ICommonAllSupplier {
    supplierName!: string | undefined;
    supplierNumber!: string | undefined;
    vatRegistrationNum!: string | undefined;
    taxPayerId!: string | undefined;
    registryId!: number | undefined;
    startDateActive!: DateTime | undefined;
    endDateActive!: DateTime | undefined;
    id!: number;

    constructor(data?: ICommonAllSupplier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supplierName = _data["supplierName"];
            this.supplierNumber = _data["supplierNumber"];
            this.vatRegistrationNum = _data["vatRegistrationNum"];
            this.taxPayerId = _data["taxPayerId"];
            this.registryId = _data["registryId"];
            this.startDateActive = _data["startDateActive"] ? DateTime.fromISO(_data["startDateActive"].toString()) : <any>undefined;
            this.endDateActive = _data["endDateActive"] ? DateTime.fromISO(_data["endDateActive"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CommonAllSupplier {
        data = typeof data === 'object' ? data : {};
        let result = new CommonAllSupplier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supplierName"] = this.supplierName;
        data["supplierNumber"] = this.supplierNumber;
        data["vatRegistrationNum"] = this.vatRegistrationNum;
        data["taxPayerId"] = this.taxPayerId;
        data["registryId"] = this.registryId;
        data["startDateActive"] = this.startDateActive ? this.startDateActive.toString() : <any>undefined;
        data["endDateActive"] = this.endDateActive ? this.endDateActive.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ICommonAllSupplier {
    supplierName: string | undefined;
    supplierNumber: string | undefined;
    vatRegistrationNum: string | undefined;
    taxPayerId: string | undefined;
    registryId: number | undefined;
    startDateActive: DateTime | undefined;
    endDateActive: DateTime | undefined;
    id: number;
}

export class CommonAllSupplierSite implements ICommonAllSupplierSite {
    country!: string | undefined;
    invoiceCurrencyCode!: string | undefined;
    paymentCurrencyCode!: string | undefined;
    supplierId!: number;
    vendorSiteCode!: string | undefined;
    purchasingSiteFlag!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    isDefault!: boolean | undefined;
    id!: number;

    constructor(data?: ICommonAllSupplierSite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.country = _data["country"];
            this.invoiceCurrencyCode = _data["invoiceCurrencyCode"];
            this.paymentCurrencyCode = _data["paymentCurrencyCode"];
            this.supplierId = _data["supplierId"];
            this.vendorSiteCode = _data["vendorSiteCode"];
            this.purchasingSiteFlag = _data["purchasingSiteFlag"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.isDefault = _data["isDefault"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CommonAllSupplierSite {
        data = typeof data === 'object' ? data : {};
        let result = new CommonAllSupplierSite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["country"] = this.country;
        data["invoiceCurrencyCode"] = this.invoiceCurrencyCode;
        data["paymentCurrencyCode"] = this.paymentCurrencyCode;
        data["supplierId"] = this.supplierId;
        data["vendorSiteCode"] = this.vendorSiteCode;
        data["purchasingSiteFlag"] = this.purchasingSiteFlag;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["isDefault"] = this.isDefault;
        data["id"] = this.id;
        return data;
    }
}

export interface ICommonAllSupplierSite {
    country: string | undefined;
    invoiceCurrencyCode: string | undefined;
    paymentCurrencyCode: string | undefined;
    supplierId: number;
    vendorSiteCode: string | undefined;
    purchasingSiteFlag: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    isDefault: boolean | undefined;
    id: number;
}

export class CommonAllLineType implements ICommonAllLineType {
    lineTypeCode!: string | undefined;
    lineTypeName!: string | undefined;
    id!: number;

    constructor(data?: ICommonAllLineType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lineTypeCode = _data["lineTypeCode"];
            this.lineTypeName = _data["lineTypeName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CommonAllLineType {
        data = typeof data === 'object' ? data : {};
        let result = new CommonAllLineType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lineTypeCode"] = this.lineTypeCode;
        data["lineTypeName"] = this.lineTypeName;
        data["id"] = this.id;
        return data;
    }
}

export interface ICommonAllLineType {
    lineTypeCode: string | undefined;
    lineTypeName: string | undefined;
    id: number;
}

export class GetMstLocationsDto implements IGetMstLocationsDto {
    id!: number;
    language!: string | undefined;
    sourceLanguage!: string | undefined;
    locationCode!: string | undefined;
    description!: string | undefined;

    constructor(data?: IGetMstLocationsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.language = _data["language"];
            this.sourceLanguage = _data["sourceLanguage"];
            this.locationCode = _data["locationCode"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GetMstLocationsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMstLocationsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["language"] = this.language;
        data["sourceLanguage"] = this.sourceLanguage;
        data["locationCode"] = this.locationCode;
        data["description"] = this.description;
        return data;
    }
}

export interface IGetMstLocationsDto {
    id: number;
    language: string | undefined;
    sourceLanguage: string | undefined;
    locationCode: string | undefined;
    description: string | undefined;
}

export class CommonAllSupplierContacts implements ICommonAllSupplierContacts {
    supplierSiteId!: number | undefined;
    firstName!: string | undefined;
    midName!: string | undefined;
    lastName!: string | undefined;
    userName!: string | undefined;
    id!: number;

    constructor(data?: ICommonAllSupplierContacts) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supplierSiteId = _data["supplierSiteId"];
            this.firstName = _data["firstName"];
            this.midName = _data["midName"];
            this.lastName = _data["lastName"];
            this.userName = _data["userName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CommonAllSupplierContacts {
        data = typeof data === 'object' ? data : {};
        let result = new CommonAllSupplierContacts();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supplierSiteId"] = this.supplierSiteId;
        data["firstName"] = this.firstName;
        data["midName"] = this.midName;
        data["lastName"] = this.lastName;
        data["userName"] = this.userName;
        data["id"] = this.id;
        return data;
    }
}

export interface ICommonAllSupplierContacts {
    supplierSiteId: number | undefined;
    firstName: string | undefined;
    midName: string | undefined;
    lastName: string | undefined;
    userName: string | undefined;
    id: number;
}

export class GetRequesterDto implements IGetRequesterDto {
    id!: number;
    userName!: string | undefined;
    name!: string | undefined;
    email!: string | undefined;
    tel!: string | undefined;
    title!: string | undefined;
    departmentId!: string | undefined;
    department!: string | undefined;

    constructor(data?: IGetRequesterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.tel = _data["tel"];
            this.title = _data["title"];
            this.departmentId = _data["departmentId"];
            this.department = _data["department"];
        }
    }

    static fromJS(data: any): GetRequesterDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRequesterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["email"] = this.email;
        data["tel"] = this.tel;
        data["title"] = this.title;
        data["departmentId"] = this.departmentId;
        data["department"] = this.department;
        return data;
    }
}

export interface IGetRequesterDto {
    id: number;
    userName: string | undefined;
    name: string | undefined;
    email: string | undefined;
    tel: string | undefined;
    title: string | undefined;
    departmentId: string | undefined;
    department: string | undefined;
}

export class CommonAllPurchasePurpose implements ICommonAllPurchasePurpose {
    purchasePurposeName!: string | undefined;
    purchasePurposeCode!: string | undefined;
    haveBudgetCode!: boolean | undefined;
    status!: number | undefined;
    id!: number;

    constructor(data?: ICommonAllPurchasePurpose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchasePurposeName = _data["purchasePurposeName"];
            this.purchasePurposeCode = _data["purchasePurposeCode"];
            this.haveBudgetCode = _data["haveBudgetCode"];
            this.status = _data["status"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CommonAllPurchasePurpose {
        data = typeof data === 'object' ? data : {};
        let result = new CommonAllPurchasePurpose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchasePurposeName"] = this.purchasePurposeName;
        data["purchasePurposeCode"] = this.purchasePurposeCode;
        data["haveBudgetCode"] = this.haveBudgetCode;
        data["status"] = this.status;
        data["id"] = this.id;
        return data;
    }
}

export interface ICommonAllPurchasePurpose {
    purchasePurposeName: string | undefined;
    purchasePurposeCode: string | undefined;
    haveBudgetCode: boolean | undefined;
    status: number | undefined;
    id: number;
}

export class CommonAllDepartment implements ICommonAllDepartment {
    departmentName!: string | undefined;
    id!: string;

    constructor(data?: ICommonAllDepartment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.departmentName = _data["departmentName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CommonAllDepartment {
        data = typeof data === 'object' ? data : {};
        let result = new CommonAllDepartment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["departmentName"] = this.departmentName;
        data["id"] = this.id;
        return data;
    }
}

export interface ICommonAllDepartment {
    departmentName: string | undefined;
    id: string;
}

export class GetRequesterInfoForViewDto implements IGetRequesterInfoForViewDto {
    userName!: string | undefined;
    departmentName!: string | undefined;
    departmentId!: string;
    userTitle!: string | undefined;
    titleId!: number;
    email!: string | undefined;
    id!: number;

    constructor(data?: IGetRequesterInfoForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.departmentName = _data["departmentName"];
            this.departmentId = _data["departmentId"];
            this.userTitle = _data["userTitle"];
            this.titleId = _data["titleId"];
            this.email = _data["email"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetRequesterInfoForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRequesterInfoForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["departmentName"] = this.departmentName;
        data["departmentId"] = this.departmentId;
        data["userTitle"] = this.userTitle;
        data["titleId"] = this.titleId;
        data["email"] = this.email;
        data["id"] = this.id;
        return data;
    }
}

export interface IGetRequesterInfoForViewDto {
    userName: string | undefined;
    departmentName: string | undefined;
    departmentId: string;
    userTitle: string | undefined;
    titleId: number;
    email: string | undefined;
    id: number;
}

export class CommonAllGlCodeCombination implements ICommonAllGlCodeCombination {
    concatenatedSegments!: string | undefined;
    id!: number;

    constructor(data?: ICommonAllGlCodeCombination) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.concatenatedSegments = _data["concatenatedSegments"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CommonAllGlCodeCombination {
        data = typeof data === 'object' ? data : {};
        let result = new CommonAllGlCodeCombination();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["concatenatedSegments"] = this.concatenatedSegments;
        data["id"] = this.id;
        return data;
    }
}

export interface ICommonAllGlCodeCombination {
    concatenatedSegments: string | undefined;
    id: number;
}

export class PagedResultDtoOfCommonAllGlCodeCombination implements IPagedResultDtoOfCommonAllGlCodeCombination {
    totalCount!: number;
    items!: CommonAllGlCodeCombination[] | undefined;

    constructor(data?: IPagedResultDtoOfCommonAllGlCodeCombination) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CommonAllGlCodeCombination.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCommonAllGlCodeCombination {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCommonAllGlCodeCombination();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfCommonAllGlCodeCombination {
    totalCount: number;
    items: CommonAllGlCodeCombination[] | undefined;
}

export class CommonAllProcessType implements ICommonAllProcessType {
    processTypeCode!: string | undefined;
    processTypeName!: string | undefined;
    id!: number;

    constructor(data?: ICommonAllProcessType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processTypeCode = _data["processTypeCode"];
            this.processTypeName = _data["processTypeName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CommonAllProcessType {
        data = typeof data === 'object' ? data : {};
        let result = new CommonAllProcessType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processTypeCode"] = this.processTypeCode;
        data["processTypeName"] = this.processTypeName;
        data["id"] = this.id;
        return data;
    }
}

export interface ICommonAllProcessType {
    processTypeCode: string | undefined;
    processTypeName: string | undefined;
    id: number;
}

export class GetMstOrganizationsDto implements IGetMstOrganizationsDto {
    id!: number;
    language!: string | undefined;
    sourceLang!: string | undefined;
    name!: string | undefined;
    organizationCode!: string | undefined;
    userDefinitionEnableDate!: DateTime | undefined;
    disableDate!: DateTime | undefined;
    operatingUnit!: number;

    constructor(data?: IGetMstOrganizationsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.language = _data["language"];
            this.sourceLang = _data["sourceLang"];
            this.name = _data["name"];
            this.organizationCode = _data["organizationCode"];
            this.userDefinitionEnableDate = _data["userDefinitionEnableDate"] ? DateTime.fromISO(_data["userDefinitionEnableDate"].toString()) : <any>undefined;
            this.disableDate = _data["disableDate"] ? DateTime.fromISO(_data["disableDate"].toString()) : <any>undefined;
            this.operatingUnit = _data["operatingUnit"];
        }
    }

    static fromJS(data: any): GetMstOrganizationsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMstOrganizationsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["language"] = this.language;
        data["sourceLang"] = this.sourceLang;
        data["name"] = this.name;
        data["organizationCode"] = this.organizationCode;
        data["userDefinitionEnableDate"] = this.userDefinitionEnableDate ? this.userDefinitionEnableDate.toString() : <any>undefined;
        data["disableDate"] = this.disableDate ? this.disableDate.toString() : <any>undefined;
        data["operatingUnit"] = this.operatingUnit;
        return data;
    }
}

export interface IGetMstOrganizationsDto {
    id: number;
    language: string | undefined;
    sourceLang: string | undefined;
    name: string | undefined;
    organizationCode: string | undefined;
    userDefinitionEnableDate: DateTime | undefined;
    disableDate: DateTime | undefined;
    operatingUnit: number;
}

export class GetMstInventoryItemsDto implements IGetMstInventoryItemsDto {
    id!: number;
    inventoryGroupId!: number;
    inventoryItemId!: number;
    supplierId!: number | undefined;
    unitPrice!: string | undefined;
    primaryUnitOfMeasure!: string | undefined;
    category!: string | undefined;
    categoryId!: number;
    partNo!: string | undefined;
    color!: string | undefined;
    partName!: string | undefined;
    categorySetname!: string | undefined;
    currencyCode!: string | undefined;
    supplierName!: string | undefined;
    destinationTypeCode!: string | undefined;

    constructor(data?: IGetMstInventoryItemsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.inventoryItemId = _data["inventoryItemId"];
            this.supplierId = _data["supplierId"];
            this.unitPrice = _data["unitPrice"];
            this.primaryUnitOfMeasure = _data["primaryUnitOfMeasure"];
            this.category = _data["category"];
            this.categoryId = _data["categoryId"];
            this.partNo = _data["partNo"];
            this.color = _data["color"];
            this.partName = _data["partName"];
            this.categorySetname = _data["categorySetname"];
            this.currencyCode = _data["currencyCode"];
            this.supplierName = _data["supplierName"];
            this.destinationTypeCode = _data["destinationTypeCode"];
        }
    }

    static fromJS(data: any): GetMstInventoryItemsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMstInventoryItemsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["inventoryItemId"] = this.inventoryItemId;
        data["supplierId"] = this.supplierId;
        data["unitPrice"] = this.unitPrice;
        data["primaryUnitOfMeasure"] = this.primaryUnitOfMeasure;
        data["category"] = this.category;
        data["categoryId"] = this.categoryId;
        data["partNo"] = this.partNo;
        data["color"] = this.color;
        data["partName"] = this.partName;
        data["categorySetname"] = this.categorySetname;
        data["currencyCode"] = this.currencyCode;
        data["supplierName"] = this.supplierName;
        data["destinationTypeCode"] = this.destinationTypeCode;
        return data;
    }
}

export interface IGetMstInventoryItemsDto {
    id: number;
    inventoryGroupId: number;
    inventoryItemId: number;
    supplierId: number | undefined;
    unitPrice: string | undefined;
    primaryUnitOfMeasure: string | undefined;
    category: string | undefined;
    categoryId: number;
    partNo: string | undefined;
    color: string | undefined;
    partName: string | undefined;
    categorySetname: string | undefined;
    currencyCode: string | undefined;
    supplierName: string | undefined;
    destinationTypeCode: string | undefined;
}

export class SearchGlCodeOutputDto implements ISearchGlCodeOutputDto {
    id!: number;
    concatenatedSegments!: string | undefined;
    budgetName!: string | undefined;

    constructor(data?: ISearchGlCodeOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.concatenatedSegments = _data["concatenatedSegments"];
            this.budgetName = _data["budgetName"];
        }
    }

    static fromJS(data: any): SearchGlCodeOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchGlCodeOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["concatenatedSegments"] = this.concatenatedSegments;
        data["budgetName"] = this.budgetName;
        return data;
    }
}

export interface ISearchGlCodeOutputDto {
    id: number;
    concatenatedSegments: string | undefined;
    budgetName: string | undefined;
}

export class CommonGetReferencecs implements ICommonGetReferencecs {
    type!: string | undefined;
    number!: string | undefined;
    currentLineNum!: number;
    refLineNum!: number;

    constructor(data?: ICommonGetReferencecs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.number = _data["number"];
            this.currentLineNum = _data["currentLineNum"];
            this.refLineNum = _data["refLineNum"];
        }
    }

    static fromJS(data: any): CommonGetReferencecs {
        data = typeof data === 'object' ? data : {};
        let result = new CommonGetReferencecs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["number"] = this.number;
        data["currentLineNum"] = this.currentLineNum;
        data["refLineNum"] = this.refLineNum;
        return data;
    }
}

export interface ICommonGetReferencecs {
    type: string | undefined;
    number: string | undefined;
    currentLineNum: number;
    refLineNum: number;
}

export class CommonLookupDto implements ICommonLookupDto {
    id!: number;
    lookupCode!: string | undefined;
    lookupType!: string | undefined;
    displayedField!: string | undefined;
    description!: string | undefined;

    constructor(data?: ICommonLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.lookupCode = _data["lookupCode"];
            this.lookupType = _data["lookupType"];
            this.displayedField = _data["displayedField"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CommonLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommonLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lookupCode"] = this.lookupCode;
        data["lookupType"] = this.lookupType;
        data["displayedField"] = this.displayedField;
        data["description"] = this.description;
        return data;
    }
}

export interface ICommonLookupDto {
    id: number;
    lookupCode: string | undefined;
    lookupType: string | undefined;
    displayedField: string | undefined;
    description: string | undefined;
}

export class CommonPaymentTermsDto implements ICommonPaymentTermsDto {
    id!: number;
    name!: string | undefined;
    enableFlag!: boolean;
    description!: string | undefined;
    type!: string | undefined;

    constructor(data?: ICommonPaymentTermsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.enableFlag = _data["enableFlag"];
            this.description = _data["description"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CommonPaymentTermsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommonPaymentTermsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["enableFlag"] = this.enableFlag;
        data["description"] = this.description;
        data["type"] = this.type;
        return data;
    }
}

export interface ICommonPaymentTermsDto {
    id: number;
    name: string | undefined;
    enableFlag: boolean;
    description: string | undefined;
    type: string | undefined;
}

export class CommonGetGlExchangeRateDto implements ICommonGetGlExchangeRateDto {
    id!: number;
    fromCurrency!: string | undefined;
    toCurrency!: string | undefined;
    conversionDate!: DateTime | undefined;
    conversionType!: string | undefined;
    conversionRate!: number | undefined;

    constructor(data?: ICommonGetGlExchangeRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fromCurrency = _data["fromCurrency"];
            this.toCurrency = _data["toCurrency"];
            this.conversionDate = _data["conversionDate"] ? DateTime.fromISO(_data["conversionDate"].toString()) : <any>undefined;
            this.conversionType = _data["conversionType"];
            this.conversionRate = _data["conversionRate"];
        }
    }

    static fromJS(data: any): CommonGetGlExchangeRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommonGetGlExchangeRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fromCurrency"] = this.fromCurrency;
        data["toCurrency"] = this.toCurrency;
        data["conversionDate"] = this.conversionDate ? this.conversionDate.toString() : <any>undefined;
        data["conversionType"] = this.conversionType;
        data["conversionRate"] = this.conversionRate;
        return data;
    }
}

export interface ICommonGetGlExchangeRateDto {
    id: number;
    fromCurrency: string | undefined;
    toCurrency: string | undefined;
    conversionDate: DateTime | undefined;
    conversionType: string | undefined;
    conversionRate: number | undefined;
}

export class CommonDefaultParameterDto implements ICommonDefaultParameterDto {
    uomId!: number;
    uom!: string | undefined;
    curencyId!: number;
    curencyCode!: string | undefined;

    constructor(data?: ICommonDefaultParameterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uomId = _data["uomId"];
            this.uom = _data["uom"];
            this.curencyId = _data["curencyId"];
            this.curencyCode = _data["curencyCode"];
        }
    }

    static fromJS(data: any): CommonDefaultParameterDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommonDefaultParameterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uomId"] = this.uomId;
        data["uom"] = this.uom;
        data["curencyId"] = this.curencyId;
        data["curencyCode"] = this.curencyCode;
        return data;
    }
}

export interface ICommonDefaultParameterDto {
    uomId: number;
    uom: string | undefined;
    curencyId: number;
    curencyCode: string | undefined;
}

export class CommonAllDocument implements ICommonAllDocument {
    documentCode!: string | undefined;
    documentName!: string | undefined;
    processTypeName!: string | undefined;
    processTypeId!: number | undefined;
    isIrregular!: number | undefined;
    productGroupName!: string | undefined;
    inventoryGroupId!: number | undefined;
    leadtime!: number | undefined;
    status!: string | undefined;
    id!: number;

    constructor(data?: ICommonAllDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentCode = _data["documentCode"];
            this.documentName = _data["documentName"];
            this.processTypeName = _data["processTypeName"];
            this.processTypeId = _data["processTypeId"];
            this.isIrregular = _data["isIrregular"];
            this.productGroupName = _data["productGroupName"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.leadtime = _data["leadtime"];
            this.status = _data["status"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CommonAllDocument {
        data = typeof data === 'object' ? data : {};
        let result = new CommonAllDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentCode"] = this.documentCode;
        data["documentName"] = this.documentName;
        data["processTypeName"] = this.processTypeName;
        data["processTypeId"] = this.processTypeId;
        data["isIrregular"] = this.isIrregular;
        data["productGroupName"] = this.productGroupName;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["leadtime"] = this.leadtime;
        data["status"] = this.status;
        data["id"] = this.id;
        return data;
    }
}

export interface ICommonAllDocument {
    documentCode: string | undefined;
    documentName: string | undefined;
    processTypeName: string | undefined;
    processTypeId: number | undefined;
    isIrregular: number | undefined;
    productGroupName: string | undefined;
    inventoryGroupId: number | undefined;
    leadtime: number | undefined;
    status: string | undefined;
    id: number;
}

export class CommonAllTemplate implements ICommonAllTemplate {
    id!: number;
    templateCode!: string | undefined;
    templateName!: string | undefined;
    inventoryGroupId!: number | undefined;
    isActive!: string | undefined;
    description!: string | undefined;

    constructor(data?: ICommonAllTemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.templateCode = _data["templateCode"];
            this.templateName = _data["templateName"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CommonAllTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new CommonAllTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["templateCode"] = this.templateCode;
        data["templateName"] = this.templateName;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        return data;
    }
}

export interface ICommonAllTemplate {
    id: number;
    templateCode: string | undefined;
    templateName: string | undefined;
    inventoryGroupId: number | undefined;
    isActive: string | undefined;
    description: string | undefined;
}

export class CommonAllOrganization implements ICommonAllOrganization {
    language!: string | undefined;
    sourceLang!: string | undefined;
    name!: string | undefined;
    organizationCode!: string | undefined;
    setOfBooksId!: number;
    chartOfAccountsId!: number;
    userDefinitionEnableDate!: DateTime | undefined;
    disableDate!: DateTime | undefined;
    operatingUnit!: number;
    id!: number;

    constructor(data?: ICommonAllOrganization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"];
            this.sourceLang = _data["sourceLang"];
            this.name = _data["name"];
            this.organizationCode = _data["organizationCode"];
            this.setOfBooksId = _data["setOfBooksId"];
            this.chartOfAccountsId = _data["chartOfAccountsId"];
            this.userDefinitionEnableDate = _data["userDefinitionEnableDate"] ? DateTime.fromISO(_data["userDefinitionEnableDate"].toString()) : <any>undefined;
            this.disableDate = _data["disableDate"] ? DateTime.fromISO(_data["disableDate"].toString()) : <any>undefined;
            this.operatingUnit = _data["operatingUnit"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CommonAllOrganization {
        data = typeof data === 'object' ? data : {};
        let result = new CommonAllOrganization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language;
        data["sourceLang"] = this.sourceLang;
        data["name"] = this.name;
        data["organizationCode"] = this.organizationCode;
        data["setOfBooksId"] = this.setOfBooksId;
        data["chartOfAccountsId"] = this.chartOfAccountsId;
        data["userDefinitionEnableDate"] = this.userDefinitionEnableDate ? this.userDefinitionEnableDate.toString() : <any>undefined;
        data["disableDate"] = this.disableDate ? this.disableDate.toString() : <any>undefined;
        data["operatingUnit"] = this.operatingUnit;
        data["id"] = this.id;
        return data;
    }
}

export interface ICommonAllOrganization {
    language: string | undefined;
    sourceLang: string | undefined;
    name: string | undefined;
    organizationCode: string | undefined;
    setOfBooksId: number;
    chartOfAccountsId: number;
    userDefinitionEnableDate: DateTime | undefined;
    disableDate: DateTime | undefined;
    operatingUnit: number;
    id: number;
}

export class CommonGetAllCatalogDto implements ICommonGetAllCatalogDto {
    id!: number;
    catalogCode!: string | undefined;
    catalogName!: string | undefined;

    constructor(data?: ICommonGetAllCatalogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.catalogCode = _data["catalogCode"];
            this.catalogName = _data["catalogName"];
        }
    }

    static fromJS(data: any): CommonGetAllCatalogDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommonGetAllCatalogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["catalogCode"] = this.catalogCode;
        data["catalogName"] = this.catalogName;
        return data;
    }
}

export interface ICommonGetAllCatalogDto {
    id: number;
    catalogCode: string | undefined;
    catalogName: string | undefined;
}

export enum GenSeqType {
    UserRequest = 0,
    PurchasingRequest = 1,
    PurchasingOrder = 2,
    ReceiptNote = 3,
    Receipt = 4,
    Annex = 5,
    PaymentRequest = 6,
    ContractBackdate = 7,
    PaymentFromSupplier = 8,
    SupplierRequest = 9,
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
    isFree!: boolean | undefined;
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean;

    constructor(data?: ISubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isFree = _data["isFree"];
            this.value = _data["value"];
            this.displayText = _data["displayText"];
            this.isSelected = _data["isSelected"];
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFree"] = this.isFree;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data;
    }
}

export interface ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;
}

export class ListResultDtoOfSubscribableEditionComboboxItemDto implements IListResultDtoOfSubscribableEditionComboboxItemDto {
    items!: SubscribableEditionComboboxItemDto[] | undefined;

    constructor(data?: IListResultDtoOfSubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;
}

export class FindUsersInput implements IFindUsersInput {
    tenantId!: number | undefined;
    excludeCurrentUser!: boolean;
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.excludeCurrentUser = _data["excludeCurrentUser"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["excludeCurrentUser"] = this.excludeCurrentUser;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IFindUsersInput {
    tenantId: number | undefined;
    excludeCurrentUser: boolean;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
}

export class PagedResultDtoOfNameValueDto implements IPagedResultDtoOfNameValueDto {
    totalCount!: number;
    items!: NameValueDto[] | undefined;

    constructor(data?: IPagedResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfNameValueDto {
    totalCount: number;
    items: NameValueDto[] | undefined;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name!: string | undefined;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IGetDefaultEditionNameOutput {
    name: string | undefined;
}

export class GetAttachFileDto implements IGetAttachFileDto {
    headerId!: number;
    originalFileName!: string | undefined;
    serverFileName!: string | undefined;
    rootPath!: string | undefined;
    attachFileType!: string | undefined;
    id!: number;

    constructor(data?: IGetAttachFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.headerId = _data["headerId"];
            this.originalFileName = _data["originalFileName"];
            this.serverFileName = _data["serverFileName"];
            this.rootPath = _data["rootPath"];
            this.attachFileType = _data["attachFileType"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAttachFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAttachFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["headerId"] = this.headerId;
        data["originalFileName"] = this.originalFileName;
        data["serverFileName"] = this.serverFileName;
        data["rootPath"] = this.rootPath;
        data["attachFileType"] = this.attachFileType;
        data["id"] = this.id;
        return data;
    }
}

export interface IGetAttachFileDto {
    headerId: number;
    originalFileName: string | undefined;
    serverFileName: string | undefined;
    rootPath: string | undefined;
    attachFileType: string | undefined;
    id: number;
}

export class Widget implements IWidget {
    widgetId!: string | undefined;
    height!: number;
    width!: number;
    positionX!: number;
    positionY!: number;

    constructor(data?: IWidget) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.widgetId = _data["widgetId"];
            this.height = _data["height"];
            this.width = _data["width"];
            this.positionX = _data["positionX"];
            this.positionY = _data["positionY"];
        }
    }

    static fromJS(data: any): Widget {
        data = typeof data === 'object' ? data : {};
        let result = new Widget();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["widgetId"] = this.widgetId;
        data["height"] = this.height;
        data["width"] = this.width;
        data["positionX"] = this.positionX;
        data["positionY"] = this.positionY;
        return data;
    }
}

export interface IWidget {
    widgetId: string | undefined;
    height: number;
    width: number;
    positionX: number;
    positionY: number;
}

export class Page implements IPage {
    id!: string | undefined;
    name!: string | undefined;
    widgets!: Widget[] | undefined;

    constructor(data?: IPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["widgets"])) {
                this.widgets = [] as any;
                for (let item of _data["widgets"])
                    this.widgets!.push(Widget.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Page {
        data = typeof data === 'object' ? data : {};
        let result = new Page();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.widgets)) {
            data["widgets"] = [];
            for (let item of this.widgets)
                data["widgets"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPage {
    id: string | undefined;
    name: string | undefined;
    widgets: Widget[] | undefined;
}

export class Dashboard implements IDashboard {
    dashboardName!: string | undefined;
    pages!: Page[] | undefined;

    constructor(data?: IDashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardName = _data["dashboardName"];
            if (Array.isArray(_data["pages"])) {
                this.pages = [] as any;
                for (let item of _data["pages"])
                    this.pages!.push(Page.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Dashboard {
        data = typeof data === 'object' ? data : {};
        let result = new Dashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        if (Array.isArray(this.pages)) {
            data["pages"] = [];
            for (let item of this.pages)
                data["pages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDashboard {
    dashboardName: string | undefined;
    pages: Page[] | undefined;
}

export class SavePageInput implements ISavePageInput {
    dashboardName!: string | undefined;
    application!: string | undefined;
    pages!: Page[] | undefined;

    constructor(data?: ISavePageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardName = _data["dashboardName"];
            this.application = _data["application"];
            if (Array.isArray(_data["pages"])) {
                this.pages = [] as any;
                for (let item of _data["pages"])
                    this.pages!.push(Page.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SavePageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SavePageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        data["application"] = this.application;
        if (Array.isArray(this.pages)) {
            data["pages"] = [];
            for (let item of this.pages)
                data["pages"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISavePageInput {
    dashboardName: string | undefined;
    application: string | undefined;
    pages: Page[] | undefined;
}

export class RenamePageInput implements IRenamePageInput {
    dashboardName!: string | undefined;
    id!: string | undefined;
    name!: string | undefined;
    application!: string | undefined;

    constructor(data?: IRenamePageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardName = _data["dashboardName"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.application = _data["application"];
        }
    }

    static fromJS(data: any): RenamePageInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenamePageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        data["id"] = this.id;
        data["name"] = this.name;
        data["application"] = this.application;
        return data;
    }
}

export interface IRenamePageInput {
    dashboardName: string | undefined;
    id: string | undefined;
    name: string | undefined;
    application: string | undefined;
}

export class AddNewPageInput implements IAddNewPageInput {
    dashboardName!: string | undefined;
    name!: string | undefined;
    application!: string | undefined;

    constructor(data?: IAddNewPageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardName = _data["dashboardName"];
            this.name = _data["name"];
            this.application = _data["application"];
        }
    }

    static fromJS(data: any): AddNewPageInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddNewPageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        data["name"] = this.name;
        data["application"] = this.application;
        return data;
    }
}

export interface IAddNewPageInput {
    dashboardName: string | undefined;
    name: string | undefined;
    application: string | undefined;
}

export class AddNewPageOutput implements IAddNewPageOutput {
    pageId!: string | undefined;

    constructor(data?: IAddNewPageOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageId = _data["pageId"];
        }
    }

    static fromJS(data: any): AddNewPageOutput {
        data = typeof data === 'object' ? data : {};
        let result = new AddNewPageOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageId"] = this.pageId;
        return data;
    }
}

export interface IAddNewPageOutput {
    pageId: string | undefined;
}

export class AddWidgetInput implements IAddWidgetInput {
    widgetId!: string | undefined;
    pageId!: string | undefined;
    dashboardName!: string | undefined;
    width!: number;
    height!: number;
    application!: string | undefined;

    constructor(data?: IAddWidgetInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.widgetId = _data["widgetId"];
            this.pageId = _data["pageId"];
            this.dashboardName = _data["dashboardName"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.application = _data["application"];
        }
    }

    static fromJS(data: any): AddWidgetInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddWidgetInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["widgetId"] = this.widgetId;
        data["pageId"] = this.pageId;
        data["dashboardName"] = this.dashboardName;
        data["width"] = this.width;
        data["height"] = this.height;
        data["application"] = this.application;
        return data;
    }
}

export interface IAddWidgetInput {
    widgetId: string | undefined;
    pageId: string | undefined;
    dashboardName: string | undefined;
    width: number;
    height: number;
    application: string | undefined;
}

export class WidgetFilterOutput implements IWidgetFilterOutput {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IWidgetFilterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): WidgetFilterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetFilterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IWidgetFilterOutput {
    id: string | undefined;
    name: string | undefined;
}

export class WidgetOutput implements IWidgetOutput {
    id!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    filters!: WidgetFilterOutput[] | undefined;

    constructor(data?: IWidgetOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["filters"])) {
                this.filters = [] as any;
                for (let item of _data["filters"])
                    this.filters!.push(WidgetFilterOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WidgetOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.filters)) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWidgetOutput {
    id: string | undefined;
    name: string | undefined;
    description: string | undefined;
    filters: WidgetFilterOutput[] | undefined;
}

export class DashboardOutput implements IDashboardOutput {
    name!: string | undefined;
    widgets!: WidgetOutput[] | undefined;

    constructor(data?: IDashboardOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["widgets"])) {
                this.widgets = [] as any;
                for (let item of _data["widgets"])
                    this.widgets!.push(WidgetOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DashboardOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.widgets)) {
            data["widgets"] = [];
            for (let item of this.widgets)
                data["widgets"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDashboardOutput {
    name: string | undefined;
    widgets: WidgetOutput[] | undefined;
}

export class DateToStringOutput implements IDateToStringOutput {
    dateString!: string | undefined;

    constructor(data?: IDateToStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateString = _data["dateString"];
        }
    }

    static fromJS(data: any): DateToStringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DateToStringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateString"] = this.dateString;
        return data;
    }
}

export interface IDateToStringOutput {
    dateString: string | undefined;
}

export class NameValueOfString implements INameValueOfString {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueOfString {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface INameValueOfString {
    name: string | undefined;
    value: string | undefined;
}

export class StringOutput implements IStringOutput {
    output!: string | undefined;

    constructor(data?: IStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.output = _data["output"];
        }
    }

    static fromJS(data: any): StringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["output"] = this.output;
        return data;
    }
}

export interface IStringOutput {
    output: string | undefined;
}

export class DigitalInvoiceInfoDto implements IDigitalInvoiceInfoDto {
    invoiceNum!: string | undefined;
    serialNo!: string | undefined;
    supplierName!: string | undefined;
    supplierNumber!: string | undefined;
    invoiceDate!: DateTime;
    status!: number;
    distAmount!: number;
    vatAmount!: number;
    amount!: number;
    sellerTaxCode!: string | undefined;
    poNo!: string | undefined;
    id!: number;

    constructor(data?: IDigitalInvoiceInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoiceNum = _data["invoiceNum"];
            this.serialNo = _data["serialNo"];
            this.supplierName = _data["supplierName"];
            this.supplierNumber = _data["supplierNumber"];
            this.invoiceDate = _data["invoiceDate"] ? DateTime.fromISO(_data["invoiceDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.distAmount = _data["distAmount"];
            this.vatAmount = _data["vatAmount"];
            this.amount = _data["amount"];
            this.sellerTaxCode = _data["sellerTaxCode"];
            this.poNo = _data["poNo"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DigitalInvoiceInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new DigitalInvoiceInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceNum"] = this.invoiceNum;
        data["serialNo"] = this.serialNo;
        data["supplierName"] = this.supplierName;
        data["supplierNumber"] = this.supplierNumber;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toString() : <any>undefined;
        data["status"] = this.status;
        data["distAmount"] = this.distAmount;
        data["vatAmount"] = this.vatAmount;
        data["amount"] = this.amount;
        data["sellerTaxCode"] = this.sellerTaxCode;
        data["poNo"] = this.poNo;
        data["id"] = this.id;
        return data;
    }
}

export interface IDigitalInvoiceInfoDto {
    invoiceNum: string | undefined;
    serialNo: string | undefined;
    supplierName: string | undefined;
    supplierNumber: string | undefined;
    invoiceDate: DateTime;
    status: number;
    distAmount: number;
    vatAmount: number;
    amount: number;
    sellerTaxCode: string | undefined;
    poNo: string | undefined;
    id: number;
}

export class PagedResultDtoOfDigitalInvoiceInfoDto implements IPagedResultDtoOfDigitalInvoiceInfoDto {
    totalCount!: number;
    items!: DigitalInvoiceInfoDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDigitalInvoiceInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DigitalInvoiceInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDigitalInvoiceInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDigitalInvoiceInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfDigitalInvoiceInfoDto {
    totalCount: number;
    items: DigitalInvoiceInfoDto[] | undefined;
}

export class InvoiceAkabotFileDto implements IInvoiceAkabotFileDto {
    invAkabotHeaderId!: number;
    originalFileName!: string | undefined;
    serverFileName!: string | undefined;
    rootPath!: string | undefined;
    fileType!: string | undefined;
    id!: number;

    constructor(data?: IInvoiceAkabotFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invAkabotHeaderId = _data["invAkabotHeaderId"];
            this.originalFileName = _data["originalFileName"];
            this.serverFileName = _data["serverFileName"];
            this.rootPath = _data["rootPath"];
            this.fileType = _data["fileType"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): InvoiceAkabotFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceAkabotFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invAkabotHeaderId"] = this.invAkabotHeaderId;
        data["originalFileName"] = this.originalFileName;
        data["serverFileName"] = this.serverFileName;
        data["rootPath"] = this.rootPath;
        data["fileType"] = this.fileType;
        data["id"] = this.id;
        return data;
    }
}

export interface IInvoiceAkabotFileDto {
    invAkabotHeaderId: number;
    originalFileName: string | undefined;
    serverFileName: string | undefined;
    rootPath: string | undefined;
    fileType: string | undefined;
    id: number;
}

export class DigitalInvoiceDetailInfoDto implements IDigitalInvoiceDetailInfoDto {
    distDescription!: string | undefined;
    unitOfMeasure!: string | undefined;
    quantityInvoiced!: number;
    unitPrice!: number;
    distAmount!: number;
    poNo!: string | undefined;
    vatRate!: string | undefined;
    id!: number;

    constructor(data?: IDigitalInvoiceDetailInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.distDescription = _data["distDescription"];
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.quantityInvoiced = _data["quantityInvoiced"];
            this.unitPrice = _data["unitPrice"];
            this.distAmount = _data["distAmount"];
            this.poNo = _data["poNo"];
            this.vatRate = _data["vatRate"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DigitalInvoiceDetailInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new DigitalInvoiceDetailInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["distDescription"] = this.distDescription;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["quantityInvoiced"] = this.quantityInvoiced;
        data["unitPrice"] = this.unitPrice;
        data["distAmount"] = this.distAmount;
        data["poNo"] = this.poNo;
        data["vatRate"] = this.vatRate;
        data["id"] = this.id;
        return data;
    }
}

export interface IDigitalInvoiceDetailInfoDto {
    distDescription: string | undefined;
    unitOfMeasure: string | undefined;
    quantityInvoiced: number;
    unitPrice: number;
    distAmount: number;
    poNo: string | undefined;
    vatRate: string | undefined;
    id: number;
}

export class DigitalInvoiceMatchResultsDto implements IDigitalInvoiceMatchResultsDto {
    invoiceNum!: string | undefined;
    poNo!: string | undefined;
    nameOnInvoice!: string | undefined;
    nameOnSupplier!: string | undefined;
    nameOnPO!: string | undefined;
    itemId!: number | undefined;
    status!: number;
    eInvErrorStatus!: number;
    quantityOrdered!: number;
    quantityShipped!: number;
    quantityReceived!: number;
    quantityBilled!: number;
    quantityInvoiced!: number;
    amountOrdered!: number;
    amountBilled!: number;
    distAmount!: number;
    note!: string | undefined;
    unitOfMeasure!: string | undefined;
    interfaceHeaderId!: number | undefined;
    interfaceLineId!: number | undefined;
    vendorId!: number | undefined;
    id!: number;

    constructor(data?: IDigitalInvoiceMatchResultsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoiceNum = _data["invoiceNum"];
            this.poNo = _data["poNo"];
            this.nameOnInvoice = _data["nameOnInvoice"];
            this.nameOnSupplier = _data["nameOnSupplier"];
            this.nameOnPO = _data["nameOnPO"];
            this.itemId = _data["itemId"];
            this.status = _data["status"];
            this.eInvErrorStatus = _data["eInvErrorStatus"];
            this.quantityOrdered = _data["quantityOrdered"];
            this.quantityShipped = _data["quantityShipped"];
            this.quantityReceived = _data["quantityReceived"];
            this.quantityBilled = _data["quantityBilled"];
            this.quantityInvoiced = _data["quantityInvoiced"];
            this.amountOrdered = _data["amountOrdered"];
            this.amountBilled = _data["amountBilled"];
            this.distAmount = _data["distAmount"];
            this.note = _data["note"];
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.interfaceHeaderId = _data["interfaceHeaderId"];
            this.interfaceLineId = _data["interfaceLineId"];
            this.vendorId = _data["vendorId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DigitalInvoiceMatchResultsDto {
        data = typeof data === 'object' ? data : {};
        let result = new DigitalInvoiceMatchResultsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceNum"] = this.invoiceNum;
        data["poNo"] = this.poNo;
        data["nameOnInvoice"] = this.nameOnInvoice;
        data["nameOnSupplier"] = this.nameOnSupplier;
        data["nameOnPO"] = this.nameOnPO;
        data["itemId"] = this.itemId;
        data["status"] = this.status;
        data["eInvErrorStatus"] = this.eInvErrorStatus;
        data["quantityOrdered"] = this.quantityOrdered;
        data["quantityShipped"] = this.quantityShipped;
        data["quantityReceived"] = this.quantityReceived;
        data["quantityBilled"] = this.quantityBilled;
        data["quantityInvoiced"] = this.quantityInvoiced;
        data["amountOrdered"] = this.amountOrdered;
        data["amountBilled"] = this.amountBilled;
        data["distAmount"] = this.distAmount;
        data["note"] = this.note;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["interfaceHeaderId"] = this.interfaceHeaderId;
        data["interfaceLineId"] = this.interfaceLineId;
        data["vendorId"] = this.vendorId;
        data["id"] = this.id;
        return data;
    }
}

export interface IDigitalInvoiceMatchResultsDto {
    invoiceNum: string | undefined;
    poNo: string | undefined;
    nameOnInvoice: string | undefined;
    nameOnSupplier: string | undefined;
    nameOnPO: string | undefined;
    itemId: number | undefined;
    status: number;
    eInvErrorStatus: number;
    quantityOrdered: number;
    quantityShipped: number;
    quantityReceived: number;
    quantityBilled: number;
    quantityInvoiced: number;
    amountOrdered: number;
    amountBilled: number;
    distAmount: number;
    note: string | undefined;
    unitOfMeasure: string | undefined;
    interfaceHeaderId: number | undefined;
    interfaceLineId: number | undefined;
    vendorId: number | undefined;
    id: number;
}

export class DynamicEntityPropertyDto implements IDynamicEntityPropertyDto {
    entityFullName!: string | undefined;
    dynamicPropertyName!: string | undefined;
    dynamicPropertyId!: number;
    tenantId!: number | undefined;
    id!: number;

    constructor(data?: IDynamicEntityPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityFullName = _data["entityFullName"];
            this.dynamicPropertyName = _data["dynamicPropertyName"];
            this.dynamicPropertyId = _data["dynamicPropertyId"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicEntityPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicEntityPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityFullName"] = this.entityFullName;
        data["dynamicPropertyName"] = this.dynamicPropertyName;
        data["dynamicPropertyId"] = this.dynamicPropertyId;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicEntityPropertyDto {
    entityFullName: string | undefined;
    dynamicPropertyName: string | undefined;
    dynamicPropertyId: number;
    tenantId: number | undefined;
    id: number;
}

export class ListResultDtoOfDynamicEntityPropertyDto implements IListResultDtoOfDynamicEntityPropertyDto {
    items!: DynamicEntityPropertyDto[] | undefined;

    constructor(data?: IListResultDtoOfDynamicEntityPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DynamicEntityPropertyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfDynamicEntityPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfDynamicEntityPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfDynamicEntityPropertyDto {
    items: DynamicEntityPropertyDto[] | undefined;
}

export class GetAllEntitiesHasDynamicPropertyOutput implements IGetAllEntitiesHasDynamicPropertyOutput {
    entityFullName!: string | undefined;

    constructor(data?: IGetAllEntitiesHasDynamicPropertyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityFullName = _data["entityFullName"];
        }
    }

    static fromJS(data: any): GetAllEntitiesHasDynamicPropertyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllEntitiesHasDynamicPropertyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityFullName"] = this.entityFullName;
        return data;
    }
}

export interface IGetAllEntitiesHasDynamicPropertyOutput {
    entityFullName: string | undefined;
}

export class ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput implements IListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput {
    items!: GetAllEntitiesHasDynamicPropertyOutput[] | undefined;

    constructor(data?: IListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllEntitiesHasDynamicPropertyOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput {
    items: GetAllEntitiesHasDynamicPropertyOutput[] | undefined;
}

export class DynamicEntityPropertyValueDto implements IDynamicEntityPropertyValueDto {
    value!: string | undefined;
    entityId!: string | undefined;
    dynamicEntityPropertyId!: number;
    id!: number;

    constructor(data?: IDynamicEntityPropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.entityId = _data["entityId"];
            this.dynamicEntityPropertyId = _data["dynamicEntityPropertyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicEntityPropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicEntityPropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["entityId"] = this.entityId;
        data["dynamicEntityPropertyId"] = this.dynamicEntityPropertyId;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicEntityPropertyValueDto {
    value: string | undefined;
    entityId: string | undefined;
    dynamicEntityPropertyId: number;
    id: number;
}

export class ListResultDtoOfDynamicEntityPropertyValueDto implements IListResultDtoOfDynamicEntityPropertyValueDto {
    items!: DynamicEntityPropertyValueDto[] | undefined;

    constructor(data?: IListResultDtoOfDynamicEntityPropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DynamicEntityPropertyValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfDynamicEntityPropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfDynamicEntityPropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfDynamicEntityPropertyValueDto {
    items: DynamicEntityPropertyValueDto[] | undefined;
}

export class IValueValidator implements IIValueValidator {
    readonly name!: string | undefined;
    readonly attributes!: { [key: string]: any; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            if (_data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>(<any>this).attributes)![key] = _data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    (<any>data["attributes"])[key] = (<any>this.attributes)[key];
            }
        }
        return data;
    }
}

export interface IIValueValidator {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
}

export class IInputType implements IIInputType {
    readonly name!: string | undefined;
    readonly attributes!: { [key: string]: any; } | undefined;
    validator!: IValueValidator;

    constructor(data?: IIInputType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            if (_data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>(<any>this).attributes)![key] = _data["attributes"][key];
                }
            }
            this.validator = _data["validator"] ? IValueValidator.fromJS(_data["validator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IInputType {
        data = typeof data === 'object' ? data : {};
        let result = new IInputType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    (<any>data["attributes"])[key] = (<any>this.attributes)[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIInputType {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
    validator: IValueValidator;
}

export class GetAllDynamicEntityPropertyValuesOutputItem implements IGetAllDynamicEntityPropertyValuesOutputItem {
    dynamicEntityPropertyId!: number;
    propertyName!: string | undefined;
    inputType!: IInputType;
    selectedValues!: string[] | undefined;
    allValuesInputTypeHas!: string[] | undefined;

    constructor(data?: IGetAllDynamicEntityPropertyValuesOutputItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dynamicEntityPropertyId = _data["dynamicEntityPropertyId"];
            this.propertyName = _data["propertyName"];
            this.inputType = _data["inputType"] ? IInputType.fromJS(_data["inputType"]) : <any>undefined;
            if (Array.isArray(_data["selectedValues"])) {
                this.selectedValues = [] as any;
                for (let item of _data["selectedValues"])
                    this.selectedValues!.push(item);
            }
            if (Array.isArray(_data["allValuesInputTypeHas"])) {
                this.allValuesInputTypeHas = [] as any;
                for (let item of _data["allValuesInputTypeHas"])
                    this.allValuesInputTypeHas!.push(item);
            }
        }
    }

    static fromJS(data: any): GetAllDynamicEntityPropertyValuesOutputItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllDynamicEntityPropertyValuesOutputItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dynamicEntityPropertyId"] = this.dynamicEntityPropertyId;
        data["propertyName"] = this.propertyName;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        if (Array.isArray(this.selectedValues)) {
            data["selectedValues"] = [];
            for (let item of this.selectedValues)
                data["selectedValues"].push(item);
        }
        if (Array.isArray(this.allValuesInputTypeHas)) {
            data["allValuesInputTypeHas"] = [];
            for (let item of this.allValuesInputTypeHas)
                data["allValuesInputTypeHas"].push(item);
        }
        return data;
    }
}

export interface IGetAllDynamicEntityPropertyValuesOutputItem {
    dynamicEntityPropertyId: number;
    propertyName: string | undefined;
    inputType: IInputType;
    selectedValues: string[] | undefined;
    allValuesInputTypeHas: string[] | undefined;
}

export class GetAllDynamicEntityPropertyValuesOutput implements IGetAllDynamicEntityPropertyValuesOutput {
    items!: GetAllDynamicEntityPropertyValuesOutputItem[] | undefined;

    constructor(data?: IGetAllDynamicEntityPropertyValuesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllDynamicEntityPropertyValuesOutputItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllDynamicEntityPropertyValuesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllDynamicEntityPropertyValuesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetAllDynamicEntityPropertyValuesOutput {
    items: GetAllDynamicEntityPropertyValuesOutputItem[] | undefined;
}

export class InsertOrUpdateAllValuesInputItem implements IInsertOrUpdateAllValuesInputItem {
    entityId!: string | undefined;
    dynamicEntityPropertyId!: number;
    values!: string[] | undefined;

    constructor(data?: IInsertOrUpdateAllValuesInputItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityId = _data["entityId"];
            this.dynamicEntityPropertyId = _data["dynamicEntityPropertyId"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
        }
    }

    static fromJS(data: any): InsertOrUpdateAllValuesInputItem {
        data = typeof data === 'object' ? data : {};
        let result = new InsertOrUpdateAllValuesInputItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["dynamicEntityPropertyId"] = this.dynamicEntityPropertyId;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        return data;
    }
}

export interface IInsertOrUpdateAllValuesInputItem {
    entityId: string | undefined;
    dynamicEntityPropertyId: number;
    values: string[] | undefined;
}

export class InsertOrUpdateAllValuesInput implements IInsertOrUpdateAllValuesInput {
    items!: InsertOrUpdateAllValuesInputItem[] | undefined;

    constructor(data?: IInsertOrUpdateAllValuesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InsertOrUpdateAllValuesInputItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InsertOrUpdateAllValuesInput {
        data = typeof data === 'object' ? data : {};
        let result = new InsertOrUpdateAllValuesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInsertOrUpdateAllValuesInput {
    items: InsertOrUpdateAllValuesInputItem[] | undefined;
}

export class CleanValuesInput implements ICleanValuesInput {
    dynamicEntityPropertyId!: number;
    entityId!: string | undefined;

    constructor(data?: ICleanValuesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dynamicEntityPropertyId = _data["dynamicEntityPropertyId"];
            this.entityId = _data["entityId"];
        }
    }

    static fromJS(data: any): CleanValuesInput {
        data = typeof data === 'object' ? data : {};
        let result = new CleanValuesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dynamicEntityPropertyId"] = this.dynamicEntityPropertyId;
        data["entityId"] = this.entityId;
        return data;
    }
}

export interface ICleanValuesInput {
    dynamicEntityPropertyId: number;
    entityId: string | undefined;
}

export class DynamicPropertyDto implements IDynamicPropertyDto {
    propertyName!: string | undefined;
    displayName!: string | undefined;
    inputType!: string | undefined;
    permission!: string | undefined;
    tenantId!: number | undefined;
    id!: number;

    constructor(data?: IDynamicPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.displayName = _data["displayName"];
            this.inputType = _data["inputType"];
            this.permission = _data["permission"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["displayName"] = this.displayName;
        data["inputType"] = this.inputType;
        data["permission"] = this.permission;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicPropertyDto {
    propertyName: string | undefined;
    displayName: string | undefined;
    inputType: string | undefined;
    permission: string | undefined;
    tenantId: number | undefined;
    id: number;
}

export class ListResultDtoOfDynamicPropertyDto implements IListResultDtoOfDynamicPropertyDto {
    items!: DynamicPropertyDto[] | undefined;

    constructor(data?: IListResultDtoOfDynamicPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DynamicPropertyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfDynamicPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfDynamicPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfDynamicPropertyDto {
    items: DynamicPropertyDto[] | undefined;
}

export class DynamicPropertyValueDto implements IDynamicPropertyValueDto {
    value!: string | undefined;
    tenantId!: number | undefined;
    dynamicPropertyId!: number;
    id!: number;

    constructor(data?: IDynamicPropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.tenantId = _data["tenantId"];
            this.dynamicPropertyId = _data["dynamicPropertyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicPropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["tenantId"] = this.tenantId;
        data["dynamicPropertyId"] = this.dynamicPropertyId;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicPropertyValueDto {
    value: string | undefined;
    tenantId: number | undefined;
    dynamicPropertyId: number;
    id: number;
}

export class ListResultDtoOfDynamicPropertyValueDto implements IListResultDtoOfDynamicPropertyValueDto {
    items!: DynamicPropertyValueDto[] | undefined;

    constructor(data?: IListResultDtoOfDynamicPropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DynamicPropertyValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfDynamicPropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfDynamicPropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfDynamicPropertyValueDto {
    items: DynamicPropertyValueDto[] | undefined;
}

export class EditionListDto implements IEditionListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    dailyPrice!: number | undefined;
    weeklyPrice!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    trialDayCount!: number | undefined;
    expiringEditionDisplayName!: string | undefined;
    id!: number;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.dailyPrice = _data["dailyPrice"];
            this.weeklyPrice = _data["weeklyPrice"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.waitingDayAfterExpire = _data["waitingDayAfterExpire"];
            this.trialDayCount = _data["trialDayCount"];
            this.expiringEditionDisplayName = _data["expiringEditionDisplayName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["trialDayCount"] = this.trialDayCount;
        data["expiringEditionDisplayName"] = this.expiringEditionDisplayName;
        data["id"] = this.id;
        return data;
    }
}

export interface IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    waitingDayAfterExpire: number | undefined;
    trialDayCount: number | undefined;
    expiringEditionDisplayName: string | undefined;
    id: number;
}

export class ListResultDtoOfEditionListDto implements IListResultDtoOfEditionListDto {
    items!: EditionListDto[] | undefined;

    constructor(data?: IListResultDtoOfEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EditionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfEditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;
}

export class EditionEditDto implements IEditionEditDto {
    id!: number | undefined;
    displayName!: string;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.expiringEditionId = _data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        return data;
    }
}

export interface IEditionEditDto {
    id: number | undefined;
    displayName: string;
    expiringEditionId: number | undefined;
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.displayText = _data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data;
    }
}

export interface ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items!: LocalizableComboboxItemDto[] | undefined;

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name!: string | undefined;
    attributes!: { [key: string]: any; } | undefined;
    validator!: IValueValidator;
    itemSource!: LocalizableComboboxItemSourceDto;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (_data["attributes"]) {
                this.attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>this.attributes)![key] = _data["attributes"][key];
                }
            }
            this.validator = _data["validator"] ? IValueValidator.fromJS(_data["validator"]) : <any>undefined;
            this.itemSource = _data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(_data["itemSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    (<any>data["attributes"])[key] = (<any>this.attributes)[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
    validator: IValueValidator;
    itemSource: LocalizableComboboxItemSourceDto;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: FeatureInputTypeDto;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.defaultValue = _data["defaultValue"];
            this.inputType = _data["inputType"] ? FeatureInputTypeDto.fromJS(_data["inputType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition!: EditionEditDto;
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionEditDto.fromJS(_data["edition"]) : <any>undefined;
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetEditionEditOutput {
    edition: EditionEditDto;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class EditionCreateDto implements IEditionCreateDto {
    id!: number | undefined;
    displayName!: string;
    dailyPrice!: number | undefined;
    weeklyPrice!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.dailyPrice = _data["dailyPrice"];
            this.weeklyPrice = _data["weeklyPrice"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.trialDayCount = _data["trialDayCount"];
            this.waitingDayAfterExpire = _data["waitingDayAfterExpire"];
            this.expiringEditionId = _data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data;
    }
}

export interface IEditionCreateDto {
    id: number | undefined;
    displayName: string;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;
}

export class CreateEditionDto implements ICreateEditionDto {
    edition!: EditionCreateDto;
    featureValues!: NameValueDto[];

    constructor(data?: ICreateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionCreateDto();
            this.featureValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionCreateDto.fromJS(_data["edition"]) : new EditionCreateDto();
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateEditionDto {
    edition: EditionCreateDto;
    featureValues: NameValueDto[];
}

export class UpdateEditionDto implements IUpdateEditionDto {
    edition!: EditionEditDto;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
            this.featureValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionEditDto.fromJS(_data["edition"]) : new EditionEditDto();
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];
}

export class MoveTenantsToAnotherEditionDto implements IMoveTenantsToAnotherEditionDto {
    sourceEditionId!: number;
    targetEditionId!: number;

    constructor(data?: IMoveTenantsToAnotherEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceEditionId = _data["sourceEditionId"];
            this.targetEditionId = _data["targetEditionId"];
        }
    }

    static fromJS(data: any): MoveTenantsToAnotherEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoveTenantsToAnotherEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceEditionId"] = this.sourceEditionId;
        data["targetEditionId"] = this.targetEditionId;
        return data;
    }
}

export interface IMoveTenantsToAnotherEditionDto {
    sourceEditionId: number;
    targetEditionId: number;
}

export class MstExchangeRateDto implements IMstExchangeRateDto {
    id!: number;
    periodVersionName!: string | undefined;
    periodName!: string | undefined;
    currencyName!: string | undefined;
    exchangeRate!: number;
    description!: string | undefined;

    constructor(data?: IMstExchangeRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.periodVersionName = _data["periodVersionName"];
            this.periodName = _data["periodName"];
            this.currencyName = _data["currencyName"];
            this.exchangeRate = _data["exchangeRate"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): MstExchangeRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new MstExchangeRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["periodVersionName"] = this.periodVersionName;
        data["periodName"] = this.periodName;
        data["currencyName"] = this.currencyName;
        data["exchangeRate"] = this.exchangeRate;
        data["description"] = this.description;
        return data;
    }
}

export interface IMstExchangeRateDto {
    id: number;
    periodVersionName: string | undefined;
    periodName: string | undefined;
    currencyName: string | undefined;
    exchangeRate: number;
    description: string | undefined;
}

export class PagedResultDtoOfMstExchangeRateDto implements IPagedResultDtoOfMstExchangeRateDto {
    totalCount!: number;
    items!: MstExchangeRateDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMstExchangeRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MstExchangeRateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMstExchangeRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMstExchangeRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMstExchangeRateDto {
    totalCount: number;
    items: MstExchangeRateDto[] | undefined;
}

export class InputExchangeRateDto implements IInputExchangeRateDto {
    id!: number;
    periodVersionId!: number;
    periodId!: number;
    currencyId!: number;
    exchangeRate!: number;
    description!: string | undefined;

    constructor(data?: IInputExchangeRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.periodVersionId = _data["periodVersionId"];
            this.periodId = _data["periodId"];
            this.currencyId = _data["currencyId"];
            this.exchangeRate = _data["exchangeRate"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): InputExchangeRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputExchangeRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["periodVersionId"] = this.periodVersionId;
        data["periodId"] = this.periodId;
        data["currencyId"] = this.currencyId;
        data["exchangeRate"] = this.exchangeRate;
        data["description"] = this.description;
        return data;
    }
}

export interface IInputExchangeRateDto {
    id: number;
    periodVersionId: number;
    periodId: number;
    currencyId: number;
    exchangeRate: number;
    description: string | undefined;
}

export enum BmsMstColumn {
    OriginalPlan = 1,
    OriginalPlanGap = 2,
    FinancialPlan = 3,
    FinancialPlanGap = 4,
    P1Q = 5,
    P1QGap = 6,
    P2Q = 7,
    P2QGap = 8,
    P3Q = 9,
    P3QGap = 10,
    P11P1 = 11,
    P11P1Gap = 12,
    Apr = 13,
    May = 14,
    Jun = 15,
    Jul = 16,
    Aug = 17,
    Sep = 18,
    Oct = 19,
    Nov = 20,
    Dec = 21,
    Jan = 22,
    Feb = 23,
    Mar = 24,
}

export class CreateFriendshipRequestInput implements ICreateFriendshipRequestInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: ICreateFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface ICreateFriendshipRequestInput {
    userId: number;
    tenantId: number | undefined;
}

export class CreateFriendshipRequestByUserNameInput implements ICreateFriendshipRequestByUserNameInput {
    tenancyName!: string;
    userName!: string | undefined;

    constructor(data?: ICreateFriendshipRequestByUserNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestByUserNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        return data;
    }
}

export interface ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName: string | undefined;
}

export class BlockUserInput implements IBlockUserInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: IBlockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): BlockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new BlockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IBlockUserInput {
    userId: number;
    tenantId: number | undefined;
}

export class UnblockUserInput implements IUnblockUserInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: IUnblockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): UnblockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnblockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IUnblockUserInput {
    userId: number;
    tenantId: number | undefined;
}

export class AcceptFriendshipRequestInput implements IAcceptFriendshipRequestInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: IAcceptFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): AcceptFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IAcceptFriendshipRequestInput {
    userId: number;
    tenantId: number | undefined;
}

export class TopStatsData implements ITopStatsData {
    newTenantsCount!: number;
    newSubscriptionAmount!: number;
    dashboardPlaceholder1!: number;
    dashboardPlaceholder2!: number;

    constructor(data?: ITopStatsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newTenantsCount = _data["newTenantsCount"];
            this.newSubscriptionAmount = _data["newSubscriptionAmount"];
            this.dashboardPlaceholder1 = _data["dashboardPlaceholder1"];
            this.dashboardPlaceholder2 = _data["dashboardPlaceholder2"];
        }
    }

    static fromJS(data: any): TopStatsData {
        data = typeof data === 'object' ? data : {};
        let result = new TopStatsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newTenantsCount"] = this.newTenantsCount;
        data["newSubscriptionAmount"] = this.newSubscriptionAmount;
        data["dashboardPlaceholder1"] = this.dashboardPlaceholder1;
        data["dashboardPlaceholder2"] = this.dashboardPlaceholder2;
        return data;
    }
}

export interface ITopStatsData {
    newTenantsCount: number;
    newSubscriptionAmount: number;
    dashboardPlaceholder1: number;
    dashboardPlaceholder2: number;
}

export class RecentTenant implements IRecentTenant {
    id!: number;
    name!: string | undefined;
    creationTime!: DateTime;

    constructor(data?: IRecentTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecentTenant {
        data = typeof data === 'object' ? data : {};
        let result = new RecentTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        return data;
    }
}

export interface IRecentTenant {
    id: number;
    name: string | undefined;
    creationTime: DateTime;
}

export class GetRecentTenantsOutput implements IGetRecentTenantsOutput {
    recentTenantsDayCount!: number;
    maxRecentTenantsShownCount!: number;
    tenantCreationStartDate!: DateTime;
    recentTenants!: RecentTenant[] | undefined;

    constructor(data?: IGetRecentTenantsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recentTenantsDayCount = _data["recentTenantsDayCount"];
            this.maxRecentTenantsShownCount = _data["maxRecentTenantsShownCount"];
            this.tenantCreationStartDate = _data["tenantCreationStartDate"] ? DateTime.fromISO(_data["tenantCreationStartDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["recentTenants"])) {
                this.recentTenants = [] as any;
                for (let item of _data["recentTenants"])
                    this.recentTenants!.push(RecentTenant.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRecentTenantsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRecentTenantsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recentTenantsDayCount"] = this.recentTenantsDayCount;
        data["maxRecentTenantsShownCount"] = this.maxRecentTenantsShownCount;
        data["tenantCreationStartDate"] = this.tenantCreationStartDate ? this.tenantCreationStartDate.toString() : <any>undefined;
        if (Array.isArray(this.recentTenants)) {
            data["recentTenants"] = [];
            for (let item of this.recentTenants)
                data["recentTenants"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetRecentTenantsOutput {
    recentTenantsDayCount: number;
    maxRecentTenantsShownCount: number;
    tenantCreationStartDate: DateTime;
    recentTenants: RecentTenant[] | undefined;
}

export class ExpiringTenant implements IExpiringTenant {
    tenantName!: string | undefined;
    remainingDayCount!: number;

    constructor(data?: IExpiringTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantName = _data["tenantName"];
            this.remainingDayCount = _data["remainingDayCount"];
        }
    }

    static fromJS(data: any): ExpiringTenant {
        data = typeof data === 'object' ? data : {};
        let result = new ExpiringTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["remainingDayCount"] = this.remainingDayCount;
        return data;
    }
}

export interface IExpiringTenant {
    tenantName: string | undefined;
    remainingDayCount: number;
}

export class GetExpiringTenantsOutput implements IGetExpiringTenantsOutput {
    expiringTenants!: ExpiringTenant[] | undefined;
    subscriptionEndAlertDayCount!: number;
    maxExpiringTenantsShownCount!: number;
    subscriptionEndDateStart!: DateTime;
    subscriptionEndDateEnd!: DateTime;

    constructor(data?: IGetExpiringTenantsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["expiringTenants"])) {
                this.expiringTenants = [] as any;
                for (let item of _data["expiringTenants"])
                    this.expiringTenants!.push(ExpiringTenant.fromJS(item));
            }
            this.subscriptionEndAlertDayCount = _data["subscriptionEndAlertDayCount"];
            this.maxExpiringTenantsShownCount = _data["maxExpiringTenantsShownCount"];
            this.subscriptionEndDateStart = _data["subscriptionEndDateStart"] ? DateTime.fromISO(_data["subscriptionEndDateStart"].toString()) : <any>undefined;
            this.subscriptionEndDateEnd = _data["subscriptionEndDateEnd"] ? DateTime.fromISO(_data["subscriptionEndDateEnd"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetExpiringTenantsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetExpiringTenantsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.expiringTenants)) {
            data["expiringTenants"] = [];
            for (let item of this.expiringTenants)
                data["expiringTenants"].push(item.toJSON());
        }
        data["subscriptionEndAlertDayCount"] = this.subscriptionEndAlertDayCount;
        data["maxExpiringTenantsShownCount"] = this.maxExpiringTenantsShownCount;
        data["subscriptionEndDateStart"] = this.subscriptionEndDateStart ? this.subscriptionEndDateStart.toString() : <any>undefined;
        data["subscriptionEndDateEnd"] = this.subscriptionEndDateEnd ? this.subscriptionEndDateEnd.toString() : <any>undefined;
        return data;
    }
}

export interface IGetExpiringTenantsOutput {
    expiringTenants: ExpiringTenant[] | undefined;
    subscriptionEndAlertDayCount: number;
    maxExpiringTenantsShownCount: number;
    subscriptionEndDateStart: DateTime;
    subscriptionEndDateEnd: DateTime;
}

export enum ChartDateInterval {
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
}

export class IncomeStastistic implements IIncomeStastistic {
    label!: string | undefined;
    date!: DateTime;
    amount!: number;

    constructor(data?: IIncomeStastistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : <any>undefined;
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): IncomeStastistic {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeStastistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["date"] = this.date ? this.date.toString() : <any>undefined;
        data["amount"] = this.amount;
        return data;
    }
}

export interface IIncomeStastistic {
    label: string | undefined;
    date: DateTime;
    amount: number;
}

export class GetIncomeStatisticsDataOutput implements IGetIncomeStatisticsDataOutput {
    incomeStatistics!: IncomeStastistic[] | undefined;

    constructor(data?: IGetIncomeStatisticsDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["incomeStatistics"])) {
                this.incomeStatistics = [] as any;
                for (let item of _data["incomeStatistics"])
                    this.incomeStatistics!.push(IncomeStastistic.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetIncomeStatisticsDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncomeStatisticsDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.incomeStatistics)) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[] | undefined;
}

export class TenantEdition implements ITenantEdition {
    label!: string | undefined;
    value!: number;

    constructor(data?: ITenantEdition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): TenantEdition {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEdition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data;
    }
}

export interface ITenantEdition {
    label: string | undefined;
    value: number;
}

export class GetEditionTenantStatisticsOutput implements IGetEditionTenantStatisticsOutput {
    editionStatistics!: TenantEdition[] | undefined;

    constructor(data?: IGetEditionTenantStatisticsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["editionStatistics"])) {
                this.editionStatistics = [] as any;
                for (let item of _data["editionStatistics"])
                    this.editionStatistics!.push(TenantEdition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionTenantStatisticsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionTenantStatisticsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.editionStatistics)) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[] | undefined;
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    timezone!: string | undefined;
    timezoneForComparison!: string | undefined;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timezone = _data["timezone"];
            this.timezoneForComparison = _data["timezoneForComparison"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        return data;
    }
}

export interface IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;
}

export class SessionTimeOutSettingsEditDto implements ISessionTimeOutSettingsEditDto {
    isEnabled!: boolean;
    timeOutSecond!: number;
    showTimeOutNotificationSecond!: number;
    showLockScreenWhenTimedOut!: boolean;

    constructor(data?: ISessionTimeOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
            this.timeOutSecond = _data["timeOutSecond"];
            this.showTimeOutNotificationSecond = _data["showTimeOutNotificationSecond"];
            this.showLockScreenWhenTimedOut = _data["showLockScreenWhenTimedOut"];
        }
    }

    static fromJS(data: any): SessionTimeOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SessionTimeOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["timeOutSecond"] = this.timeOutSecond;
        data["showTimeOutNotificationSecond"] = this.showTimeOutNotificationSecond;
        data["showLockScreenWhenTimedOut"] = this.showLockScreenWhenTimedOut;
        return data;
    }
}

export interface ISessionTimeOutSettingsEditDto {
    isEnabled: boolean;
    timeOutSecond: number;
    showTimeOutNotificationSecond: number;
    showLockScreenWhenTimedOut: boolean;
}

export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin!: boolean;
    smsVerificationEnabled!: boolean;
    isCookieConsentEnabled!: boolean;
    isQuickThemeSelectEnabled!: boolean;
    useCaptchaOnLogin!: boolean;
    allowUsingGravatarProfilePicture!: boolean;
    sessionTimeOutSettings!: SessionTimeOutSettingsEditDto;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEmailConfirmationRequiredForLogin = _data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = _data["smsVerificationEnabled"];
            this.isCookieConsentEnabled = _data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
            this.useCaptchaOnLogin = _data["useCaptchaOnLogin"];
            this.allowUsingGravatarProfilePicture = _data["allowUsingGravatarProfilePicture"];
            this.sessionTimeOutSettings = _data["sessionTimeOutSettings"] ? SessionTimeOutSettingsEditDto.fromJS(_data["sessionTimeOutSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        data["useCaptchaOnLogin"] = this.useCaptchaOnLogin;
        data["allowUsingGravatarProfilePicture"] = this.allowUsingGravatarProfilePicture;
        data["sessionTimeOutSettings"] = this.sessionTimeOutSettings ? this.sessionTimeOutSettings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean;
    smsVerificationEnabled: boolean;
    isCookieConsentEnabled: boolean;
    isQuickThemeSelectEnabled: boolean;
    useCaptchaOnLogin: boolean;
    allowUsingGravatarProfilePicture: boolean;
    sessionTimeOutSettings: SessionTimeOutSettingsEditDto;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean;
    smtpUseDefaultCredentials!: boolean;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
            this.smtpHost = _data["smtpHost"];
            this.smtpPort = _data["smtpPort"];
            this.smtpUserName = _data["smtpUserName"];
            this.smtpPassword = _data["smtpPassword"];
            this.smtpDomain = _data["smtpDomain"];
            this.smtpEnableSsl = _data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data;
    }
}

export interface IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    allowSelfRegistration!: boolean;
    isNewRegisteredTenantActiveByDefault!: boolean;
    useCaptchaOnRegistration!: boolean;
    defaultEditionId!: number | undefined;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowSelfRegistration = _data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = _data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnRegistration = _data["useCaptchaOnRegistration"];
            this.defaultEditionId = _data["defaultEditionId"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["defaultEditionId"] = this.defaultEditionId;
        return data;
    }
}

export interface ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredTenantActiveByDefault: boolean;
    useCaptchaOnRegistration: boolean;
    defaultEditionId: number | undefined;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    requireDigit!: boolean;
    requireLowercase!: boolean;
    requireNonAlphanumeric!: boolean;
    requireUppercase!: boolean;
    requiredLength!: number;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requireDigit = _data["requireDigit"];
            this.requireLowercase = _data["requireLowercase"];
            this.requireNonAlphanumeric = _data["requireNonAlphanumeric"];
            this.requireUppercase = _data["requireUppercase"];
            this.requiredLength = _data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data;
    }
}

export interface IPasswordComplexitySetting {
    requireDigit: boolean;
    requireLowercase: boolean;
    requireNonAlphanumeric: boolean;
    requireUppercase: boolean;
    requiredLength: number;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    isEnabled!: boolean;
    maxFailedAccessAttemptsBeforeLockout!: number;
    defaultAccountLockoutSeconds!: number;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = _data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = _data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data;
    }
}

export interface IUserLockOutSettingsEditDto {
    isEnabled: boolean;
    maxFailedAccessAttemptsBeforeLockout: number;
    defaultAccountLockoutSeconds: number;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication!: boolean;
    isEnabled!: boolean;
    isEmailProviderEnabled!: boolean;
    isSmsProviderEnabled!: boolean;
    isRememberBrowserEnabled!: boolean;
    isGoogleAuthenticatorEnabled!: boolean;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabledForApplication = _data["isEnabledForApplication"];
            this.isEnabled = _data["isEnabled"];
            this.isEmailProviderEnabled = _data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = _data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = _data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = _data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data;
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean;
    isEnabled: boolean;
    isEmailProviderEnabled: boolean;
    isSmsProviderEnabled: boolean;
    isRememberBrowserEnabled: boolean;
    isGoogleAuthenticatorEnabled: boolean;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    allowOneConcurrentLoginPerUser!: boolean;
    useDefaultPasswordComplexitySettings!: boolean;
    passwordComplexity!: PasswordComplexitySetting;
    defaultPasswordComplexity!: PasswordComplexitySetting;
    userLockOut!: UserLockOutSettingsEditDto;
    twoFactorLogin!: TwoFactorLoginSettingsEditDto;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowOneConcurrentLoginPerUser = _data["allowOneConcurrentLoginPerUser"];
            this.useDefaultPasswordComplexitySettings = _data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = _data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(_data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = _data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(_data["defaultPasswordComplexity"]) : <any>undefined;
            this.userLockOut = _data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(_data["userLockOut"]) : <any>undefined;
            this.twoFactorLogin = _data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(_data["twoFactorLogin"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowOneConcurrentLoginPerUser"] = this.allowOneConcurrentLoginPerUser;
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISecuritySettingsEditDto {
    allowOneConcurrentLoginPerUser: boolean;
    useDefaultPasswordComplexitySettings: boolean;
    passwordComplexity: PasswordComplexitySetting;
    defaultPasswordComplexity: PasswordComplexitySetting;
    userLockOut: UserLockOutSettingsEditDto;
    twoFactorLogin: TwoFactorLoginSettingsEditDto;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;

    constructor(data?: IHostBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.legalName = _data["legalName"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): HostBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        return data;
    }
}

export interface IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
}

export class OtherSettingsEditDto implements IOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean;

    constructor(data?: IOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): OtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data;
    }
}

export interface IOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean;
}

export class FacebookExternalLoginProviderSettings implements IFacebookExternalLoginProviderSettings {
    appId!: string | undefined;
    appSecret!: string | undefined;

    constructor(data?: IFacebookExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appId = _data["appId"];
            this.appSecret = _data["appSecret"];
        }
    }

    static fromJS(data: any): FacebookExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new FacebookExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId;
        data["appSecret"] = this.appSecret;
        return data;
    }
}

export interface IFacebookExternalLoginProviderSettings {
    appId: string | undefined;
    appSecret: string | undefined;
}

export class GoogleExternalLoginProviderSettings implements IGoogleExternalLoginProviderSettings {
    clientId!: string | undefined;
    clientSecret!: string | undefined;
    userInfoEndpoint!: string | undefined;

    constructor(data?: IGoogleExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
            this.userInfoEndpoint = _data["userInfoEndpoint"];
        }
    }

    static fromJS(data: any): GoogleExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new GoogleExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        data["userInfoEndpoint"] = this.userInfoEndpoint;
        return data;
    }
}

export interface IGoogleExternalLoginProviderSettings {
    clientId: string | undefined;
    clientSecret: string | undefined;
    userInfoEndpoint: string | undefined;
}

export class TwitterExternalLoginProviderSettings implements ITwitterExternalLoginProviderSettings {
    consumerKey!: string | undefined;
    consumerSecret!: string | undefined;

    constructor(data?: ITwitterExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consumerKey = _data["consumerKey"];
            this.consumerSecret = _data["consumerSecret"];
        }
    }

    static fromJS(data: any): TwitterExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new TwitterExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consumerKey"] = this.consumerKey;
        data["consumerSecret"] = this.consumerSecret;
        return data;
    }
}

export interface ITwitterExternalLoginProviderSettings {
    consumerKey: string | undefined;
    consumerSecret: string | undefined;
}

export class MicrosoftExternalLoginProviderSettings implements IMicrosoftExternalLoginProviderSettings {
    clientId!: string | undefined;
    clientSecret!: string | undefined;

    constructor(data?: IMicrosoftExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
        }
    }

    static fromJS(data: any): MicrosoftExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new MicrosoftExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        return data;
    }
}

export interface IMicrosoftExternalLoginProviderSettings {
    clientId: string | undefined;
    clientSecret: string | undefined;
}

export class OpenIdConnectExternalLoginProviderSettings implements IOpenIdConnectExternalLoginProviderSettings {
    clientId!: string | undefined;
    clientSecret!: string | undefined;
    authority!: string | undefined;
    loginUrl!: string | undefined;
    validateIssuer!: boolean;

    constructor(data?: IOpenIdConnectExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
            this.authority = _data["authority"];
            this.loginUrl = _data["loginUrl"];
            this.validateIssuer = _data["validateIssuer"];
        }
    }

    static fromJS(data: any): OpenIdConnectExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new OpenIdConnectExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        data["authority"] = this.authority;
        data["loginUrl"] = this.loginUrl;
        data["validateIssuer"] = this.validateIssuer;
        return data;
    }
}

export interface IOpenIdConnectExternalLoginProviderSettings {
    clientId: string | undefined;
    clientSecret: string | undefined;
    authority: string | undefined;
    loginUrl: string | undefined;
    validateIssuer: boolean;
}

export class JsonClaimMapDto implements IJsonClaimMapDto {
    claim!: string | undefined;
    key!: string | undefined;

    constructor(data?: IJsonClaimMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.claim = _data["claim"];
            this.key = _data["key"];
        }
    }

    static fromJS(data: any): JsonClaimMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new JsonClaimMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["claim"] = this.claim;
        data["key"] = this.key;
        return data;
    }
}

export interface IJsonClaimMapDto {
    claim: string | undefined;
    key: string | undefined;
}

export class WsFederationExternalLoginProviderSettings implements IWsFederationExternalLoginProviderSettings {
    clientId!: string | undefined;
    tenant!: string | undefined;
    metaDataAddress!: string | undefined;
    wtrealm!: string | undefined;
    authority!: string | undefined;

    constructor(data?: IWsFederationExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.tenant = _data["tenant"];
            this.metaDataAddress = _data["metaDataAddress"];
            this.wtrealm = _data["wtrealm"];
            this.authority = _data["authority"];
        }
    }

    static fromJS(data: any): WsFederationExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new WsFederationExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["tenant"] = this.tenant;
        data["metaDataAddress"] = this.metaDataAddress;
        data["wtrealm"] = this.wtrealm;
        data["authority"] = this.authority;
        return data;
    }
}

export interface IWsFederationExternalLoginProviderSettings {
    clientId: string | undefined;
    tenant: string | undefined;
    metaDataAddress: string | undefined;
    wtrealm: string | undefined;
    authority: string | undefined;
}

export class ExternalLoginProviderSettingsEditDto implements IExternalLoginProviderSettingsEditDto {
    facebook_IsDeactivated!: boolean;
    facebook!: FacebookExternalLoginProviderSettings;
    google_IsDeactivated!: boolean;
    google!: GoogleExternalLoginProviderSettings;
    twitter_IsDeactivated!: boolean;
    twitter!: TwitterExternalLoginProviderSettings;
    microsoft_IsDeactivated!: boolean;
    microsoft!: MicrosoftExternalLoginProviderSettings;
    openIdConnect_IsDeactivated!: boolean;
    openIdConnect!: OpenIdConnectExternalLoginProviderSettings;
    openIdConnectClaimsMapping!: JsonClaimMapDto[] | undefined;
    wsFederation_IsDeactivated!: boolean;
    wsFederation!: WsFederationExternalLoginProviderSettings;
    wsFederationClaimsMapping!: JsonClaimMapDto[] | undefined;

    constructor(data?: IExternalLoginProviderSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.facebook_IsDeactivated = _data["facebook_IsDeactivated"];
            this.facebook = _data["facebook"] ? FacebookExternalLoginProviderSettings.fromJS(_data["facebook"]) : <any>undefined;
            this.google_IsDeactivated = _data["google_IsDeactivated"];
            this.google = _data["google"] ? GoogleExternalLoginProviderSettings.fromJS(_data["google"]) : <any>undefined;
            this.twitter_IsDeactivated = _data["twitter_IsDeactivated"];
            this.twitter = _data["twitter"] ? TwitterExternalLoginProviderSettings.fromJS(_data["twitter"]) : <any>undefined;
            this.microsoft_IsDeactivated = _data["microsoft_IsDeactivated"];
            this.microsoft = _data["microsoft"] ? MicrosoftExternalLoginProviderSettings.fromJS(_data["microsoft"]) : <any>undefined;
            this.openIdConnect_IsDeactivated = _data["openIdConnect_IsDeactivated"];
            this.openIdConnect = _data["openIdConnect"] ? OpenIdConnectExternalLoginProviderSettings.fromJS(_data["openIdConnect"]) : <any>undefined;
            if (Array.isArray(_data["openIdConnectClaimsMapping"])) {
                this.openIdConnectClaimsMapping = [] as any;
                for (let item of _data["openIdConnectClaimsMapping"])
                    this.openIdConnectClaimsMapping!.push(JsonClaimMapDto.fromJS(item));
            }
            this.wsFederation_IsDeactivated = _data["wsFederation_IsDeactivated"];
            this.wsFederation = _data["wsFederation"] ? WsFederationExternalLoginProviderSettings.fromJS(_data["wsFederation"]) : <any>undefined;
            if (Array.isArray(_data["wsFederationClaimsMapping"])) {
                this.wsFederationClaimsMapping = [] as any;
                for (let item of _data["wsFederationClaimsMapping"])
                    this.wsFederationClaimsMapping!.push(JsonClaimMapDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["facebook_IsDeactivated"] = this.facebook_IsDeactivated;
        data["facebook"] = this.facebook ? this.facebook.toJSON() : <any>undefined;
        data["google_IsDeactivated"] = this.google_IsDeactivated;
        data["google"] = this.google ? this.google.toJSON() : <any>undefined;
        data["twitter_IsDeactivated"] = this.twitter_IsDeactivated;
        data["twitter"] = this.twitter ? this.twitter.toJSON() : <any>undefined;
        data["microsoft_IsDeactivated"] = this.microsoft_IsDeactivated;
        data["microsoft"] = this.microsoft ? this.microsoft.toJSON() : <any>undefined;
        data["openIdConnect_IsDeactivated"] = this.openIdConnect_IsDeactivated;
        data["openIdConnect"] = this.openIdConnect ? this.openIdConnect.toJSON() : <any>undefined;
        if (Array.isArray(this.openIdConnectClaimsMapping)) {
            data["openIdConnectClaimsMapping"] = [];
            for (let item of this.openIdConnectClaimsMapping)
                data["openIdConnectClaimsMapping"].push(item.toJSON());
        }
        data["wsFederation_IsDeactivated"] = this.wsFederation_IsDeactivated;
        data["wsFederation"] = this.wsFederation ? this.wsFederation.toJSON() : <any>undefined;
        if (Array.isArray(this.wsFederationClaimsMapping)) {
            data["wsFederationClaimsMapping"] = [];
            for (let item of this.wsFederationClaimsMapping)
                data["wsFederationClaimsMapping"].push(item.toJSON());
        }
        return data;
    }
}

export interface IExternalLoginProviderSettingsEditDto {
    facebook_IsDeactivated: boolean;
    facebook: FacebookExternalLoginProviderSettings;
    google_IsDeactivated: boolean;
    google: GoogleExternalLoginProviderSettings;
    twitter_IsDeactivated: boolean;
    twitter: TwitterExternalLoginProviderSettings;
    microsoft_IsDeactivated: boolean;
    microsoft: MicrosoftExternalLoginProviderSettings;
    openIdConnect_IsDeactivated: boolean;
    openIdConnect: OpenIdConnectExternalLoginProviderSettings;
    openIdConnectClaimsMapping: JsonClaimMapDto[] | undefined;
    wsFederation_IsDeactivated: boolean;
    wsFederation: WsFederationExternalLoginProviderSettings;
    wsFederationClaimsMapping: JsonClaimMapDto[] | undefined;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: HostUserManagementSettingsEditDto;
    email!: EmailSettingsEditDto;
    tenantManagement!: TenantManagementSettingsEditDto;
    security!: SecuritySettingsEditDto;
    billing!: HostBillingSettingsEditDto;
    otherSettings!: OtherSettingsEditDto;
    externalLoginProviderSettings!: ExternalLoginProviderSettingsEditDto;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new HostUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.tenantManagement = new TenantManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.general = _data["general"] ? GeneralSettingsEditDto.fromJS(_data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = _data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(_data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = _data["email"] ? EmailSettingsEditDto.fromJS(_data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = _data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(_data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = _data["security"] ? SecuritySettingsEditDto.fromJS(_data["security"]) : new SecuritySettingsEditDto();
            this.billing = _data["billing"] ? HostBillingSettingsEditDto.fromJS(_data["billing"]) : <any>undefined;
            this.otherSettings = _data["otherSettings"] ? OtherSettingsEditDto.fromJS(_data["otherSettings"]) : <any>undefined;
            this.externalLoginProviderSettings = _data["externalLoginProviderSettings"] ? ExternalLoginProviderSettingsEditDto.fromJS(_data["externalLoginProviderSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        data["externalLoginProviderSettings"] = this.externalLoginProviderSettings ? this.externalLoginProviderSettings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto;
    otherSettings: OtherSettingsEditDto;
    externalLoginProviderSettings: ExternalLoginProviderSettingsEditDto;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress!: string;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface ISendTestEmailInput {
    emailAddress: string;
}

export class ExternalLoginSettingsDto implements IExternalLoginSettingsDto {
    enabledSocialLoginSettings!: string[] | undefined;

    constructor(data?: IExternalLoginSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["enabledSocialLoginSettings"])) {
                this.enabledSocialLoginSettings = [] as any;
                for (let item of _data["enabledSocialLoginSettings"])
                    this.enabledSocialLoginSettings!.push(item);
            }
        }
    }

    static fromJS(data: any): ExternalLoginSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.enabledSocialLoginSettings)) {
            data["enabledSocialLoginSettings"] = [];
            for (let item of this.enabledSocialLoginSettings)
                data["enabledSocialLoginSettings"].push(item);
        }
        return data;
    }
}

export interface IExternalLoginSettingsDto {
    enabledSocialLoginSettings: string[] | undefined;
}

export class ImpInventoryItemPriceTempDto implements IImpInventoryItemPriceTempDto {
    itemsCode!: string | undefined;
    partNameSupplier!: string | undefined;
    supplierCode!: string | undefined;
    taxPrice!: number | undefined;
    unitOfMeasure!: string | undefined;
    unitPrice!: number | undefined;
    currencyCode!: string | undefined;
    effectiveFrom!: DateTime | undefined;
    effectiveTo!: DateTime | undefined;
    currencyId!: number | undefined;
    supplierId!: number | undefined;
    unitOfMeasureId!: number | undefined;
    inventoryItemId!: number | undefined;
    creatorUserId!: number | undefined;
    remark!: string | undefined;

    constructor(data?: IImpInventoryItemPriceTempDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemsCode = _data["itemsCode"];
            this.partNameSupplier = _data["partNameSupplier"];
            this.supplierCode = _data["supplierCode"];
            this.taxPrice = _data["taxPrice"];
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.unitPrice = _data["unitPrice"];
            this.currencyCode = _data["currencyCode"];
            this.effectiveFrom = _data["effectiveFrom"] ? DateTime.fromISO(_data["effectiveFrom"].toString()) : <any>undefined;
            this.effectiveTo = _data["effectiveTo"] ? DateTime.fromISO(_data["effectiveTo"].toString()) : <any>undefined;
            this.currencyId = _data["currencyId"];
            this.supplierId = _data["supplierId"];
            this.unitOfMeasureId = _data["unitOfMeasureId"];
            this.inventoryItemId = _data["inventoryItemId"];
            this.creatorUserId = _data["creatorUserId"];
            this.remark = _data["remark"];
        }
    }

    static fromJS(data: any): ImpInventoryItemPriceTempDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImpInventoryItemPriceTempDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemsCode"] = this.itemsCode;
        data["partNameSupplier"] = this.partNameSupplier;
        data["supplierCode"] = this.supplierCode;
        data["taxPrice"] = this.taxPrice;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["unitPrice"] = this.unitPrice;
        data["currencyCode"] = this.currencyCode;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toString() : <any>undefined;
        data["effectiveTo"] = this.effectiveTo ? this.effectiveTo.toString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        data["supplierId"] = this.supplierId;
        data["unitOfMeasureId"] = this.unitOfMeasureId;
        data["inventoryItemId"] = this.inventoryItemId;
        data["creatorUserId"] = this.creatorUserId;
        data["remark"] = this.remark;
        return data;
    }
}

export interface IImpInventoryItemPriceTempDto {
    itemsCode: string | undefined;
    partNameSupplier: string | undefined;
    supplierCode: string | undefined;
    taxPrice: number | undefined;
    unitOfMeasure: string | undefined;
    unitPrice: number | undefined;
    currencyCode: string | undefined;
    effectiveFrom: DateTime | undefined;
    effectiveTo: DateTime | undefined;
    currencyId: number | undefined;
    supplierId: number | undefined;
    unitOfMeasureId: number | undefined;
    inventoryItemId: number | undefined;
    creatorUserId: number | undefined;
    remark: string | undefined;
}

export class ImportPrDto implements IImportPrDto {
    productCode!: string | undefined;
    productName!: string | undefined;
    productGroupName!: string | undefined;
    uom!: string | undefined;
    organizationCode!: string | undefined;
    comments!: string | undefined;
    location!: string | undefined;
    budgetCode!: string | undefined;
    unitPrice!: string | undefined;
    delivery1!: string | undefined;
    delivery2!: string | undefined;
    delivery3!: string | undefined;
    delivery4!: string | undefined;
    delivery5!: string | undefined;
    delivery6!: string | undefined;
    delivery7!: string | undefined;
    delivery8!: string | undefined;
    delivery9!: string | undefined;
    delivery10!: string | undefined;
    delivery11!: string | undefined;
    delivery12!: string | undefined;
    delivery13!: string | undefined;
    delivery14!: string | undefined;
    delivery15!: string | undefined;
    delivery16!: string | undefined;
    delivery17!: string | undefined;
    delivery18!: string | undefined;
    delivery19!: string | undefined;
    delivery20!: string | undefined;
    delivery21!: string | undefined;
    delivery22!: string | undefined;
    delivery23!: string | undefined;
    delivery24!: string | undefined;
    delivery25!: string | undefined;
    delivery26!: string | undefined;
    delivery27!: string | undefined;
    delivery28!: string | undefined;
    delivery29!: string | undefined;
    delivery30!: string | undefined;
    delivery31!: string | undefined;
    monthN!: string | undefined;
    monthN1!: string | undefined;
    monthN2!: string | undefined;
    monthN3!: string | undefined;
    vendorName!: string | undefined;
    vendorSite!: string | undefined;
    exception!: string | undefined;
    remark!: string | undefined;

    constructor(data?: IImportPrDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.productGroupName = _data["productGroupName"];
            this.uom = _data["uom"];
            this.organizationCode = _data["organizationCode"];
            this.comments = _data["comments"];
            this.location = _data["location"];
            this.budgetCode = _data["budgetCode"];
            this.unitPrice = _data["unitPrice"];
            this.delivery1 = _data["delivery1"];
            this.delivery2 = _data["delivery2"];
            this.delivery3 = _data["delivery3"];
            this.delivery4 = _data["delivery4"];
            this.delivery5 = _data["delivery5"];
            this.delivery6 = _data["delivery6"];
            this.delivery7 = _data["delivery7"];
            this.delivery8 = _data["delivery8"];
            this.delivery9 = _data["delivery9"];
            this.delivery10 = _data["delivery10"];
            this.delivery11 = _data["delivery11"];
            this.delivery12 = _data["delivery12"];
            this.delivery13 = _data["delivery13"];
            this.delivery14 = _data["delivery14"];
            this.delivery15 = _data["delivery15"];
            this.delivery16 = _data["delivery16"];
            this.delivery17 = _data["delivery17"];
            this.delivery18 = _data["delivery18"];
            this.delivery19 = _data["delivery19"];
            this.delivery20 = _data["delivery20"];
            this.delivery21 = _data["delivery21"];
            this.delivery22 = _data["delivery22"];
            this.delivery23 = _data["delivery23"];
            this.delivery24 = _data["delivery24"];
            this.delivery25 = _data["delivery25"];
            this.delivery26 = _data["delivery26"];
            this.delivery27 = _data["delivery27"];
            this.delivery28 = _data["delivery28"];
            this.delivery29 = _data["delivery29"];
            this.delivery30 = _data["delivery30"];
            this.delivery31 = _data["delivery31"];
            this.monthN = _data["monthN"];
            this.monthN1 = _data["monthN1"];
            this.monthN2 = _data["monthN2"];
            this.monthN3 = _data["monthN3"];
            this.vendorName = _data["vendorName"];
            this.vendorSite = _data["vendorSite"];
            this.exception = _data["exception"];
            this.remark = _data["remark"];
        }
    }

    static fromJS(data: any): ImportPrDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportPrDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productGroupName"] = this.productGroupName;
        data["uom"] = this.uom;
        data["organizationCode"] = this.organizationCode;
        data["comments"] = this.comments;
        data["location"] = this.location;
        data["budgetCode"] = this.budgetCode;
        data["unitPrice"] = this.unitPrice;
        data["delivery1"] = this.delivery1;
        data["delivery2"] = this.delivery2;
        data["delivery3"] = this.delivery3;
        data["delivery4"] = this.delivery4;
        data["delivery5"] = this.delivery5;
        data["delivery6"] = this.delivery6;
        data["delivery7"] = this.delivery7;
        data["delivery8"] = this.delivery8;
        data["delivery9"] = this.delivery9;
        data["delivery10"] = this.delivery10;
        data["delivery11"] = this.delivery11;
        data["delivery12"] = this.delivery12;
        data["delivery13"] = this.delivery13;
        data["delivery14"] = this.delivery14;
        data["delivery15"] = this.delivery15;
        data["delivery16"] = this.delivery16;
        data["delivery17"] = this.delivery17;
        data["delivery18"] = this.delivery18;
        data["delivery19"] = this.delivery19;
        data["delivery20"] = this.delivery20;
        data["delivery21"] = this.delivery21;
        data["delivery22"] = this.delivery22;
        data["delivery23"] = this.delivery23;
        data["delivery24"] = this.delivery24;
        data["delivery25"] = this.delivery25;
        data["delivery26"] = this.delivery26;
        data["delivery27"] = this.delivery27;
        data["delivery28"] = this.delivery28;
        data["delivery29"] = this.delivery29;
        data["delivery30"] = this.delivery30;
        data["delivery31"] = this.delivery31;
        data["monthN"] = this.monthN;
        data["monthN1"] = this.monthN1;
        data["monthN2"] = this.monthN2;
        data["monthN3"] = this.monthN3;
        data["vendorName"] = this.vendorName;
        data["vendorSite"] = this.vendorSite;
        data["exception"] = this.exception;
        data["remark"] = this.remark;
        return data;
    }
}

export interface IImportPrDto {
    productCode: string | undefined;
    productName: string | undefined;
    productGroupName: string | undefined;
    uom: string | undefined;
    organizationCode: string | undefined;
    comments: string | undefined;
    location: string | undefined;
    budgetCode: string | undefined;
    unitPrice: string | undefined;
    delivery1: string | undefined;
    delivery2: string | undefined;
    delivery3: string | undefined;
    delivery4: string | undefined;
    delivery5: string | undefined;
    delivery6: string | undefined;
    delivery7: string | undefined;
    delivery8: string | undefined;
    delivery9: string | undefined;
    delivery10: string | undefined;
    delivery11: string | undefined;
    delivery12: string | undefined;
    delivery13: string | undefined;
    delivery14: string | undefined;
    delivery15: string | undefined;
    delivery16: string | undefined;
    delivery17: string | undefined;
    delivery18: string | undefined;
    delivery19: string | undefined;
    delivery20: string | undefined;
    delivery21: string | undefined;
    delivery22: string | undefined;
    delivery23: string | undefined;
    delivery24: string | undefined;
    delivery25: string | undefined;
    delivery26: string | undefined;
    delivery27: string | undefined;
    delivery28: string | undefined;
    delivery29: string | undefined;
    delivery30: string | undefined;
    delivery31: string | undefined;
    monthN: string | undefined;
    monthN1: string | undefined;
    monthN2: string | undefined;
    monthN3: string | undefined;
    vendorName: string | undefined;
    vendorSite: string | undefined;
    exception: string | undefined;
    remark: string | undefined;
}

export class PoImportPurchaseOrderDto implements IPoImportPurchaseOrderDto {
    productCode!: string | undefined;
    productName!: string | undefined;
    productGroupName!: string | undefined;
    comments!: string | undefined;
    uom!: string | undefined;
    quantity!: string | undefined;
    unitPrice!: string | undefined;
    budgetCode!: string | undefined;
    vendorName!: string | undefined;
    vendorId!: number | undefined;
    vendorSiteName!: string | undefined;
    vendorSiteId!: number | undefined;
    priceType!: string | undefined;
    contract!: string | undefined;
    needByPaintSteel!: string | undefined;
    needByLocalParts!: string | undefined;
    requisition!: string | undefined;
    glDate!: string | undefined;
    organization!: string | undefined;
    destinationType!: string | undefined;
    requester!: string | undefined;
    location!: string | undefined;
    subinventory!: string | undefined;
    minimumReleaseAmount!: string | undefined;
    transactionNature!: string | undefined;
    promised!: string | undefined;
    requisitionLine!: string | undefined;
    chargeAccount!: string | undefined;
    shipTo!: string | undefined;
    remark!: string | undefined;
    exception!: string | undefined;

    constructor(data?: IPoImportPurchaseOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.productGroupName = _data["productGroupName"];
            this.comments = _data["comments"];
            this.uom = _data["uom"];
            this.quantity = _data["quantity"];
            this.unitPrice = _data["unitPrice"];
            this.budgetCode = _data["budgetCode"];
            this.vendorName = _data["vendorName"];
            this.vendorId = _data["vendorId"];
            this.vendorSiteName = _data["vendorSiteName"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.priceType = _data["priceType"];
            this.contract = _data["contract"];
            this.needByPaintSteel = _data["needByPaintSteel"];
            this.needByLocalParts = _data["needByLocalParts"];
            this.requisition = _data["requisition"];
            this.glDate = _data["glDate"];
            this.organization = _data["organization"];
            this.destinationType = _data["destinationType"];
            this.requester = _data["requester"];
            this.location = _data["location"];
            this.subinventory = _data["subinventory"];
            this.minimumReleaseAmount = _data["minimumReleaseAmount"];
            this.transactionNature = _data["transactionNature"];
            this.promised = _data["promised"];
            this.requisitionLine = _data["requisitionLine"];
            this.chargeAccount = _data["chargeAccount"];
            this.shipTo = _data["shipTo"];
            this.remark = _data["remark"];
            this.exception = _data["exception"];
        }
    }

    static fromJS(data: any): PoImportPurchaseOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PoImportPurchaseOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productGroupName"] = this.productGroupName;
        data["comments"] = this.comments;
        data["uom"] = this.uom;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["budgetCode"] = this.budgetCode;
        data["vendorName"] = this.vendorName;
        data["vendorId"] = this.vendorId;
        data["vendorSiteName"] = this.vendorSiteName;
        data["vendorSiteId"] = this.vendorSiteId;
        data["priceType"] = this.priceType;
        data["contract"] = this.contract;
        data["needByPaintSteel"] = this.needByPaintSteel;
        data["needByLocalParts"] = this.needByLocalParts;
        data["requisition"] = this.requisition;
        data["glDate"] = this.glDate;
        data["organization"] = this.organization;
        data["destinationType"] = this.destinationType;
        data["requester"] = this.requester;
        data["location"] = this.location;
        data["subinventory"] = this.subinventory;
        data["minimumReleaseAmount"] = this.minimumReleaseAmount;
        data["transactionNature"] = this.transactionNature;
        data["promised"] = this.promised;
        data["requisitionLine"] = this.requisitionLine;
        data["chargeAccount"] = this.chargeAccount;
        data["shipTo"] = this.shipTo;
        data["remark"] = this.remark;
        data["exception"] = this.exception;
        return data;
    }
}

export interface IPoImportPurchaseOrderDto {
    productCode: string | undefined;
    productName: string | undefined;
    productGroupName: string | undefined;
    comments: string | undefined;
    uom: string | undefined;
    quantity: string | undefined;
    unitPrice: string | undefined;
    budgetCode: string | undefined;
    vendorName: string | undefined;
    vendorId: number | undefined;
    vendorSiteName: string | undefined;
    vendorSiteId: number | undefined;
    priceType: string | undefined;
    contract: string | undefined;
    needByPaintSteel: string | undefined;
    needByLocalParts: string | undefined;
    requisition: string | undefined;
    glDate: string | undefined;
    organization: string | undefined;
    destinationType: string | undefined;
    requester: string | undefined;
    location: string | undefined;
    subinventory: string | undefined;
    minimumReleaseAmount: string | undefined;
    transactionNature: string | undefined;
    promised: string | undefined;
    requisitionLine: string | undefined;
    chargeAccount: string | undefined;
    shipTo: string | undefined;
    remark: string | undefined;
    exception: string | undefined;
}

export class InstallDto implements IInstallDto {
    connectionString!: string;
    adminPassword!: string;
    webSiteUrl!: string;
    serverUrl!: string | undefined;
    defaultLanguage!: string;
    smtpSettings!: EmailSettingsEditDto;
    billInfo!: HostBillingSettingsEditDto;

    constructor(data?: IInstallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connectionString = _data["connectionString"];
            this.adminPassword = _data["adminPassword"];
            this.webSiteUrl = _data["webSiteUrl"];
            this.serverUrl = _data["serverUrl"];
            this.defaultLanguage = _data["defaultLanguage"];
            this.smtpSettings = _data["smtpSettings"] ? EmailSettingsEditDto.fromJS(_data["smtpSettings"]) : <any>undefined;
            this.billInfo = _data["billInfo"] ? HostBillingSettingsEditDto.fromJS(_data["billInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InstallDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionString"] = this.connectionString;
        data["adminPassword"] = this.adminPassword;
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverUrl"] = this.serverUrl;
        data["defaultLanguage"] = this.defaultLanguage;
        data["smtpSettings"] = this.smtpSettings ? this.smtpSettings.toJSON() : <any>undefined;
        data["billInfo"] = this.billInfo ? this.billInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IInstallDto {
    connectionString: string;
    adminPassword: string;
    webSiteUrl: string;
    serverUrl: string | undefined;
    defaultLanguage: string;
    smtpSettings: EmailSettingsEditDto;
    billInfo: HostBillingSettingsEditDto;
}

export class NameValue implements INameValue {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface INameValue {
    name: string | undefined;
    value: string | undefined;
}

export class AppSettingsJsonDto implements IAppSettingsJsonDto {
    webSiteUrl!: string | undefined;
    serverSiteUrl!: string | undefined;
    languages!: NameValue[] | undefined;

    constructor(data?: IAppSettingsJsonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.webSiteUrl = _data["webSiteUrl"];
            this.serverSiteUrl = _data["serverSiteUrl"];
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(NameValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppSettingsJsonDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingsJsonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverSiteUrl"] = this.serverSiteUrl;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAppSettingsJsonDto {
    webSiteUrl: string | undefined;
    serverSiteUrl: string | undefined;
    languages: NameValue[] | undefined;
}

export class CheckDatabaseOutput implements ICheckDatabaseOutput {
    isDatabaseExist!: boolean;

    constructor(data?: ICheckDatabaseOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isDatabaseExist = _data["isDatabaseExist"];
        }
    }

    static fromJS(data: any): CheckDatabaseOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckDatabaseOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDatabaseExist"] = this.isDatabaseExist;
        return data;
    }
}

export interface ICheckDatabaseOutput {
    isDatabaseExist: boolean;
}

export class InvoiceDto implements IInvoiceDto {
    amount!: number;
    editionDisplayName!: string | undefined;
    invoiceNo!: string | undefined;
    invoiceDate!: DateTime;
    tenantLegalName!: string | undefined;
    tenantAddress!: string[] | undefined;
    tenantTaxNo!: string | undefined;
    hostLegalName!: string | undefined;
    hostAddress!: string[] | undefined;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.editionDisplayName = _data["editionDisplayName"];
            this.invoiceNo = _data["invoiceNo"];
            this.invoiceDate = _data["invoiceDate"] ? DateTime.fromISO(_data["invoiceDate"].toString()) : <any>undefined;
            this.tenantLegalName = _data["tenantLegalName"];
            if (Array.isArray(_data["tenantAddress"])) {
                this.tenantAddress = [] as any;
                for (let item of _data["tenantAddress"])
                    this.tenantAddress!.push(item);
            }
            this.tenantTaxNo = _data["tenantTaxNo"];
            this.hostLegalName = _data["hostLegalName"];
            if (Array.isArray(_data["hostAddress"])) {
                this.hostAddress = [] as any;
                for (let item of _data["hostAddress"])
                    this.hostAddress!.push(item);
            }
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toString() : <any>undefined;
        data["tenantLegalName"] = this.tenantLegalName;
        if (Array.isArray(this.tenantAddress)) {
            data["tenantAddress"] = [];
            for (let item of this.tenantAddress)
                data["tenantAddress"].push(item);
        }
        data["tenantTaxNo"] = this.tenantTaxNo;
        data["hostLegalName"] = this.hostLegalName;
        if (Array.isArray(this.hostAddress)) {
            data["hostAddress"] = [];
            for (let item of this.hostAddress)
                data["hostAddress"].push(item);
        }
        return data;
    }
}

export interface IInvoiceDto {
    amount: number;
    editionDisplayName: string | undefined;
    invoiceNo: string | undefined;
    invoiceDate: DateTime;
    tenantLegalName: string | undefined;
    tenantAddress: string[] | undefined;
    tenantTaxNo: string | undefined;
    hostLegalName: string | undefined;
    hostAddress: string[] | undefined;
}

export class CreateInvoiceDto implements ICreateInvoiceDto {
    subscriptionPaymentId!: number;

    constructor(data?: ICreateInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionPaymentId = _data["subscriptionPaymentId"];
        }
    }

    static fromJS(data: any): CreateInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionPaymentId"] = this.subscriptionPaymentId;
        return data;
    }
}

export interface ICreateInvoiceDto {
    subscriptionPaymentId: number;
}

export class SearchInvoiceOutputDetailDto implements ISearchInvoiceOutputDetailDto {
    id!: number | undefined;
    poNumber!: string | undefined;
    poHeaderId!: number | undefined;
    itemNumber!: string | undefined;
    itemDescription!: string | undefined;
    quantity!: number | undefined;
    quantityStr!: string | undefined;
    quantityOrder!: number | undefined;
    quantityOrderStr!: string | undefined;
    foreignPrice!: number | undefined;
    foreignPriceStr!: string | undefined;
    quantityReceived!: number | undefined;
    quantityReceivedStr!: string | undefined;
    quantityMatched!: number | undefined;
    quantityMatchedStr!: string | undefined;
    quantityGR!: number | undefined;
    quantityPayment!: number | undefined;
    qtyRemainGR!: number | undefined;
    toVnd!: number | undefined;
    vndPrice!: number | undefined;
    amount!: number | undefined;
    totalAmount!: number | undefined;
    taxRate!: number | undefined;
    taxRateStr!: string | undefined;
    invoiceId!: number | undefined;
    itemId!: number | undefined;
    categoryId!: number | undefined;
    lineNum!: number | undefined;
    remainQty!: number | undefined;
    amountVat!: number | undefined;
    unitPrice!: number | undefined;
    poId!: number | undefined;
    erroR_DESCRIPTION!: string | undefined;
    invoiceNum!: string | undefined;
    status!: string | undefined;
    vendorId!: number | undefined;
    unitPricePO!: number | undefined;
    qtyInvoice!: number | undefined;
    remainQtyActual!: number | undefined;
    note!: string | undefined;
    isSkipInvCheck!: boolean | undefined;

    constructor(data?: ISearchInvoiceOutputDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.poNumber = _data["poNumber"];
            this.poHeaderId = _data["poHeaderId"];
            this.itemNumber = _data["itemNumber"];
            this.itemDescription = _data["itemDescription"];
            this.quantity = _data["quantity"];
            this.quantityStr = _data["quantityStr"];
            this.quantityOrder = _data["quantityOrder"];
            this.quantityOrderStr = _data["quantityOrderStr"];
            this.foreignPrice = _data["foreignPrice"];
            this.foreignPriceStr = _data["foreignPriceStr"];
            this.quantityReceived = _data["quantityReceived"];
            this.quantityReceivedStr = _data["quantityReceivedStr"];
            this.quantityMatched = _data["quantityMatched"];
            this.quantityMatchedStr = _data["quantityMatchedStr"];
            this.quantityGR = _data["quantityGR"];
            this.quantityPayment = _data["quantityPayment"];
            this.qtyRemainGR = _data["qtyRemainGR"];
            this.toVnd = _data["toVnd"];
            this.vndPrice = _data["vndPrice"];
            this.amount = _data["amount"];
            this.totalAmount = _data["totalAmount"];
            this.taxRate = _data["taxRate"];
            this.taxRateStr = _data["taxRateStr"];
            this.invoiceId = _data["invoiceId"];
            this.itemId = _data["itemId"];
            this.categoryId = _data["categoryId"];
            this.lineNum = _data["lineNum"];
            this.remainQty = _data["remainQty"];
            this.amountVat = _data["amountVat"];
            this.unitPrice = _data["unitPrice"];
            this.poId = _data["poId"];
            this.erroR_DESCRIPTION = _data["erroR_DESCRIPTION"];
            this.invoiceNum = _data["invoiceNum"];
            this.status = _data["status"];
            this.vendorId = _data["vendorId"];
            this.unitPricePO = _data["unitPricePO"];
            this.qtyInvoice = _data["qtyInvoice"];
            this.remainQtyActual = _data["remainQtyActual"];
            this.note = _data["note"];
            this.isSkipInvCheck = _data["isSkipInvCheck"];
        }
    }

    static fromJS(data: any): SearchInvoiceOutputDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchInvoiceOutputDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["poNumber"] = this.poNumber;
        data["poHeaderId"] = this.poHeaderId;
        data["itemNumber"] = this.itemNumber;
        data["itemDescription"] = this.itemDescription;
        data["quantity"] = this.quantity;
        data["quantityStr"] = this.quantityStr;
        data["quantityOrder"] = this.quantityOrder;
        data["quantityOrderStr"] = this.quantityOrderStr;
        data["foreignPrice"] = this.foreignPrice;
        data["foreignPriceStr"] = this.foreignPriceStr;
        data["quantityReceived"] = this.quantityReceived;
        data["quantityReceivedStr"] = this.quantityReceivedStr;
        data["quantityMatched"] = this.quantityMatched;
        data["quantityMatchedStr"] = this.quantityMatchedStr;
        data["quantityGR"] = this.quantityGR;
        data["quantityPayment"] = this.quantityPayment;
        data["qtyRemainGR"] = this.qtyRemainGR;
        data["toVnd"] = this.toVnd;
        data["vndPrice"] = this.vndPrice;
        data["amount"] = this.amount;
        data["totalAmount"] = this.totalAmount;
        data["taxRate"] = this.taxRate;
        data["taxRateStr"] = this.taxRateStr;
        data["invoiceId"] = this.invoiceId;
        data["itemId"] = this.itemId;
        data["categoryId"] = this.categoryId;
        data["lineNum"] = this.lineNum;
        data["remainQty"] = this.remainQty;
        data["amountVat"] = this.amountVat;
        data["unitPrice"] = this.unitPrice;
        data["poId"] = this.poId;
        data["erroR_DESCRIPTION"] = this.erroR_DESCRIPTION;
        data["invoiceNum"] = this.invoiceNum;
        data["status"] = this.status;
        data["vendorId"] = this.vendorId;
        data["unitPricePO"] = this.unitPricePO;
        data["qtyInvoice"] = this.qtyInvoice;
        data["remainQtyActual"] = this.remainQtyActual;
        data["note"] = this.note;
        data["isSkipInvCheck"] = this.isSkipInvCheck;
        return data;
    }
}

export interface ISearchInvoiceOutputDetailDto {
    id: number | undefined;
    poNumber: string | undefined;
    poHeaderId: number | undefined;
    itemNumber: string | undefined;
    itemDescription: string | undefined;
    quantity: number | undefined;
    quantityStr: string | undefined;
    quantityOrder: number | undefined;
    quantityOrderStr: string | undefined;
    foreignPrice: number | undefined;
    foreignPriceStr: string | undefined;
    quantityReceived: number | undefined;
    quantityReceivedStr: string | undefined;
    quantityMatched: number | undefined;
    quantityMatchedStr: string | undefined;
    quantityGR: number | undefined;
    quantityPayment: number | undefined;
    qtyRemainGR: number | undefined;
    toVnd: number | undefined;
    vndPrice: number | undefined;
    amount: number | undefined;
    totalAmount: number | undefined;
    taxRate: number | undefined;
    taxRateStr: string | undefined;
    invoiceId: number | undefined;
    itemId: number | undefined;
    categoryId: number | undefined;
    lineNum: number | undefined;
    remainQty: number | undefined;
    amountVat: number | undefined;
    unitPrice: number | undefined;
    poId: number | undefined;
    erroR_DESCRIPTION: string | undefined;
    invoiceNum: string | undefined;
    status: string | undefined;
    vendorId: number | undefined;
    unitPricePO: number | undefined;
    qtyInvoice: number | undefined;
    remainQtyActual: number | undefined;
    note: string | undefined;
    isSkipInvCheck: boolean | undefined;
}

export class SearchInvoiceOutputDto implements ISearchInvoiceOutputDto {
    totalCount!: number | undefined;
    id!: number | undefined;
    invoiceNum!: string | undefined;
    invoiceSymbol!: string | undefined;
    vendorNumber!: string | undefined;
    vendorName!: string | undefined;
    vendorSiteId!: number | undefined;
    invoiceDate!: DateTime | undefined;
    invoiceDateStr!: string | undefined;
    taxName!: string | undefined;
    taxRate!: number | undefined;
    taxRateStr!: string | undefined;
    currencyCode!: string | undefined;
    rate!: number | undefined;
    rateStr!: string | undefined;
    matchingStatusText!: string | undefined;
    confirmStatusText!: string | undefined;
    totalAmount!: number | undefined;
    totalAmountStr!: string | undefined;
    totalTaxAmount!: number | undefined;
    vendorId!: number | undefined;
    currencyId!: number | undefined;
    description!: string | undefined;
    vatRegistrationNum!: string | undefined;
    vatRegistrationInvoice!: string | undefined;
    invoiceDetailList!: SearchInvoiceOutputDetailDto[] | undefined;
    totalPaymentAmount!: number | undefined;
    isPaid!: boolean;
    erroR_DESCRIPTION!: string | undefined;
    invoiceAmountPO!: number | undefined;
    status!: string | undefined;
    source!: string | undefined;
    lookupCode!: string | undefined;
    lookupLink!: string | undefined;
    poNumber!: string | undefined;
    checkMatched!: boolean;
    picInvoice!: string | undefined;
    vatAmount!: number | undefined;

    constructor(data?: ISearchInvoiceOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.id = _data["id"];
            this.invoiceNum = _data["invoiceNum"];
            this.invoiceSymbol = _data["invoiceSymbol"];
            this.vendorNumber = _data["vendorNumber"];
            this.vendorName = _data["vendorName"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.invoiceDate = _data["invoiceDate"] ? DateTime.fromISO(_data["invoiceDate"].toString()) : <any>undefined;
            this.invoiceDateStr = _data["invoiceDateStr"];
            this.taxName = _data["taxName"];
            this.taxRate = _data["taxRate"];
            this.taxRateStr = _data["taxRateStr"];
            this.currencyCode = _data["currencyCode"];
            this.rate = _data["rate"];
            this.rateStr = _data["rateStr"];
            this.matchingStatusText = _data["matchingStatusText"];
            this.confirmStatusText = _data["confirmStatusText"];
            this.totalAmount = _data["totalAmount"];
            this.totalAmountStr = _data["totalAmountStr"];
            this.totalTaxAmount = _data["totalTaxAmount"];
            this.vendorId = _data["vendorId"];
            this.currencyId = _data["currencyId"];
            this.description = _data["description"];
            this.vatRegistrationNum = _data["vatRegistrationNum"];
            this.vatRegistrationInvoice = _data["vatRegistrationInvoice"];
            if (Array.isArray(_data["invoiceDetailList"])) {
                this.invoiceDetailList = [] as any;
                for (let item of _data["invoiceDetailList"])
                    this.invoiceDetailList!.push(SearchInvoiceOutputDetailDto.fromJS(item));
            }
            this.totalPaymentAmount = _data["totalPaymentAmount"];
            this.isPaid = _data["isPaid"];
            this.erroR_DESCRIPTION = _data["erroR_DESCRIPTION"];
            this.invoiceAmountPO = _data["invoiceAmountPO"];
            this.status = _data["status"];
            this.source = _data["source"];
            this.lookupCode = _data["lookupCode"];
            this.lookupLink = _data["lookupLink"];
            this.poNumber = _data["poNumber"];
            this.checkMatched = _data["checkMatched"];
            this.picInvoice = _data["picInvoice"];
            this.vatAmount = _data["vatAmount"];
        }
    }

    static fromJS(data: any): SearchInvoiceOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchInvoiceOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["id"] = this.id;
        data["invoiceNum"] = this.invoiceNum;
        data["invoiceSymbol"] = this.invoiceSymbol;
        data["vendorNumber"] = this.vendorNumber;
        data["vendorName"] = this.vendorName;
        data["vendorSiteId"] = this.vendorSiteId;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toString() : <any>undefined;
        data["invoiceDateStr"] = this.invoiceDateStr;
        data["taxName"] = this.taxName;
        data["taxRate"] = this.taxRate;
        data["taxRateStr"] = this.taxRateStr;
        data["currencyCode"] = this.currencyCode;
        data["rate"] = this.rate;
        data["rateStr"] = this.rateStr;
        data["matchingStatusText"] = this.matchingStatusText;
        data["confirmStatusText"] = this.confirmStatusText;
        data["totalAmount"] = this.totalAmount;
        data["totalAmountStr"] = this.totalAmountStr;
        data["totalTaxAmount"] = this.totalTaxAmount;
        data["vendorId"] = this.vendorId;
        data["currencyId"] = this.currencyId;
        data["description"] = this.description;
        data["vatRegistrationNum"] = this.vatRegistrationNum;
        data["vatRegistrationInvoice"] = this.vatRegistrationInvoice;
        if (Array.isArray(this.invoiceDetailList)) {
            data["invoiceDetailList"] = [];
            for (let item of this.invoiceDetailList)
                data["invoiceDetailList"].push(item.toJSON());
        }
        data["totalPaymentAmount"] = this.totalPaymentAmount;
        data["isPaid"] = this.isPaid;
        data["erroR_DESCRIPTION"] = this.erroR_DESCRIPTION;
        data["invoiceAmountPO"] = this.invoiceAmountPO;
        data["status"] = this.status;
        data["source"] = this.source;
        data["lookupCode"] = this.lookupCode;
        data["lookupLink"] = this.lookupLink;
        data["poNumber"] = this.poNumber;
        data["checkMatched"] = this.checkMatched;
        data["picInvoice"] = this.picInvoice;
        data["vatAmount"] = this.vatAmount;
        return data;
    }
}

export interface ISearchInvoiceOutputDto {
    totalCount: number | undefined;
    id: number | undefined;
    invoiceNum: string | undefined;
    invoiceSymbol: string | undefined;
    vendorNumber: string | undefined;
    vendorName: string | undefined;
    vendorSiteId: number | undefined;
    invoiceDate: DateTime | undefined;
    invoiceDateStr: string | undefined;
    taxName: string | undefined;
    taxRate: number | undefined;
    taxRateStr: string | undefined;
    currencyCode: string | undefined;
    rate: number | undefined;
    rateStr: string | undefined;
    matchingStatusText: string | undefined;
    confirmStatusText: string | undefined;
    totalAmount: number | undefined;
    totalAmountStr: string | undefined;
    totalTaxAmount: number | undefined;
    vendorId: number | undefined;
    currencyId: number | undefined;
    description: string | undefined;
    vatRegistrationNum: string | undefined;
    vatRegistrationInvoice: string | undefined;
    invoiceDetailList: SearchInvoiceOutputDetailDto[] | undefined;
    totalPaymentAmount: number | undefined;
    isPaid: boolean;
    erroR_DESCRIPTION: string | undefined;
    invoiceAmountPO: number | undefined;
    status: string | undefined;
    source: string | undefined;
    lookupCode: string | undefined;
    lookupLink: string | undefined;
    poNumber: string | undefined;
    checkMatched: boolean;
    picInvoice: string | undefined;
    vatAmount: number | undefined;
}

export class PagedResultDtoOfSearchInvoiceOutputDto implements IPagedResultDtoOfSearchInvoiceOutputDto {
    totalCount!: number;
    items!: SearchInvoiceOutputDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSearchInvoiceOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SearchInvoiceOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSearchInvoiceOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSearchInvoiceOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfSearchInvoiceOutputDto {
    totalCount: number;
    items: SearchInvoiceOutputDto[] | undefined;
}

export class GetPoVendorDto implements IGetPoVendorDto {
    id!: number;
    poNumber!: string | undefined;
    creationTime!: DateTime;
    comments!: string | undefined;
    supplierName!: string | undefined;
    currencyCode!: string | undefined;
    unitPrice!: number | undefined;
    quantityOrder!: number | undefined;
    quantity!: number | undefined;
    quantityReceived!: number | undefined;
    qtyInvoice!: number | undefined;
    categoryId!: number | undefined;
    itemDescription!: string | undefined;
    itemNumber!: string | undefined;
    partNameSupplier!: string | undefined;
    lineNum!: number;
    itemId!: number | undefined;
    vendorId!: number | undefined;
    poHeaderId!: number;
    poId!: number;
    partNo!: string | undefined;
    errDescription!: string | undefined;
    qtyRemain!: number | undefined;
    invoicePrice!: number | undefined;
    partName!: string | undefined;
    isSkipInvCheck!: boolean | undefined;

    constructor(data?: IGetPoVendorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.poNumber = _data["poNumber"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.comments = _data["comments"];
            this.supplierName = _data["supplierName"];
            this.currencyCode = _data["currencyCode"];
            this.unitPrice = _data["unitPrice"];
            this.quantityOrder = _data["quantityOrder"];
            this.quantity = _data["quantity"];
            this.quantityReceived = _data["quantityReceived"];
            this.qtyInvoice = _data["qtyInvoice"];
            this.categoryId = _data["categoryId"];
            this.itemDescription = _data["itemDescription"];
            this.itemNumber = _data["itemNumber"];
            this.partNameSupplier = _data["partNameSupplier"];
            this.lineNum = _data["lineNum"];
            this.itemId = _data["itemId"];
            this.vendorId = _data["vendorId"];
            this.poHeaderId = _data["poHeaderId"];
            this.poId = _data["poId"];
            this.partNo = _data["partNo"];
            this.errDescription = _data["errDescription"];
            this.qtyRemain = _data["qtyRemain"];
            this.invoicePrice = _data["invoicePrice"];
            this.partName = _data["partName"];
            this.isSkipInvCheck = _data["isSkipInvCheck"];
        }
    }

    static fromJS(data: any): GetPoVendorDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPoVendorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["poNumber"] = this.poNumber;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["comments"] = this.comments;
        data["supplierName"] = this.supplierName;
        data["currencyCode"] = this.currencyCode;
        data["unitPrice"] = this.unitPrice;
        data["quantityOrder"] = this.quantityOrder;
        data["quantity"] = this.quantity;
        data["quantityReceived"] = this.quantityReceived;
        data["qtyInvoice"] = this.qtyInvoice;
        data["categoryId"] = this.categoryId;
        data["itemDescription"] = this.itemDescription;
        data["itemNumber"] = this.itemNumber;
        data["partNameSupplier"] = this.partNameSupplier;
        data["lineNum"] = this.lineNum;
        data["itemId"] = this.itemId;
        data["vendorId"] = this.vendorId;
        data["poHeaderId"] = this.poHeaderId;
        data["poId"] = this.poId;
        data["partNo"] = this.partNo;
        data["errDescription"] = this.errDescription;
        data["qtyRemain"] = this.qtyRemain;
        data["invoicePrice"] = this.invoicePrice;
        data["partName"] = this.partName;
        data["isSkipInvCheck"] = this.isSkipInvCheck;
        return data;
    }
}

export interface IGetPoVendorDto {
    id: number;
    poNumber: string | undefined;
    creationTime: DateTime;
    comments: string | undefined;
    supplierName: string | undefined;
    currencyCode: string | undefined;
    unitPrice: number | undefined;
    quantityOrder: number | undefined;
    quantity: number | undefined;
    quantityReceived: number | undefined;
    qtyInvoice: number | undefined;
    categoryId: number | undefined;
    itemDescription: string | undefined;
    itemNumber: string | undefined;
    partNameSupplier: string | undefined;
    lineNum: number;
    itemId: number | undefined;
    vendorId: number | undefined;
    poHeaderId: number;
    poId: number;
    partNo: string | undefined;
    errDescription: string | undefined;
    qtyRemain: number | undefined;
    invoicePrice: number | undefined;
    partName: string | undefined;
    isSkipInvCheck: boolean | undefined;
}

export class VendorComboboxDto implements IVendorComboboxDto {
    id!: number | undefined;
    supplierName!: string | undefined;
    supplierNumber!: string | undefined;

    constructor(data?: IVendorComboboxDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.supplierName = _data["supplierName"];
            this.supplierNumber = _data["supplierNumber"];
        }
    }

    static fromJS(data: any): VendorComboboxDto {
        data = typeof data === 'object' ? data : {};
        let result = new VendorComboboxDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["supplierName"] = this.supplierName;
        data["supplierNumber"] = this.supplierNumber;
        return data;
    }
}

export interface IVendorComboboxDto {
    id: number | undefined;
    supplierName: string | undefined;
    supplierNumber: string | undefined;
}

export class MasterLookupDto implements IMasterLookupDto {
    id!: number;
    stringId!: string;
    code!: string | undefined;
    contractAppendixNo!: string | undefined;
    name!: string | undefined;

    constructor(data?: IMasterLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.stringId = _data["stringId"];
            this.code = _data["code"];
            this.contractAppendixNo = _data["contractAppendixNo"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): MasterLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new MasterLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["stringId"] = this.stringId;
        data["code"] = this.code;
        data["contractAppendixNo"] = this.contractAppendixNo;
        data["name"] = this.name;
        return data;
    }
}

export interface IMasterLookupDto {
    id: number;
    stringId: string;
    code: string | undefined;
    contractAppendixNo: string | undefined;
    name: string | undefined;
}

export class CurrencyComboboxDto implements ICurrencyComboboxDto {
    id!: number | undefined;
    currencyCode!: string | undefined;
    code!: string | undefined;
    name!: string | undefined;

    constructor(data?: ICurrencyComboboxDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.currencyCode = _data["currencyCode"];
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CurrencyComboboxDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyComboboxDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["currencyCode"] = this.currencyCode;
        data["code"] = this.code;
        data["name"] = this.name;
        return data;
    }
}

export interface ICurrencyComboboxDto {
    id: number | undefined;
    currencyCode: string | undefined;
    code: string | undefined;
    name: string | undefined;
}

export class InvImportMultipleDto implements IInvImportMultipleDto {
    listHeader!: SearchInvoiceOutputDto[] | undefined;
    listItems!: SearchInvoiceOutputDetailDto[] | undefined;

    constructor(data?: IInvImportMultipleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listHeader"])) {
                this.listHeader = [] as any;
                for (let item of _data["listHeader"])
                    this.listHeader!.push(SearchInvoiceOutputDto.fromJS(item));
            }
            if (Array.isArray(_data["listItems"])) {
                this.listItems = [] as any;
                for (let item of _data["listItems"])
                    this.listItems!.push(SearchInvoiceOutputDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvImportMultipleDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvImportMultipleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listHeader)) {
            data["listHeader"] = [];
            for (let item of this.listHeader)
                data["listHeader"].push(item.toJSON());
        }
        if (Array.isArray(this.listItems)) {
            data["listItems"] = [];
            for (let item of this.listItems)
                data["listItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInvImportMultipleDto {
    listHeader: SearchInvoiceOutputDto[] | undefined;
    listItems: SearchInvoiceOutputDetailDto[] | undefined;
}

export class GetAllPoNumberByVendorDto implements IGetAllPoNumberByVendorDto {
    poNumber!: string | undefined;
    vendorName!: string | undefined;
    description!: string | undefined;
    creationTime!: DateTime;
    id!: number;

    constructor(data?: IGetAllPoNumberByVendorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.poNumber = _data["poNumber"];
            this.vendorName = _data["vendorName"];
            this.description = _data["description"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAllPoNumberByVendorDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllPoNumberByVendorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["poNumber"] = this.poNumber;
        data["vendorName"] = this.vendorName;
        data["description"] = this.description;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IGetAllPoNumberByVendorDto {
    poNumber: string | undefined;
    vendorName: string | undefined;
    description: string | undefined;
    creationTime: DateTime;
    id: number;
}

export class GetAllPoLinesForUpdateInvoiceDto implements IGetAllPoLinesForUpdateInvoiceDto {
    poNumber!: string | undefined;
    partName!: string | undefined;
    partNameSupplier!: string | undefined;
    partNo!: string | undefined;
    unitPrice!: number;
    poQuantity!: number;
    quantityGR!: number;
    isSkipInvCheck!: boolean | undefined;
    itemId!: number | undefined;
    id!: number;

    constructor(data?: IGetAllPoLinesForUpdateInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.poNumber = _data["poNumber"];
            this.partName = _data["partName"];
            this.partNameSupplier = _data["partNameSupplier"];
            this.partNo = _data["partNo"];
            this.unitPrice = _data["unitPrice"];
            this.poQuantity = _data["poQuantity"];
            this.quantityGR = _data["quantityGR"];
            this.isSkipInvCheck = _data["isSkipInvCheck"];
            this.itemId = _data["itemId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAllPoLinesForUpdateInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllPoLinesForUpdateInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["poNumber"] = this.poNumber;
        data["partName"] = this.partName;
        data["partNameSupplier"] = this.partNameSupplier;
        data["partNo"] = this.partNo;
        data["unitPrice"] = this.unitPrice;
        data["poQuantity"] = this.poQuantity;
        data["quantityGR"] = this.quantityGR;
        data["isSkipInvCheck"] = this.isSkipInvCheck;
        data["itemId"] = this.itemId;
        data["id"] = this.id;
        return data;
    }
}

export interface IGetAllPoLinesForUpdateInvoiceDto {
    poNumber: string | undefined;
    partName: string | undefined;
    partNameSupplier: string | undefined;
    partNo: string | undefined;
    unitPrice: number;
    poQuantity: number;
    quantityGR: number;
    isSkipInvCheck: boolean | undefined;
    itemId: number | undefined;
    id: number;
}

export class CancelInvoiceInputDto implements ICancelInvoiceInputDto {
    cancelReason!: string | undefined;
    id!: number;

    constructor(data?: ICancelInvoiceInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cancelReason = _data["cancelReason"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CancelInvoiceInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CancelInvoiceInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cancelReason"] = this.cancelReason;
        data["id"] = this.id;
        return data;
    }
}

export interface ICancelInvoiceInputDto {
    cancelReason: string | undefined;
    id: number;
}

export class GetAllCancelReasonForInvoice implements IGetAllCancelReasonForInvoice {
    code!: string | undefined;
    type!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    id!: number;

    constructor(data?: IGetAllCancelReasonForInvoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.type = _data["type"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAllCancelReasonForInvoice {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllCancelReasonForInvoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["type"] = this.type;
        data["name"] = this.name;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }
}

export interface IGetAllCancelReasonForInvoice {
    code: string | undefined;
    type: string | undefined;
    name: string | undefined;
    description: string | undefined;
    id: number;
}

export class GetSupplierInfoForInvoiceDto implements IGetSupplierInfoForInvoiceDto {
    supplierName!: string | undefined;
    supplierNumber!: string | undefined;
    vatRegistrationNum!: string | undefined;
    vatRegistrationInvoice!: string | undefined;
    id!: number;

    constructor(data?: IGetSupplierInfoForInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supplierName = _data["supplierName"];
            this.supplierNumber = _data["supplierNumber"];
            this.vatRegistrationNum = _data["vatRegistrationNum"];
            this.vatRegistrationInvoice = _data["vatRegistrationInvoice"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetSupplierInfoForInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSupplierInfoForInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supplierName"] = this.supplierName;
        data["supplierNumber"] = this.supplierNumber;
        data["vatRegistrationNum"] = this.vatRegistrationNum;
        data["vatRegistrationInvoice"] = this.vatRegistrationInvoice;
        data["id"] = this.id;
        return data;
    }
}

export interface IGetSupplierInfoForInvoiceDto {
    supplierName: string | undefined;
    supplierNumber: string | undefined;
    vatRegistrationNum: string | undefined;
    vatRegistrationInvoice: string | undefined;
    id: number;
}

export class GetAllUserForComboboxDto implements IGetAllUserForComboboxDto {
    userNameAndEmail!: string | undefined;
    id!: number;

    constructor(data?: IGetAllUserForComboboxDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameAndEmail = _data["userNameAndEmail"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAllUserForComboboxDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllUserForComboboxDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameAndEmail"] = this.userNameAndEmail;
        data["id"] = this.id;
        return data;
    }
}

export interface IGetAllUserForComboboxDto {
    userNameAndEmail: string | undefined;
    id: number;
}

export class InputInvoiceAdjustedLinesDto implements IInputInvoiceAdjustedLinesDto {
    id!: number;
    invAdjustedHeadersId!: number | undefined;
    originalInvoiceLineId!: number | undefined;
    typeAdjusted!: string | undefined;
    contentAdjusted!: string | undefined;
    invLineAdjusted!: number | undefined;
    quantity!: number | undefined;
    unitMeasLookupCode!: string | undefined;
    unitPrice!: number | undefined;
    totalPrice!: number | undefined;
    tax!: number;
    vat!: number | undefined;
    totalPriceAdjusted!: number | undefined;

    constructor(data?: IInputInvoiceAdjustedLinesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.invAdjustedHeadersId = _data["invAdjustedHeadersId"];
            this.originalInvoiceLineId = _data["originalInvoiceLineId"];
            this.typeAdjusted = _data["typeAdjusted"];
            this.contentAdjusted = _data["contentAdjusted"];
            this.invLineAdjusted = _data["invLineAdjusted"];
            this.quantity = _data["quantity"];
            this.unitMeasLookupCode = _data["unitMeasLookupCode"];
            this.unitPrice = _data["unitPrice"];
            this.totalPrice = _data["totalPrice"];
            this.tax = _data["tax"];
            this.vat = _data["vat"];
            this.totalPriceAdjusted = _data["totalPriceAdjusted"];
        }
    }

    static fromJS(data: any): InputInvoiceAdjustedLinesDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputInvoiceAdjustedLinesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invAdjustedHeadersId"] = this.invAdjustedHeadersId;
        data["originalInvoiceLineId"] = this.originalInvoiceLineId;
        data["typeAdjusted"] = this.typeAdjusted;
        data["contentAdjusted"] = this.contentAdjusted;
        data["invLineAdjusted"] = this.invLineAdjusted;
        data["quantity"] = this.quantity;
        data["unitMeasLookupCode"] = this.unitMeasLookupCode;
        data["unitPrice"] = this.unitPrice;
        data["totalPrice"] = this.totalPrice;
        data["tax"] = this.tax;
        data["vat"] = this.vat;
        data["totalPriceAdjusted"] = this.totalPriceAdjusted;
        return data;
    }
}

export interface IInputInvoiceAdjustedLinesDto {
    id: number;
    invAdjustedHeadersId: number | undefined;
    originalInvoiceLineId: number | undefined;
    typeAdjusted: string | undefined;
    contentAdjusted: string | undefined;
    invLineAdjusted: number | undefined;
    quantity: number | undefined;
    unitMeasLookupCode: string | undefined;
    unitPrice: number | undefined;
    totalPrice: number | undefined;
    tax: number;
    vat: number | undefined;
    totalPriceAdjusted: number | undefined;
}

export class InputInvoiceAdjustedHeadersDto implements IInputInvoiceAdjustedHeadersDto {
    id!: number;
    invoiceNo!: string | undefined;
    serialNo!: string | undefined;
    invoiceDate!: DateTime | undefined;
    supplierId!: number | undefined;
    invoiceNoAdjusted!: string | undefined;
    serialNoAdjusted!: string | undefined;
    invoiceDateAdjusted!: DateTime | undefined;
    typeAdjusted!: string | undefined;
    description!: string | undefined;
    inputInvoiceAdjustedLinesDtos!: InputInvoiceAdjustedLinesDto[] | undefined;

    constructor(data?: IInputInvoiceAdjustedHeadersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.invoiceNo = _data["invoiceNo"];
            this.serialNo = _data["serialNo"];
            this.invoiceDate = _data["invoiceDate"] ? DateTime.fromISO(_data["invoiceDate"].toString()) : <any>undefined;
            this.supplierId = _data["supplierId"];
            this.invoiceNoAdjusted = _data["invoiceNoAdjusted"];
            this.serialNoAdjusted = _data["serialNoAdjusted"];
            this.invoiceDateAdjusted = _data["invoiceDateAdjusted"] ? DateTime.fromISO(_data["invoiceDateAdjusted"].toString()) : <any>undefined;
            this.typeAdjusted = _data["typeAdjusted"];
            this.description = _data["description"];
            if (Array.isArray(_data["inputInvoiceAdjustedLinesDtos"])) {
                this.inputInvoiceAdjustedLinesDtos = [] as any;
                for (let item of _data["inputInvoiceAdjustedLinesDtos"])
                    this.inputInvoiceAdjustedLinesDtos!.push(InputInvoiceAdjustedLinesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InputInvoiceAdjustedHeadersDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputInvoiceAdjustedHeadersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invoiceNo"] = this.invoiceNo;
        data["serialNo"] = this.serialNo;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toString() : <any>undefined;
        data["supplierId"] = this.supplierId;
        data["invoiceNoAdjusted"] = this.invoiceNoAdjusted;
        data["serialNoAdjusted"] = this.serialNoAdjusted;
        data["invoiceDateAdjusted"] = this.invoiceDateAdjusted ? this.invoiceDateAdjusted.toString() : <any>undefined;
        data["typeAdjusted"] = this.typeAdjusted;
        data["description"] = this.description;
        if (Array.isArray(this.inputInvoiceAdjustedLinesDtos)) {
            data["inputInvoiceAdjustedLinesDtos"] = [];
            for (let item of this.inputInvoiceAdjustedLinesDtos)
                data["inputInvoiceAdjustedLinesDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInputInvoiceAdjustedHeadersDto {
    id: number;
    invoiceNo: string | undefined;
    serialNo: string | undefined;
    invoiceDate: DateTime | undefined;
    supplierId: number | undefined;
    invoiceNoAdjusted: string | undefined;
    serialNoAdjusted: string | undefined;
    invoiceDateAdjusted: DateTime | undefined;
    typeAdjusted: string | undefined;
    description: string | undefined;
    inputInvoiceAdjustedLinesDtos: InputInvoiceAdjustedLinesDto[] | undefined;
}

export class GetAllInvoiceAdjustedDto implements IGetAllInvoiceAdjustedDto {
    id!: number;
    invoiceNo!: string | undefined;
    typeAdjusted!: string | undefined;
    serialNo!: string | undefined;
    supplierName!: string | undefined;
    vatAdjusted!: string | undefined;
    invoiceDate!: DateTime | undefined;
    invoiceNoAdjusted!: string | undefined;
    serialNoAdjusted!: string | undefined;
    totalCount!: number;

    constructor(data?: IGetAllInvoiceAdjustedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.invoiceNo = _data["invoiceNo"];
            this.typeAdjusted = _data["typeAdjusted"];
            this.serialNo = _data["serialNo"];
            this.supplierName = _data["supplierName"];
            this.vatAdjusted = _data["vatAdjusted"];
            this.invoiceDate = _data["invoiceDate"] ? DateTime.fromISO(_data["invoiceDate"].toString()) : <any>undefined;
            this.invoiceNoAdjusted = _data["invoiceNoAdjusted"];
            this.serialNoAdjusted = _data["serialNoAdjusted"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetAllInvoiceAdjustedDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllInvoiceAdjustedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invoiceNo"] = this.invoiceNo;
        data["typeAdjusted"] = this.typeAdjusted;
        data["serialNo"] = this.serialNo;
        data["supplierName"] = this.supplierName;
        data["vatAdjusted"] = this.vatAdjusted;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toString() : <any>undefined;
        data["invoiceNoAdjusted"] = this.invoiceNoAdjusted;
        data["serialNoAdjusted"] = this.serialNoAdjusted;
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IGetAllInvoiceAdjustedDto {
    id: number;
    invoiceNo: string | undefined;
    typeAdjusted: string | undefined;
    serialNo: string | undefined;
    supplierName: string | undefined;
    vatAdjusted: string | undefined;
    invoiceDate: DateTime | undefined;
    invoiceNoAdjusted: string | undefined;
    serialNoAdjusted: string | undefined;
    totalCount: number;
}

export class PagedResultDtoOfGetAllInvoiceAdjustedDto implements IPagedResultDtoOfGetAllInvoiceAdjustedDto {
    totalCount!: number;
    items!: GetAllInvoiceAdjustedDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAllInvoiceAdjustedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllInvoiceAdjustedDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAllInvoiceAdjustedDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAllInvoiceAdjustedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAllInvoiceAdjustedDto {
    totalCount: number;
    items: GetAllInvoiceAdjustedDto[] | undefined;
}

export class GetListInvoiceHeadersDto implements IGetListInvoiceHeadersDto {
    id!: number;
    invoiceNo!: string | undefined;
    serialNo!: string | undefined;
    invoiceDate!: DateTime | undefined;

    constructor(data?: IGetListInvoiceHeadersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.invoiceNo = _data["invoiceNo"];
            this.serialNo = _data["serialNo"];
            this.invoiceDate = _data["invoiceDate"] ? DateTime.fromISO(_data["invoiceDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetListInvoiceHeadersDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetListInvoiceHeadersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invoiceNo"] = this.invoiceNo;
        data["serialNo"] = this.serialNo;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toString() : <any>undefined;
        return data;
    }
}

export interface IGetListInvoiceHeadersDto {
    id: number;
    invoiceNo: string | undefined;
    serialNo: string | undefined;
    invoiceDate: DateTime | undefined;
}

export class GetListInvoiceLinesDto implements IGetListInvoiceLinesDto {
    id!: number;
    invoiceId!: number;
    lineNum!: number | undefined;
    poNumber!: string | undefined;
    vendorName!: string | undefined;
    vendorId!: number | undefined;
    itemId!: number | undefined;
    itemDescription!: string | undefined;
    quantity!: number | undefined;
    unitPrice!: number | undefined;
    amount!: number | undefined;
    taxRate!: number | undefined;
    vat!: number | undefined;

    constructor(data?: IGetListInvoiceLinesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.invoiceId = _data["invoiceId"];
            this.lineNum = _data["lineNum"];
            this.poNumber = _data["poNumber"];
            this.vendorName = _data["vendorName"];
            this.vendorId = _data["vendorId"];
            this.itemId = _data["itemId"];
            this.itemDescription = _data["itemDescription"];
            this.quantity = _data["quantity"];
            this.unitPrice = _data["unitPrice"];
            this.amount = _data["amount"];
            this.taxRate = _data["taxRate"];
            this.vat = _data["vat"];
        }
    }

    static fromJS(data: any): GetListInvoiceLinesDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetListInvoiceLinesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invoiceId"] = this.invoiceId;
        data["lineNum"] = this.lineNum;
        data["poNumber"] = this.poNumber;
        data["vendorName"] = this.vendorName;
        data["vendorId"] = this.vendorId;
        data["itemId"] = this.itemId;
        data["itemDescription"] = this.itemDescription;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["amount"] = this.amount;
        data["taxRate"] = this.taxRate;
        data["vat"] = this.vat;
        return data;
    }
}

export interface IGetListInvoiceLinesDto {
    id: number;
    invoiceId: number;
    lineNum: number | undefined;
    poNumber: string | undefined;
    vendorName: string | undefined;
    vendorId: number | undefined;
    itemId: number | undefined;
    itemDescription: string | undefined;
    quantity: number | undefined;
    unitPrice: number | undefined;
    amount: number | undefined;
    taxRate: number | undefined;
    vat: number | undefined;
}

export class InvoiceHeadersDto implements IInvoiceHeadersDto {
    id!: number;
    invoiceNum!: string | undefined;
    description!: string | undefined;
    invoiceDate!: DateTime | undefined;
    vendorId!: number | undefined;
    vendorName!: string | undefined;
    vendorNumber!: string | undefined;
    vendorSiteId!: number | undefined;
    currencyCode!: string | undefined;
    rate!: number | undefined;
    rateDate!: DateTime | undefined;
    invoiceAmount!: number | undefined;
    amountVat!: number | undefined;
    taxId!: number | undefined;
    taxName!: string | undefined;
    taxRate!: number | undefined;
    differency!: number | undefined;
    amountDeducted!: number | undefined;
    isPaid!: boolean;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IInvoiceHeadersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.invoiceNum = _data["invoiceNum"];
            this.description = _data["description"];
            this.invoiceDate = _data["invoiceDate"] ? DateTime.fromISO(_data["invoiceDate"].toString()) : <any>undefined;
            this.vendorId = _data["vendorId"];
            this.vendorName = _data["vendorName"];
            this.vendorNumber = _data["vendorNumber"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.currencyCode = _data["currencyCode"];
            this.rate = _data["rate"];
            this.rateDate = _data["rateDate"] ? DateTime.fromISO(_data["rateDate"].toString()) : <any>undefined;
            this.invoiceAmount = _data["invoiceAmount"];
            this.amountVat = _data["amountVat"];
            this.taxId = _data["taxId"];
            this.taxName = _data["taxName"];
            this.taxRate = _data["taxRate"];
            this.differency = _data["differency"];
            this.amountDeducted = _data["amountDeducted"];
            this.isPaid = _data["isPaid"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): InvoiceHeadersDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceHeadersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invoiceNum"] = this.invoiceNum;
        data["description"] = this.description;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toString() : <any>undefined;
        data["vendorId"] = this.vendorId;
        data["vendorName"] = this.vendorName;
        data["vendorNumber"] = this.vendorNumber;
        data["vendorSiteId"] = this.vendorSiteId;
        data["currencyCode"] = this.currencyCode;
        data["rate"] = this.rate;
        data["rateDate"] = this.rateDate ? this.rateDate.toString() : <any>undefined;
        data["invoiceAmount"] = this.invoiceAmount;
        data["amountVat"] = this.amountVat;
        data["taxId"] = this.taxId;
        data["taxName"] = this.taxName;
        data["taxRate"] = this.taxRate;
        data["differency"] = this.differency;
        data["amountDeducted"] = this.amountDeducted;
        data["isPaid"] = this.isPaid;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data;
    }
}

export interface IInvoiceHeadersDto {
    id: number;
    invoiceNum: string | undefined;
    description: string | undefined;
    invoiceDate: DateTime | undefined;
    vendorId: number | undefined;
    vendorName: string | undefined;
    vendorNumber: string | undefined;
    vendorSiteId: number | undefined;
    currencyCode: string | undefined;
    rate: number | undefined;
    rateDate: DateTime | undefined;
    invoiceAmount: number | undefined;
    amountVat: number | undefined;
    taxId: number | undefined;
    taxName: string | undefined;
    taxRate: number | undefined;
    differency: number | undefined;
    amountDeducted: number | undefined;
    isPaid: boolean;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class PagedResultDtoOfInvoiceHeadersDto implements IPagedResultDtoOfInvoiceHeadersDto {
    totalCount!: number;
    items!: InvoiceHeadersDto[] | undefined;

    constructor(data?: IPagedResultDtoOfInvoiceHeadersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InvoiceHeadersDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfInvoiceHeadersDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfInvoiceHeadersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfInvoiceHeadersDto {
    totalCount: number;
    items: InvoiceHeadersDto[] | undefined;
}

export class InvoiceLinesDto implements IInvoiceLinesDto {
    id!: number;
    invoiceId!: number;
    lineNum!: number | undefined;
    poHeaderId!: number | undefined;
    poNumber!: string | undefined;
    vendorId!: number | undefined;
    itemId!: number | undefined;
    itemNumber!: string | undefined;
    itemDescription!: string | undefined;
    categoryId!: number | undefined;
    quantity!: number | undefined;
    quantityOrder!: number | undefined;
    quantityOnhand!: number | undefined;
    unitPrice!: number | undefined;
    amount!: number | undefined;
    amountVat!: number | undefined;
    foreignPrice!: number | undefined;
    foreignPriceVnd!: number | undefined;
    flag!: string | undefined;
    quantityReceived!: number | undefined;
    quantityMatched!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IInvoiceLinesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.invoiceId = _data["invoiceId"];
            this.lineNum = _data["lineNum"];
            this.poHeaderId = _data["poHeaderId"];
            this.poNumber = _data["poNumber"];
            this.vendorId = _data["vendorId"];
            this.itemId = _data["itemId"];
            this.itemNumber = _data["itemNumber"];
            this.itemDescription = _data["itemDescription"];
            this.categoryId = _data["categoryId"];
            this.quantity = _data["quantity"];
            this.quantityOrder = _data["quantityOrder"];
            this.quantityOnhand = _data["quantityOnhand"];
            this.unitPrice = _data["unitPrice"];
            this.amount = _data["amount"];
            this.amountVat = _data["amountVat"];
            this.foreignPrice = _data["foreignPrice"];
            this.foreignPriceVnd = _data["foreignPriceVnd"];
            this.flag = _data["flag"];
            this.quantityReceived = _data["quantityReceived"];
            this.quantityMatched = _data["quantityMatched"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): InvoiceLinesDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceLinesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invoiceId"] = this.invoiceId;
        data["lineNum"] = this.lineNum;
        data["poHeaderId"] = this.poHeaderId;
        data["poNumber"] = this.poNumber;
        data["vendorId"] = this.vendorId;
        data["itemId"] = this.itemId;
        data["itemNumber"] = this.itemNumber;
        data["itemDescription"] = this.itemDescription;
        data["categoryId"] = this.categoryId;
        data["quantity"] = this.quantity;
        data["quantityOrder"] = this.quantityOrder;
        data["quantityOnhand"] = this.quantityOnhand;
        data["unitPrice"] = this.unitPrice;
        data["amount"] = this.amount;
        data["amountVat"] = this.amountVat;
        data["foreignPrice"] = this.foreignPrice;
        data["foreignPriceVnd"] = this.foreignPriceVnd;
        data["flag"] = this.flag;
        data["quantityReceived"] = this.quantityReceived;
        data["quantityMatched"] = this.quantityMatched;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data;
    }
}

export interface IInvoiceLinesDto {
    id: number;
    invoiceId: number;
    lineNum: number | undefined;
    poHeaderId: number | undefined;
    poNumber: string | undefined;
    vendorId: number | undefined;
    itemId: number | undefined;
    itemNumber: string | undefined;
    itemDescription: string | undefined;
    categoryId: number | undefined;
    quantity: number | undefined;
    quantityOrder: number | undefined;
    quantityOnhand: number | undefined;
    unitPrice: number | undefined;
    amount: number | undefined;
    amountVat: number | undefined;
    foreignPrice: number | undefined;
    foreignPriceVnd: number | undefined;
    flag: string | undefined;
    quantityReceived: number | undefined;
    quantityMatched: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class PagedResultDtoOfInvoiceLinesDto implements IPagedResultDtoOfInvoiceLinesDto {
    totalCount!: number;
    items!: InvoiceLinesDto[] | undefined;

    constructor(data?: IPagedResultDtoOfInvoiceLinesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InvoiceLinesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfInvoiceLinesDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfInvoiceLinesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfInvoiceLinesDto {
    totalCount: number;
    items: InvoiceLinesDto[] | undefined;
}

export class ApplicationLanguageListDto implements IApplicationLanguageListDto {
    tenantId!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    icon!: string | undefined;
    isDisabled!: boolean;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IApplicationLanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.icon = _data["icon"];
            this.isDisabled = _data["isDisabled"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApplicationLanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IApplicationLanguageListDto {
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    defaultLanguageName!: string | undefined;
    items!: ApplicationLanguageListDto[] | undefined;

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultLanguageName = _data["defaultLanguageName"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ApplicationLanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetLanguagesOutput {
    defaultLanguageName: string | undefined;
    items: ApplicationLanguageListDto[] | undefined;
}

export class ApplicationLanguageEditDto implements IApplicationLanguageEditDto {
    id!: number | undefined;
    name!: string;
    icon!: string | undefined;
    isEnabled!: boolean;

    constructor(data?: IApplicationLanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.icon = _data["icon"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): ApplicationLanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface IApplicationLanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.displayText = _data["displayText"];
            this.isSelected = _data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data;
    }
}

export interface IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language!: ApplicationLanguageEditDto;
    languageNames!: ComboboxItemDto[] | undefined;
    flags!: ComboboxItemDto[] | undefined;

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"] ? ApplicationLanguageEditDto.fromJS(_data["language"]) : <any>undefined;
            if (Array.isArray(_data["languageNames"])) {
                this.languageNames = [] as any;
                for (let item of _data["languageNames"])
                    this.languageNames!.push(ComboboxItemDto.fromJS(item));
            }
            if (Array.isArray(_data["flags"])) {
                this.flags = [] as any;
                for (let item of _data["flags"])
                    this.flags!.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (Array.isArray(this.languageNames)) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (Array.isArray(this.flags)) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language!: ApplicationLanguageEditDto;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new ApplicationLanguageEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"] ? ApplicationLanguageEditDto.fromJS(_data["language"]) : new ApplicationLanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name!: string;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ISetDefaultLanguageInput {
    name: string;
}

export class LanguageTextListDto implements ILanguageTextListDto {
    key!: string | undefined;
    baseValue!: string | undefined;
    targetValue!: string | undefined;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.baseValue = _data["baseValue"];
            this.targetValue = _data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data;
    }
}

export interface ILanguageTextListDto {
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;
}

export class PagedResultDtoOfLanguageTextListDto implements IPagedResultDtoOfLanguageTextListDto {
    totalCount!: number;
    items!: LanguageTextListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfLanguageTextListDto {
    totalCount: number;
    items: LanguageTextListDto[] | undefined;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    languageName!: string;
    sourceName!: string;
    key!: string;
    value!: string;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
            this.sourceName = _data["sourceName"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;
}

export class ProcessTypeDto implements IProcessTypeDto {
    id!: number;
    processName!: string | undefined;

    constructor(data?: IProcessTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.processName = _data["processName"];
        }
    }

    static fromJS(data: any): ProcessTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["processName"] = this.processName;
        return data;
    }
}

export interface IProcessTypeDto {
    id: number;
    processName: string | undefined;
}

export class IventoryGroupDto implements IIventoryGroupDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: IIventoryGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IventoryGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new IventoryGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IIventoryGroupDto {
    id: number;
    name: string | undefined;
}

export class UserSearchByHrOgrDto implements IUserSearchByHrOgrDto {
    id!: number;
    userName!: string | undefined;

    constructor(data?: IUserSearchByHrOgrDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): UserSearchByHrOgrDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserSearchByHrOgrDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IUserSearchByHrOgrDto {
    id: number;
    userName: string | undefined;
}

export class ApprovalTypeDto implements IApprovalTypeDto {
    id!: number;
    approvalTypeName!: string | undefined;

    constructor(data?: IApprovalTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.approvalTypeName = _data["approvalTypeName"];
        }
    }

    static fromJS(data: any): ApprovalTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["approvalTypeName"] = this.approvalTypeName;
        return data;
    }
}

export interface IApprovalTypeDto {
    id: number;
    approvalTypeName: string | undefined;
}

export class HrOrgStructureDto implements IHrOrgStructureDto {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IHrOrgStructureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): HrOrgStructureDto {
        data = typeof data === 'object' ? data : {};
        let result = new HrOrgStructureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IHrOrgStructureDto {
    id: string | undefined;
    name: string | undefined;
}

export class TitleDto implements ITitleDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: ITitleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TitleDto {
        data = typeof data === 'object' ? data : {};
        let result = new TitleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ITitleDto {
    id: number;
    name: string | undefined;
}

export class CurrencyDto implements ICurrencyDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: ICurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICurrencyDto {
    id: number;
    name: string | undefined;
}

export class ApprovalTreeOutputSelectDto implements IApprovalTreeOutputSelectDto {
    id!: number;
    processType!: string | undefined;
    currencyName!: string | undefined;
    amountFrom!: number;
    amountTo!: number;
    description!: string | undefined;
    creationTime!: DateTime | undefined;
    inventoryGroupName!: string | undefined;

    constructor(data?: IApprovalTreeOutputSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.processType = _data["processType"];
            this.currencyName = _data["currencyName"];
            this.amountFrom = _data["amountFrom"];
            this.amountTo = _data["amountTo"];
            this.description = _data["description"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.inventoryGroupName = _data["inventoryGroupName"];
        }
    }

    static fromJS(data: any): ApprovalTreeOutputSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalTreeOutputSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["processType"] = this.processType;
        data["currencyName"] = this.currencyName;
        data["amountFrom"] = this.amountFrom;
        data["amountTo"] = this.amountTo;
        data["description"] = this.description;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["inventoryGroupName"] = this.inventoryGroupName;
        return data;
    }
}

export interface IApprovalTreeOutputSelectDto {
    id: number;
    processType: string | undefined;
    currencyName: string | undefined;
    amountFrom: number;
    amountTo: number;
    description: string | undefined;
    creationTime: DateTime | undefined;
    inventoryGroupName: string | undefined;
}

export class PagedResultDtoOfApprovalTreeOutputSelectDto implements IPagedResultDtoOfApprovalTreeOutputSelectDto {
    totalCount!: number;
    items!: ApprovalTreeOutputSelectDto[] | undefined;

    constructor(data?: IPagedResultDtoOfApprovalTreeOutputSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ApprovalTreeOutputSelectDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfApprovalTreeOutputSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfApprovalTreeOutputSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfApprovalTreeOutputSelectDto {
    totalCount: number;
    items: ApprovalTreeOutputSelectDto[] | undefined;
}

export class ApprovalTreeDetailSaveDto implements IApprovalTreeDetailSaveDto {
    id!: number;
    approvalTreeId!: number;
    approvalTypeId!: number;
    hrOrgStructureId!: string | undefined;
    listUserId!: number[] | undefined;
    titleId!: number | undefined;
    approvalSeq!: number | undefined;
    dayOfProcess!: number | undefined;
    positionId!: number | undefined;

    constructor(data?: IApprovalTreeDetailSaveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.approvalTreeId = _data["approvalTreeId"];
            this.approvalTypeId = _data["approvalTypeId"];
            this.hrOrgStructureId = _data["hrOrgStructureId"];
            if (Array.isArray(_data["listUserId"])) {
                this.listUserId = [] as any;
                for (let item of _data["listUserId"])
                    this.listUserId!.push(item);
            }
            this.titleId = _data["titleId"];
            this.approvalSeq = _data["approvalSeq"];
            this.dayOfProcess = _data["dayOfProcess"];
            this.positionId = _data["positionId"];
        }
    }

    static fromJS(data: any): ApprovalTreeDetailSaveDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalTreeDetailSaveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["approvalTreeId"] = this.approvalTreeId;
        data["approvalTypeId"] = this.approvalTypeId;
        data["hrOrgStructureId"] = this.hrOrgStructureId;
        if (Array.isArray(this.listUserId)) {
            data["listUserId"] = [];
            for (let item of this.listUserId)
                data["listUserId"].push(item);
        }
        data["titleId"] = this.titleId;
        data["approvalSeq"] = this.approvalSeq;
        data["dayOfProcess"] = this.dayOfProcess;
        data["positionId"] = this.positionId;
        return data;
    }
}

export interface IApprovalTreeDetailSaveDto {
    id: number;
    approvalTreeId: number;
    approvalTypeId: number;
    hrOrgStructureId: string | undefined;
    listUserId: number[] | undefined;
    titleId: number | undefined;
    approvalSeq: number | undefined;
    dayOfProcess: number | undefined;
    positionId: number | undefined;
}

export class ApprovalTreeSaveDto implements IApprovalTreeSaveDto {
    id!: number;
    processTypeId!: number;
    currencyId!: number;
    amountFrom!: number;
    amountTo!: number;
    inventoryGroupId!: number;
    description!: string | undefined;
    listApprovalTreeDetailSave!: ApprovalTreeDetailSaveDto[] | undefined;
    countItem!: number;

    constructor(data?: IApprovalTreeSaveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.processTypeId = _data["processTypeId"];
            this.currencyId = _data["currencyId"];
            this.amountFrom = _data["amountFrom"];
            this.amountTo = _data["amountTo"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.description = _data["description"];
            if (Array.isArray(_data["listApprovalTreeDetailSave"])) {
                this.listApprovalTreeDetailSave = [] as any;
                for (let item of _data["listApprovalTreeDetailSave"])
                    this.listApprovalTreeDetailSave!.push(ApprovalTreeDetailSaveDto.fromJS(item));
            }
            this.countItem = _data["countItem"];
        }
    }

    static fromJS(data: any): ApprovalTreeSaveDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalTreeSaveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["processTypeId"] = this.processTypeId;
        data["currencyId"] = this.currencyId;
        data["amountFrom"] = this.amountFrom;
        data["amountTo"] = this.amountTo;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["description"] = this.description;
        if (Array.isArray(this.listApprovalTreeDetailSave)) {
            data["listApprovalTreeDetailSave"] = [];
            for (let item of this.listApprovalTreeDetailSave)
                data["listApprovalTreeDetailSave"].push(item.toJSON());
        }
        data["countItem"] = this.countItem;
        return data;
    }
}

export interface IApprovalTreeSaveDto {
    id: number;
    processTypeId: number;
    currencyId: number;
    amountFrom: number;
    amountTo: number;
    inventoryGroupId: number;
    description: string | undefined;
    listApprovalTreeDetailSave: ApprovalTreeDetailSaveDto[] | undefined;
    countItem: number;
}

export class ApprovalTreeDetailOutputSelectDto implements IApprovalTreeDetailOutputSelectDto {
    id!: number;
    approvalTreeId!: number;
    approvalTypeName!: string | undefined;
    hrOrgStructureName!: string | undefined;
    titleName!: string | undefined;

    constructor(data?: IApprovalTreeDetailOutputSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.approvalTreeId = _data["approvalTreeId"];
            this.approvalTypeName = _data["approvalTypeName"];
            this.hrOrgStructureName = _data["hrOrgStructureName"];
            this.titleName = _data["titleName"];
        }
    }

    static fromJS(data: any): ApprovalTreeDetailOutputSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalTreeDetailOutputSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["approvalTreeId"] = this.approvalTreeId;
        data["approvalTypeName"] = this.approvalTypeName;
        data["hrOrgStructureName"] = this.hrOrgStructureName;
        data["titleName"] = this.titleName;
        return data;
    }
}

export interface IApprovalTreeDetailOutputSelectDto {
    id: number;
    approvalTreeId: number;
    approvalTypeName: string | undefined;
    hrOrgStructureName: string | undefined;
    titleName: string | undefined;
}

export class ApprovalTreeDetailSelectDto implements IApprovalTreeDetailSelectDto {
    id!: number;
    processType!: string | undefined;
    currencyName!: string | undefined;
    amountFrom!: number;
    amountTo!: number;
    inventoryGroupName!: string | undefined;
    description!: string | undefined;
    creationTime!: DateTime | undefined;
    listApprovalTreeDetailItem!: ApprovalTreeDetailOutputSelectDto[] | undefined;

    constructor(data?: IApprovalTreeDetailSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.processType = _data["processType"];
            this.currencyName = _data["currencyName"];
            this.amountFrom = _data["amountFrom"];
            this.amountTo = _data["amountTo"];
            this.inventoryGroupName = _data["inventoryGroupName"];
            this.description = _data["description"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["listApprovalTreeDetailItem"])) {
                this.listApprovalTreeDetailItem = [] as any;
                for (let item of _data["listApprovalTreeDetailItem"])
                    this.listApprovalTreeDetailItem!.push(ApprovalTreeDetailOutputSelectDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApprovalTreeDetailSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalTreeDetailSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["processType"] = this.processType;
        data["currencyName"] = this.currencyName;
        data["amountFrom"] = this.amountFrom;
        data["amountTo"] = this.amountTo;
        data["inventoryGroupName"] = this.inventoryGroupName;
        data["description"] = this.description;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        if (Array.isArray(this.listApprovalTreeDetailItem)) {
            data["listApprovalTreeDetailItem"] = [];
            for (let item of this.listApprovalTreeDetailItem)
                data["listApprovalTreeDetailItem"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApprovalTreeDetailSelectDto {
    id: number;
    processType: string | undefined;
    currencyName: string | undefined;
    amountFrom: number;
    amountTo: number;
    inventoryGroupName: string | undefined;
    description: string | undefined;
    creationTime: DateTime | undefined;
    listApprovalTreeDetailItem: ApprovalTreeDetailOutputSelectDto[] | undefined;
}

export class PositionDropdownDto implements IPositionDropdownDto {
    id!: number;
    positionName!: string | undefined;

    constructor(data?: IPositionDropdownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.positionName = _data["positionName"];
        }
    }

    static fromJS(data: any): PositionDropdownDto {
        data = typeof data === 'object' ? data : {};
        let result = new PositionDropdownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["positionName"] = this.positionName;
        return data;
    }
}

export interface IPositionDropdownDto {
    id: number;
    positionName: string | undefined;
}

export class AssessDetailInfoDto implements IAssessDetailInfoDto {
    assessGroupId!: number | undefined;
    assessId!: number | undefined;
    assessName!: string | undefined;
    assessItemName!: string | undefined;
    description!: string | undefined;
    rateValue!: number;
    id!: number | undefined;

    constructor(data?: IAssessDetailInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assessGroupId = _data["assessGroupId"];
            this.assessId = _data["assessId"];
            this.assessName = _data["assessName"];
            this.assessItemName = _data["assessItemName"];
            this.description = _data["description"];
            this.rateValue = _data["rateValue"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AssessDetailInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssessDetailInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessGroupId"] = this.assessGroupId;
        data["assessId"] = this.assessId;
        data["assessName"] = this.assessName;
        data["assessItemName"] = this.assessItemName;
        data["description"] = this.description;
        data["rateValue"] = this.rateValue;
        data["id"] = this.id;
        return data;
    }
}

export interface IAssessDetailInfoDto {
    assessGroupId: number | undefined;
    assessId: number | undefined;
    assessName: string | undefined;
    assessItemName: string | undefined;
    description: string | undefined;
    rateValue: number;
    id: number | undefined;
}

export class AssessInfoDto implements IAssessInfoDto {
    assessName!: string | undefined;
    rateValue!: number;
    assessDetailList!: AssessDetailInfoDto[] | undefined;
    id!: number | undefined;

    constructor(data?: IAssessInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assessName = _data["assessName"];
            this.rateValue = _data["rateValue"];
            if (Array.isArray(_data["assessDetailList"])) {
                this.assessDetailList = [] as any;
                for (let item of _data["assessDetailList"])
                    this.assessDetailList!.push(AssessDetailInfoDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AssessInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssessInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessName"] = this.assessName;
        data["rateValue"] = this.rateValue;
        if (Array.isArray(this.assessDetailList)) {
            data["assessDetailList"] = [];
            for (let item of this.assessDetailList)
                data["assessDetailList"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IAssessInfoDto {
    assessName: string | undefined;
    rateValue: number;
    assessDetailList: AssessDetailInfoDto[] | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfAssessInfoDto implements IPagedResultDtoOfAssessInfoDto {
    totalCount!: number;
    items!: AssessInfoDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAssessInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AssessInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAssessInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAssessInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAssessInfoDto {
    totalCount: number;
    items: AssessInfoDto[] | undefined;
}

export class AssessGroupInfoDto implements IAssessGroupInfoDto {
    assessGroupCode!: string | undefined;
    assessGroupName!: string | undefined;
    assessGroupType!: string | undefined;
    description!: string | undefined;
    assessDetailList!: AssessDetailInfoDto[] | undefined;
    assessList!: AssessInfoDto[] | undefined;
    id!: number | undefined;

    constructor(data?: IAssessGroupInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assessGroupCode = _data["assessGroupCode"];
            this.assessGroupName = _data["assessGroupName"];
            this.assessGroupType = _data["assessGroupType"];
            this.description = _data["description"];
            if (Array.isArray(_data["assessDetailList"])) {
                this.assessDetailList = [] as any;
                for (let item of _data["assessDetailList"])
                    this.assessDetailList!.push(AssessDetailInfoDto.fromJS(item));
            }
            if (Array.isArray(_data["assessList"])) {
                this.assessList = [] as any;
                for (let item of _data["assessList"])
                    this.assessList!.push(AssessInfoDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AssessGroupInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssessGroupInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessGroupCode"] = this.assessGroupCode;
        data["assessGroupName"] = this.assessGroupName;
        data["assessGroupType"] = this.assessGroupType;
        data["description"] = this.description;
        if (Array.isArray(this.assessDetailList)) {
            data["assessDetailList"] = [];
            for (let item of this.assessDetailList)
                data["assessDetailList"].push(item.toJSON());
        }
        if (Array.isArray(this.assessList)) {
            data["assessList"] = [];
            for (let item of this.assessList)
                data["assessList"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IAssessGroupInfoDto {
    assessGroupCode: string | undefined;
    assessGroupName: string | undefined;
    assessGroupType: string | undefined;
    description: string | undefined;
    assessDetailList: AssessDetailInfoDto[] | undefined;
    assessList: AssessInfoDto[] | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfAssessGroupInfoDto implements IPagedResultDtoOfAssessGroupInfoDto {
    totalCount!: number;
    items!: AssessGroupInfoDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAssessGroupInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AssessGroupInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAssessGroupInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAssessGroupInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAssessGroupInfoDto {
    totalCount: number;
    items: AssessGroupInfoDto[] | undefined;
}

export class InputCancelReasonDto implements IInputCancelReasonDto {
    id!: number;
    code!: string | undefined;
    type!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;

    constructor(data?: IInputCancelReasonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.type = _data["type"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): InputCancelReasonDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputCancelReasonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["type"] = this.type;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IInputCancelReasonDto {
    id: number;
    code: string | undefined;
    type: string | undefined;
    name: string | undefined;
    description: string | undefined;
}

export class PagedResultDtoOfInputCancelReasonDto implements IPagedResultDtoOfInputCancelReasonDto {
    totalCount!: number;
    items!: InputCancelReasonDto[] | undefined;

    constructor(data?: IPagedResultDtoOfInputCancelReasonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InputCancelReasonDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfInputCancelReasonDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfInputCancelReasonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfInputCancelReasonDto {
    totalCount: number;
    items: InputCancelReasonDto[] | undefined;
}

export class SearchCatalogOutputDto implements ISearchCatalogOutputDto {
    catalogCode!: string | undefined;
    catalogName!: string | undefined;
    isActive!: boolean;
    inventoryGroupId!: number | undefined;
    id!: number;

    constructor(data?: ISearchCatalogOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalogCode = _data["catalogCode"];
            this.catalogName = _data["catalogName"];
            this.isActive = _data["isActive"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SearchCatalogOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchCatalogOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalogCode"] = this.catalogCode;
        data["catalogName"] = this.catalogName;
        data["isActive"] = this.isActive;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISearchCatalogOutputDto {
    catalogCode: string | undefined;
    catalogName: string | undefined;
    isActive: boolean;
    inventoryGroupId: number | undefined;
    id: number;
}

export class PagedResultDtoOfSearchCatalogOutputDto implements IPagedResultDtoOfSearchCatalogOutputDto {
    totalCount!: number;
    items!: SearchCatalogOutputDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSearchCatalogOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SearchCatalogOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSearchCatalogOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSearchCatalogOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfSearchCatalogOutputDto {
    totalCount: number;
    items: SearchCatalogOutputDto[] | undefined;
}

export class GetMstCategotiesDto implements IGetMstCategotiesDto {
    id!: number;
    structureId!: number;
    segment1!: string | undefined;
    segment2!: string | undefined;

    constructor(data?: IGetMstCategotiesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.structureId = _data["structureId"];
            this.segment1 = _data["segment1"];
            this.segment2 = _data["segment2"];
        }
    }

    static fromJS(data: any): GetMstCategotiesDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMstCategotiesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["structureId"] = this.structureId;
        data["segment1"] = this.segment1;
        data["segment2"] = this.segment2;
        return data;
    }
}

export interface IGetMstCategotiesDto {
    id: number;
    structureId: number;
    segment1: string | undefined;
    segment2: string | undefined;
}

export class GetContractTemplateDto implements IGetContractTemplateDto {
    id!: number;
    templateCode!: string | undefined;
    templateName!: string | undefined;
    inventoryGroupName!: string | undefined;
    isActive!: string | undefined;
    totalCount!: number;
    attachments!: string | undefined;
    description!: string | undefined;

    constructor(data?: IGetContractTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.templateCode = _data["templateCode"];
            this.templateName = _data["templateName"];
            this.inventoryGroupName = _data["inventoryGroupName"];
            this.isActive = _data["isActive"];
            this.totalCount = _data["totalCount"];
            this.attachments = _data["attachments"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GetContractTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetContractTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["templateCode"] = this.templateCode;
        data["templateName"] = this.templateName;
        data["inventoryGroupName"] = this.inventoryGroupName;
        data["isActive"] = this.isActive;
        data["totalCount"] = this.totalCount;
        data["attachments"] = this.attachments;
        data["description"] = this.description;
        return data;
    }
}

export interface IGetContractTemplateDto {
    id: number;
    templateCode: string | undefined;
    templateName: string | undefined;
    inventoryGroupName: string | undefined;
    isActive: string | undefined;
    totalCount: number;
    attachments: string | undefined;
    description: string | undefined;
}

export class PagedResultDtoOfGetContractTemplateDto implements IPagedResultDtoOfGetContractTemplateDto {
    totalCount!: number;
    items!: GetContractTemplateDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetContractTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetContractTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetContractTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetContractTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetContractTemplateDto {
    totalCount: number;
    items: GetContractTemplateDto[] | undefined;
}

export class InputContractTemplateDto implements IInputContractTemplateDto {
    id!: number;
    templateCode!: string | undefined;
    templateName!: string | undefined;
    inventoryGroupId!: number;
    isActive!: string | undefined;
    attachmentFileName!: string | undefined;
    rootPath!: string | undefined;
    description!: string | undefined;

    constructor(data?: IInputContractTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.templateCode = _data["templateCode"];
            this.templateName = _data["templateName"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.isActive = _data["isActive"];
            this.attachmentFileName = _data["attachmentFileName"];
            this.rootPath = _data["rootPath"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): InputContractTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputContractTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["templateCode"] = this.templateCode;
        data["templateName"] = this.templateName;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["isActive"] = this.isActive;
        data["attachmentFileName"] = this.attachmentFileName;
        data["rootPath"] = this.rootPath;
        data["description"] = this.description;
        return data;
    }
}

export interface IInputContractTemplateDto {
    id: number;
    templateCode: string | undefined;
    templateName: string | undefined;
    inventoryGroupId: number;
    isActive: string | undefined;
    attachmentFileName: string | undefined;
    rootPath: string | undefined;
    description: string | undefined;
}

export class LoadAllOutputDto implements ILoadAllOutputDto {
    id!: number;
    currencyCode!: string | undefined;

    constructor(data?: ILoadAllOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.currencyCode = _data["currencyCode"];
        }
    }

    static fromJS(data: any): LoadAllOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoadAllOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["currencyCode"] = this.currencyCode;
        return data;
    }
}

export interface ILoadAllOutputDto {
    id: number;
    currencyCode: string | undefined;
}

export class InputSearchMstCurrency implements IInputSearchMstCurrency {
    currencyCode!: string | undefined;
    name!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IInputSearchMstCurrency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currencyCode = _data["currencyCode"];
            this.name = _data["name"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): InputSearchMstCurrency {
        data = typeof data === 'object' ? data : {};
        let result = new InputSearchMstCurrency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currencyCode"] = this.currencyCode;
        data["name"] = this.name;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data;
    }
}

export interface IInputSearchMstCurrency {
    currencyCode: string | undefined;
    name: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class MstCurrencySelectDto implements IMstCurrencySelectDto {
    id!: number;
    currencyCode!: string | undefined;
    name!: string | undefined;
    descriptionEnglish!: string | undefined;
    descriptionVetNamese!: string | undefined;
    status!: string | undefined;

    constructor(data?: IMstCurrencySelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.currencyCode = _data["currencyCode"];
            this.name = _data["name"];
            this.descriptionEnglish = _data["descriptionEnglish"];
            this.descriptionVetNamese = _data["descriptionVetNamese"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): MstCurrencySelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new MstCurrencySelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["currencyCode"] = this.currencyCode;
        data["name"] = this.name;
        data["descriptionEnglish"] = this.descriptionEnglish;
        data["descriptionVetNamese"] = this.descriptionVetNamese;
        data["status"] = this.status;
        return data;
    }
}

export interface IMstCurrencySelectDto {
    id: number;
    currencyCode: string | undefined;
    name: string | undefined;
    descriptionEnglish: string | undefined;
    descriptionVetNamese: string | undefined;
    status: string | undefined;
}

export class PagedResultDtoOfMstCurrencySelectDto implements IPagedResultDtoOfMstCurrencySelectDto {
    totalCount!: number;
    items!: MstCurrencySelectDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMstCurrencySelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MstCurrencySelectDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMstCurrencySelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMstCurrencySelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMstCurrencySelectDto {
    totalCount: number;
    items: MstCurrencySelectDto[] | undefined;
}

export class MstCurrencyDto implements IMstCurrencyDto {
    id!: number;
    currencyCode!: string | undefined;
    name!: string | undefined;
    descriptionEnglish!: string | undefined;
    descriptionVetNamese!: string | undefined;
    status!: string | undefined;

    constructor(data?: IMstCurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.currencyCode = _data["currencyCode"];
            this.name = _data["name"];
            this.descriptionEnglish = _data["descriptionEnglish"];
            this.descriptionVetNamese = _data["descriptionVetNamese"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): MstCurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new MstCurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["currencyCode"] = this.currencyCode;
        data["name"] = this.name;
        data["descriptionEnglish"] = this.descriptionEnglish;
        data["descriptionVetNamese"] = this.descriptionVetNamese;
        data["status"] = this.status;
        return data;
    }
}

export interface IMstCurrencyDto {
    id: number;
    currencyCode: string | undefined;
    name: string | undefined;
    descriptionEnglish: string | undefined;
    descriptionVetNamese: string | undefined;
    status: string | undefined;
}

export class ValInventoryGroupDto implements IValInventoryGroupDto {
    name!: string | undefined;
    code!: string | undefined;

    constructor(data?: IValInventoryGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): ValInventoryGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValInventoryGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IValInventoryGroupDto {
    name: string | undefined;
    code: string | undefined;
}

export class GetByProvinceIdOutputDto implements IGetByProvinceIdOutputDto {
    id!: number;
    districtName!: string | undefined;
    provinceId!: number;

    constructor(data?: IGetByProvinceIdOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.districtName = _data["districtName"];
            this.provinceId = _data["provinceId"];
        }
    }

    static fromJS(data: any): GetByProvinceIdOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetByProvinceIdOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["districtName"] = this.districtName;
        data["provinceId"] = this.provinceId;
        return data;
    }
}

export interface IGetByProvinceIdOutputDto {
    id: number;
    districtName: string | undefined;
    provinceId: number;
}

export class MstDocumentDto implements IMstDocumentDto {
    id!: number;
    documentCode!: string | undefined;
    documentName!: string | undefined;
    processTypeName!: string | undefined;
    processTypeId!: number | undefined;
    isIrregular!: number | undefined;
    productGroupName!: string | undefined;
    inventoryGroupId!: number | undefined;
    leadtime!: number | undefined;
    status!: string | undefined;

    constructor(data?: IMstDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.documentCode = _data["documentCode"];
            this.documentName = _data["documentName"];
            this.processTypeName = _data["processTypeName"];
            this.processTypeId = _data["processTypeId"];
            this.isIrregular = _data["isIrregular"];
            this.productGroupName = _data["productGroupName"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.leadtime = _data["leadtime"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): MstDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new MstDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["documentCode"] = this.documentCode;
        data["documentName"] = this.documentName;
        data["processTypeName"] = this.processTypeName;
        data["processTypeId"] = this.processTypeId;
        data["isIrregular"] = this.isIrregular;
        data["productGroupName"] = this.productGroupName;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["leadtime"] = this.leadtime;
        data["status"] = this.status;
        return data;
    }
}

export interface IMstDocumentDto {
    id: number;
    documentCode: string | undefined;
    documentName: string | undefined;
    processTypeName: string | undefined;
    processTypeId: number | undefined;
    isIrregular: number | undefined;
    productGroupName: string | undefined;
    inventoryGroupId: number | undefined;
    leadtime: number | undefined;
    status: string | undefined;
}

export class PagedResultDtoOfMstDocumentDto implements IPagedResultDtoOfMstDocumentDto {
    totalCount!: number;
    items!: MstDocumentDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMstDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MstDocumentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMstDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMstDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMstDocumentDto {
    totalCount: number;
    items: MstDocumentDto[] | undefined;
}

export class InputDocumentDto implements IInputDocumentDto {
    code!: string | undefined;
    name!: string | undefined;

    constructor(data?: IInputDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): InputDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        return data;
    }
}

export interface IInputDocumentDto {
    code: string | undefined;
    name: string | undefined;
}

export class ProcessTypeGetAllOutputDto implements IProcessTypeGetAllOutputDto {
    id!: number;
    processTypeCode!: string | undefined;
    processTypeName!: string | undefined;

    constructor(data?: IProcessTypeGetAllOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.processTypeCode = _data["processTypeCode"];
            this.processTypeName = _data["processTypeName"];
        }
    }

    static fromJS(data: any): ProcessTypeGetAllOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessTypeGetAllOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["processTypeCode"] = this.processTypeCode;
        data["processTypeName"] = this.processTypeName;
        return data;
    }
}

export interface IProcessTypeGetAllOutputDto {
    id: number;
    processTypeCode: string | undefined;
    processTypeName: string | undefined;
}

export class PagedResultDtoOfSearchGlCodeOutputDto implements IPagedResultDtoOfSearchGlCodeOutputDto {
    totalCount!: number;
    items!: SearchGlCodeOutputDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSearchGlCodeOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SearchGlCodeOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSearchGlCodeOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSearchGlCodeOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfSearchGlCodeOutputDto {
    totalCount: number;
    items: SearchGlCodeOutputDto[] | undefined;
}

export class SearchOutputDto implements ISearchOutputDto {
    id!: number;
    fromCurrency!: string | undefined;
    toCurrency!: string | undefined;
    conversionRate!: number | undefined;
    conversionDate!: DateTime | undefined;

    constructor(data?: ISearchOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fromCurrency = _data["fromCurrency"];
            this.toCurrency = _data["toCurrency"];
            this.conversionRate = _data["conversionRate"];
            this.conversionDate = _data["conversionDate"] ? DateTime.fromISO(_data["conversionDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SearchOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fromCurrency"] = this.fromCurrency;
        data["toCurrency"] = this.toCurrency;
        data["conversionRate"] = this.conversionRate;
        data["conversionDate"] = this.conversionDate ? this.conversionDate.toString() : <any>undefined;
        return data;
    }
}

export interface ISearchOutputDto {
    id: number;
    fromCurrency: string | undefined;
    toCurrency: string | undefined;
    conversionRate: number | undefined;
    conversionDate: DateTime | undefined;
}

export class PagedResultDtoOfSearchOutputDto implements IPagedResultDtoOfSearchOutputDto {
    totalCount!: number;
    items!: SearchOutputDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSearchOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SearchOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSearchOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSearchOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfSearchOutputDto {
    totalCount: number;
    items: SearchOutputDto[] | undefined;
}

export class InputMstGlExchangeRateExportDto implements IInputMstGlExchangeRateExportDto {
    currencyId!: number | undefined;
    toCurrencyId!: number | undefined;
    startDate!: DateTime | undefined;
    endDate!: DateTime | undefined;

    constructor(data?: IInputMstGlExchangeRateExportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currencyId = _data["currencyId"];
            this.toCurrencyId = _data["toCurrencyId"];
            this.startDate = _data["startDate"] ? DateTime.fromISO(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? DateTime.fromISO(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InputMstGlExchangeRateExportDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputMstGlExchangeRateExportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currencyId"] = this.currencyId;
        data["toCurrencyId"] = this.toCurrencyId;
        data["startDate"] = this.startDate ? this.startDate.toString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toString() : <any>undefined;
        return data;
    }
}

export interface IInputMstGlExchangeRateExportDto {
    currencyId: number | undefined;
    toCurrencyId: number | undefined;
    startDate: DateTime | undefined;
    endDate: DateTime | undefined;
}

export class MstHrOrgStructureOutputDto implements IMstHrOrgStructureOutputDto {
    id!: string | undefined;
    hrOrgStructureName!: string | undefined;

    constructor(data?: IMstHrOrgStructureOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.hrOrgStructureName = _data["hrOrgStructureName"];
        }
    }

    static fromJS(data: any): MstHrOrgStructureOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new MstHrOrgStructureOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["hrOrgStructureName"] = this.hrOrgStructureName;
        return data;
    }
}

export interface IMstHrOrgStructureOutputDto {
    id: string | undefined;
    hrOrgStructureName: string | undefined;
}

export class MstHrOrgStructureEmployeeOutputDto implements IMstHrOrgStructureEmployeeOutputDto {
    id!: number;
    employeeName!: string | undefined;
    hrOrgStructureId!: string | undefined;

    constructor(data?: IMstHrOrgStructureEmployeeOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeName = _data["employeeName"];
            this.hrOrgStructureId = _data["hrOrgStructureId"];
        }
    }

    static fromJS(data: any): MstHrOrgStructureEmployeeOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new MstHrOrgStructureEmployeeOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeName"] = this.employeeName;
        data["hrOrgStructureId"] = this.hrOrgStructureId;
        return data;
    }
}

export interface IMstHrOrgStructureEmployeeOutputDto {
    id: number;
    employeeName: string | undefined;
    hrOrgStructureId: string | undefined;
}

export class MstInventoryCodeConfigDto implements IMstInventoryCodeConfigDto {
    id!: number | undefined;
    inventoryGroupCode!: string | undefined;
    inventoryGroupName!: string | undefined;
    codeHeader!: string | undefined;
    startNum!: string | undefined;
    endNum!: string | undefined;
    currentNum!: string | undefined;
    status!: string | undefined;
    docCode!: string | undefined;

    constructor(data?: IMstInventoryCodeConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.inventoryGroupCode = _data["inventoryGroupCode"];
            this.inventoryGroupName = _data["inventoryGroupName"];
            this.codeHeader = _data["codeHeader"];
            this.startNum = _data["startNum"];
            this.endNum = _data["endNum"];
            this.currentNum = _data["currentNum"];
            this.status = _data["status"];
            this.docCode = _data["docCode"];
        }
    }

    static fromJS(data: any): MstInventoryCodeConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new MstInventoryCodeConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["inventoryGroupCode"] = this.inventoryGroupCode;
        data["inventoryGroupName"] = this.inventoryGroupName;
        data["codeHeader"] = this.codeHeader;
        data["startNum"] = this.startNum;
        data["endNum"] = this.endNum;
        data["currentNum"] = this.currentNum;
        data["status"] = this.status;
        data["docCode"] = this.docCode;
        return data;
    }
}

export interface IMstInventoryCodeConfigDto {
    id: number | undefined;
    inventoryGroupCode: string | undefined;
    inventoryGroupName: string | undefined;
    codeHeader: string | undefined;
    startNum: string | undefined;
    endNum: string | undefined;
    currentNum: string | undefined;
    status: string | undefined;
    docCode: string | undefined;
}

export class PagedResultDtoOfMstInventoryCodeConfigDto implements IPagedResultDtoOfMstInventoryCodeConfigDto {
    totalCount!: number;
    items!: MstInventoryCodeConfigDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMstInventoryCodeConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MstInventoryCodeConfigDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMstInventoryCodeConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMstInventoryCodeConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMstInventoryCodeConfigDto {
    totalCount: number;
    items: MstInventoryCodeConfigDto[] | undefined;
}

export class InputSearchInventoryCodeConfigDto implements IInputSearchInventoryCodeConfigDto {
    inventoryGroupCode!: string | undefined;
    inventoryGroupName!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IInputSearchInventoryCodeConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inventoryGroupCode = _data["inventoryGroupCode"];
            this.inventoryGroupName = _data["inventoryGroupName"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): InputSearchInventoryCodeConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputSearchInventoryCodeConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inventoryGroupCode"] = this.inventoryGroupCode;
        data["inventoryGroupName"] = this.inventoryGroupName;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data;
    }
}

export interface IInputSearchInventoryCodeConfigDto {
    inventoryGroupCode: string | undefined;
    inventoryGroupName: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class GetMstInventoryGroupDto implements IGetMstInventoryGroupDto {
    id!: number;
    productGroupName!: string | undefined;
    productGroupCode!: string | undefined;
    isCatalog!: boolean | undefined;
    isInventory!: boolean | undefined;

    constructor(data?: IGetMstInventoryGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productGroupName = _data["productGroupName"];
            this.productGroupCode = _data["productGroupCode"];
            this.isCatalog = _data["isCatalog"];
            this.isInventory = _data["isInventory"];
        }
    }

    static fromJS(data: any): GetMstInventoryGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMstInventoryGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productGroupName"] = this.productGroupName;
        data["productGroupCode"] = this.productGroupCode;
        data["isCatalog"] = this.isCatalog;
        data["isInventory"] = this.isInventory;
        return data;
    }
}

export interface IGetMstInventoryGroupDto {
    id: number;
    productGroupName: string | undefined;
    productGroupCode: string | undefined;
    isCatalog: boolean | undefined;
    isInventory: boolean | undefined;
}

export class MstInventoryGroupDto implements IMstInventoryGroupDto {
    productGroupName!: string | undefined;
    productGroupCode!: string | undefined;
    picDepartmentId!: string | undefined;
    purchaDepartmentId!: string | undefined;
    deliDepartmentId!: string | undefined;
    productGroupId!: number | undefined;
    isCatalog!: boolean | undefined;
    departmentName!: string | undefined;
    purchaDepartmentName!: string | undefined;
    deliDepartmentName!: string | undefined;
    productName!: string | undefined;
    userName!: string | undefined;
    description!: string | undefined;
    isInventory!: boolean | undefined;
    ur!: boolean | undefined;
    pr!: boolean | undefined;
    po!: boolean | undefined;
    status!: string | undefined;
    budgetCode!: string | undefined;
    organizationName!: string | undefined;
    location!: string | undefined;
    purchasePurpose!: string | undefined;
    listUser!: UserSearchByHrOgrDto[] | undefined;
    id!: number;

    constructor(data?: IMstInventoryGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productGroupName = _data["productGroupName"];
            this.productGroupCode = _data["productGroupCode"];
            this.picDepartmentId = _data["picDepartmentId"];
            this.purchaDepartmentId = _data["purchaDepartmentId"];
            this.deliDepartmentId = _data["deliDepartmentId"];
            this.productGroupId = _data["productGroupId"];
            this.isCatalog = _data["isCatalog"];
            this.departmentName = _data["departmentName"];
            this.purchaDepartmentName = _data["purchaDepartmentName"];
            this.deliDepartmentName = _data["deliDepartmentName"];
            this.productName = _data["productName"];
            this.userName = _data["userName"];
            this.description = _data["description"];
            this.isInventory = _data["isInventory"];
            this.ur = _data["ur"];
            this.pr = _data["pr"];
            this.po = _data["po"];
            this.status = _data["status"];
            this.budgetCode = _data["budgetCode"];
            this.organizationName = _data["organizationName"];
            this.location = _data["location"];
            this.purchasePurpose = _data["purchasePurpose"];
            if (Array.isArray(_data["listUser"])) {
                this.listUser = [] as any;
                for (let item of _data["listUser"])
                    this.listUser!.push(UserSearchByHrOgrDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MstInventoryGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new MstInventoryGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productGroupName"] = this.productGroupName;
        data["productGroupCode"] = this.productGroupCode;
        data["picDepartmentId"] = this.picDepartmentId;
        data["purchaDepartmentId"] = this.purchaDepartmentId;
        data["deliDepartmentId"] = this.deliDepartmentId;
        data["productGroupId"] = this.productGroupId;
        data["isCatalog"] = this.isCatalog;
        data["departmentName"] = this.departmentName;
        data["purchaDepartmentName"] = this.purchaDepartmentName;
        data["deliDepartmentName"] = this.deliDepartmentName;
        data["productName"] = this.productName;
        data["userName"] = this.userName;
        data["description"] = this.description;
        data["isInventory"] = this.isInventory;
        data["ur"] = this.ur;
        data["pr"] = this.pr;
        data["po"] = this.po;
        data["status"] = this.status;
        data["budgetCode"] = this.budgetCode;
        data["organizationName"] = this.organizationName;
        data["location"] = this.location;
        data["purchasePurpose"] = this.purchasePurpose;
        if (Array.isArray(this.listUser)) {
            data["listUser"] = [];
            for (let item of this.listUser)
                data["listUser"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IMstInventoryGroupDto {
    productGroupName: string | undefined;
    productGroupCode: string | undefined;
    picDepartmentId: string | undefined;
    purchaDepartmentId: string | undefined;
    deliDepartmentId: string | undefined;
    productGroupId: number | undefined;
    isCatalog: boolean | undefined;
    departmentName: string | undefined;
    purchaDepartmentName: string | undefined;
    deliDepartmentName: string | undefined;
    productName: string | undefined;
    userName: string | undefined;
    description: string | undefined;
    isInventory: boolean | undefined;
    ur: boolean | undefined;
    pr: boolean | undefined;
    po: boolean | undefined;
    status: string | undefined;
    budgetCode: string | undefined;
    organizationName: string | undefined;
    location: string | undefined;
    purchasePurpose: string | undefined;
    listUser: UserSearchByHrOgrDto[] | undefined;
    id: number;
}

export class PagedResultDtoOfMstInventoryGroupDto implements IPagedResultDtoOfMstInventoryGroupDto {
    totalCount!: number;
    items!: MstInventoryGroupDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMstInventoryGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MstInventoryGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMstInventoryGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMstInventoryGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMstInventoryGroupDto {
    totalCount: number;
    items: MstInventoryGroupDto[] | undefined;
}

export class InputMstInventoryGroupExportDto implements IInputMstInventoryGroupExportDto {
    iventoryGroupName!: string | undefined;
    iventoryGroupCode!: string | undefined;

    constructor(data?: IInputMstInventoryGroupExportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iventoryGroupName = _data["iventoryGroupName"];
            this.iventoryGroupCode = _data["iventoryGroupCode"];
        }
    }

    static fromJS(data: any): InputMstInventoryGroupExportDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputMstInventoryGroupExportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iventoryGroupName"] = this.iventoryGroupName;
        data["iventoryGroupCode"] = this.iventoryGroupCode;
        return data;
    }
}

export interface IInputMstInventoryGroupExportDto {
    iventoryGroupName: string | undefined;
    iventoryGroupCode: string | undefined;
}

export class GetByInventoryItemOutputDto implements IGetByInventoryItemOutputDto {
    id!: number;
    unitOfMeasure!: string | undefined;
    partName!: string | undefined;
    currencyCode!: string | undefined;
    effectiveFrom!: DateTime | undefined;
    effectiveTo!: DateTime | undefined;
    unitPrice!: number;
    totalCount!: number;

    constructor(data?: IGetByInventoryItemOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.partName = _data["partName"];
            this.currencyCode = _data["currencyCode"];
            this.effectiveFrom = _data["effectiveFrom"] ? DateTime.fromISO(_data["effectiveFrom"].toString()) : <any>undefined;
            this.effectiveTo = _data["effectiveTo"] ? DateTime.fromISO(_data["effectiveTo"].toString()) : <any>undefined;
            this.unitPrice = _data["unitPrice"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetByInventoryItemOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetByInventoryItemOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["partName"] = this.partName;
        data["currencyCode"] = this.currencyCode;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toString() : <any>undefined;
        data["effectiveTo"] = this.effectiveTo ? this.effectiveTo.toString() : <any>undefined;
        data["unitPrice"] = this.unitPrice;
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IGetByInventoryItemOutputDto {
    id: number;
    unitOfMeasure: string | undefined;
    partName: string | undefined;
    currencyCode: string | undefined;
    effectiveFrom: DateTime | undefined;
    effectiveTo: DateTime | undefined;
    unitPrice: number;
    totalCount: number;
}

export class PagedResultDtoOfGetByInventoryItemOutputDto implements IPagedResultDtoOfGetByInventoryItemOutputDto {
    totalCount!: number;
    items!: GetByInventoryItemOutputDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetByInventoryItemOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetByInventoryItemOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetByInventoryItemOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetByInventoryItemOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetByInventoryItemOutputDto {
    totalCount: number;
    items: GetByInventoryItemOutputDto[] | undefined;
}

export class CreateOrEditInventoryItemPriceDto implements ICreateOrEditInventoryItemPriceDto {
    id!: number;
    unitOfMeasureId!: number | undefined;
    currencyId!: number | undefined;
    effectiveFrom!: DateTime | undefined;
    effectiveTo!: DateTime | undefined;
    unitPrice!: number | undefined;
    taxPrice!: number | undefined;

    constructor(data?: ICreateOrEditInventoryItemPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.unitOfMeasureId = _data["unitOfMeasureId"];
            this.currencyId = _data["currencyId"];
            this.effectiveFrom = _data["effectiveFrom"] ? DateTime.fromISO(_data["effectiveFrom"].toString()) : <any>undefined;
            this.effectiveTo = _data["effectiveTo"] ? DateTime.fromISO(_data["effectiveTo"].toString()) : <any>undefined;
            this.unitPrice = _data["unitPrice"];
            this.taxPrice = _data["taxPrice"];
        }
    }

    static fromJS(data: any): CreateOrEditInventoryItemPriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditInventoryItemPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["unitOfMeasureId"] = this.unitOfMeasureId;
        data["currencyId"] = this.currencyId;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toString() : <any>undefined;
        data["effectiveTo"] = this.effectiveTo ? this.effectiveTo.toString() : <any>undefined;
        data["unitPrice"] = this.unitPrice;
        data["taxPrice"] = this.taxPrice;
        return data;
    }
}

export interface ICreateOrEditInventoryItemPriceDto {
    id: number;
    unitOfMeasureId: number | undefined;
    currencyId: number | undefined;
    effectiveFrom: DateTime | undefined;
    effectiveTo: DateTime | undefined;
    unitPrice: number | undefined;
    taxPrice: number | undefined;
}

export class GetInventoryItemPriceForEditOutput implements IGetInventoryItemPriceForEditOutput {
    id!: number;
    unitOfMeasureId!: number | undefined;
    currencyId!: number | undefined;
    effectiveFrom!: DateTime | undefined;
    effectiveTo!: DateTime | undefined;
    unitPrice!: number | undefined;
    taxPrice!: number | undefined;

    constructor(data?: IGetInventoryItemPriceForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.unitOfMeasureId = _data["unitOfMeasureId"];
            this.currencyId = _data["currencyId"];
            this.effectiveFrom = _data["effectiveFrom"] ? DateTime.fromISO(_data["effectiveFrom"].toString()) : <any>undefined;
            this.effectiveTo = _data["effectiveTo"] ? DateTime.fromISO(_data["effectiveTo"].toString()) : <any>undefined;
            this.unitPrice = _data["unitPrice"];
            this.taxPrice = _data["taxPrice"];
        }
    }

    static fromJS(data: any): GetInventoryItemPriceForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetInventoryItemPriceForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["unitOfMeasureId"] = this.unitOfMeasureId;
        data["currencyId"] = this.currencyId;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toString() : <any>undefined;
        data["effectiveTo"] = this.effectiveTo ? this.effectiveTo.toString() : <any>undefined;
        data["unitPrice"] = this.unitPrice;
        data["taxPrice"] = this.taxPrice;
        return data;
    }
}

export interface IGetInventoryItemPriceForEditOutput {
    id: number;
    unitOfMeasureId: number | undefined;
    currencyId: number | undefined;
    effectiveFrom: DateTime | undefined;
    effectiveTo: DateTime | undefined;
    unitPrice: number | undefined;
    taxPrice: number | undefined;
}

export class ImpInventoryItemPriceDto implements IImpInventoryItemPriceDto {
    itemsCode!: string | undefined;
    partNameSupplier!: string | undefined;
    supplierCode!: string | undefined;
    taxPrice!: number | undefined;
    unitOfMeasureId!: number | undefined;
    unitPrice!: number | undefined;
    currencyId!: number | undefined;
    supplierId!: number | undefined;
    inventoryItemId!: number | undefined;
    effectiveFrom!: string | undefined;
    effectiveTo!: string | undefined;
    unitOfMeasure!: string | undefined;
    currencyCode!: string | undefined;
    creatorUserId!: number | undefined;
    remark!: string | undefined;

    constructor(data?: IImpInventoryItemPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemsCode = _data["itemsCode"];
            this.partNameSupplier = _data["partNameSupplier"];
            this.supplierCode = _data["supplierCode"];
            this.taxPrice = _data["taxPrice"];
            this.unitOfMeasureId = _data["unitOfMeasureId"];
            this.unitPrice = _data["unitPrice"];
            this.currencyId = _data["currencyId"];
            this.supplierId = _data["supplierId"];
            this.inventoryItemId = _data["inventoryItemId"];
            this.effectiveFrom = _data["effectiveFrom"];
            this.effectiveTo = _data["effectiveTo"];
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.currencyCode = _data["currencyCode"];
            this.creatorUserId = _data["creatorUserId"];
            this.remark = _data["remark"];
        }
    }

    static fromJS(data: any): ImpInventoryItemPriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImpInventoryItemPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemsCode"] = this.itemsCode;
        data["partNameSupplier"] = this.partNameSupplier;
        data["supplierCode"] = this.supplierCode;
        data["taxPrice"] = this.taxPrice;
        data["unitOfMeasureId"] = this.unitOfMeasureId;
        data["unitPrice"] = this.unitPrice;
        data["currencyId"] = this.currencyId;
        data["supplierId"] = this.supplierId;
        data["inventoryItemId"] = this.inventoryItemId;
        data["effectiveFrom"] = this.effectiveFrom;
        data["effectiveTo"] = this.effectiveTo;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["currencyCode"] = this.currencyCode;
        data["creatorUserId"] = this.creatorUserId;
        data["remark"] = this.remark;
        return data;
    }
}

export interface IImpInventoryItemPriceDto {
    itemsCode: string | undefined;
    partNameSupplier: string | undefined;
    supplierCode: string | undefined;
    taxPrice: number | undefined;
    unitOfMeasureId: number | undefined;
    unitPrice: number | undefined;
    currencyId: number | undefined;
    supplierId: number | undefined;
    inventoryItemId: number | undefined;
    effectiveFrom: string | undefined;
    effectiveTo: string | undefined;
    unitOfMeasure: string | undefined;
    currencyCode: string | undefined;
    creatorUserId: number | undefined;
    remark: string | undefined;
}

export class GetByInventoryItemPriceOutputDto implements IGetByInventoryItemPriceOutputDto {
    id!: number;
    partNo!: string | undefined;
    color!: string | undefined;
    partName!: string | undefined;
    partNameSupplier!: string | undefined;
    supplierName!: string | undefined;
    currencyCode!: string | undefined;
    unitPrice!: number;
    taxPrice!: number;
    effectiveFrom!: DateTime | undefined;
    effectiveTo!: DateTime | undefined;

    constructor(data?: IGetByInventoryItemPriceOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.partNo = _data["partNo"];
            this.color = _data["color"];
            this.partName = _data["partName"];
            this.partNameSupplier = _data["partNameSupplier"];
            this.supplierName = _data["supplierName"];
            this.currencyCode = _data["currencyCode"];
            this.unitPrice = _data["unitPrice"];
            this.taxPrice = _data["taxPrice"];
            this.effectiveFrom = _data["effectiveFrom"] ? DateTime.fromISO(_data["effectiveFrom"].toString()) : <any>undefined;
            this.effectiveTo = _data["effectiveTo"] ? DateTime.fromISO(_data["effectiveTo"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetByInventoryItemPriceOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetByInventoryItemPriceOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["partNo"] = this.partNo;
        data["color"] = this.color;
        data["partName"] = this.partName;
        data["partNameSupplier"] = this.partNameSupplier;
        data["supplierName"] = this.supplierName;
        data["currencyCode"] = this.currencyCode;
        data["unitPrice"] = this.unitPrice;
        data["taxPrice"] = this.taxPrice;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toString() : <any>undefined;
        data["effectiveTo"] = this.effectiveTo ? this.effectiveTo.toString() : <any>undefined;
        return data;
    }
}

export interface IGetByInventoryItemPriceOutputDto {
    id: number;
    partNo: string | undefined;
    color: string | undefined;
    partName: string | undefined;
    partNameSupplier: string | undefined;
    supplierName: string | undefined;
    currencyCode: string | undefined;
    unitPrice: number;
    taxPrice: number;
    effectiveFrom: DateTime | undefined;
    effectiveTo: DateTime | undefined;
}

export class PagedResultDtoOfGetByInventoryItemPriceOutputDto implements IPagedResultDtoOfGetByInventoryItemPriceOutputDto {
    totalCount!: number;
    items!: GetByInventoryItemPriceOutputDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetByInventoryItemPriceOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetByInventoryItemPriceOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetByInventoryItemPriceOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetByInventoryItemPriceOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetByInventoryItemPriceOutputDto {
    totalCount: number;
    items: GetByInventoryItemPriceOutputDto[] | undefined;
}

export class InventoryItemsSearchInputDto implements IInventoryItemsSearchInputDto {
    keyword!: string | undefined;
    inventoryGroupId!: number | undefined;
    catalogId!: number | undefined;
    supplierId!: number | undefined;
    page!: number;
    pageSize!: number;

    constructor(data?: IInventoryItemsSearchInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyword = _data["keyword"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.catalogId = _data["catalogId"];
            this.supplierId = _data["supplierId"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): InventoryItemsSearchInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryItemsSearchInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyword"] = this.keyword;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["catalogId"] = this.catalogId;
        data["supplierId"] = this.supplierId;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IInventoryItemsSearchInputDto {
    keyword: string | undefined;
    inventoryGroupId: number | undefined;
    catalogId: number | undefined;
    supplierId: number | undefined;
    page: number;
    pageSize: number;
}

export class InventoryItemsSearchOutputDto implements IInventoryItemsSearchOutputDto {
    id!: number;
    organizationId!: number | undefined;
    organizationName!: string | undefined;
    inventoryGroupId!: number | undefined;
    partNo!: string | undefined;
    partNoCPS!: string | undefined;
    partCode!: string | undefined;
    color!: string | undefined;
    partName!: string | undefined;
    partNameSupplier!: string | undefined;
    unitPrice!: number | undefined;
    currencyCode!: string | undefined;
    currencyId!: number | undefined;
    supplierName!: string | undefined;
    supplierId!: number | undefined;
    taxPrice!: number | undefined;
    productGroupName!: string | undefined;
    primaryUomCode!: string | undefined;
    primaryUnitOfMeasure!: string | undefined;
    effectiveFrom!: DateTime | undefined;
    effectiveTo!: DateTime | undefined;
    totalCount!: number;
    costOfSalesAccount!: string | undefined;
    expenseAccount!: string | undefined;
    salesAccount!: string | undefined;
    isActive!: number | undefined;
    imageFileName!: string | undefined;
    base64Image!: string | undefined;
    countItem!: number | undefined;
    source!: string | undefined;
    catalog!: number | undefined;
    producer!: string | undefined;
    origin!: string | undefined;
    howToPack!: string | undefined;
    availableTime!: DateTime | undefined;
    priority!: number | undefined;
    safetyStockLevel!: number | undefined;
    minimumQuantity!: number | undefined;
    factoryUse!: string | undefined;
    convertionUnitOfCode!: string | undefined;
    material!: string | undefined;
    length!: number | undefined;
    width!: number | undefined;
    height!: number | undefined;
    unitLength!: string | undefined;
    unitWidth!: string | undefined;
    unitHeight!: string | undefined;
    weight!: number | undefined;
    unitWeight!: string | undefined;

    constructor(data?: IInventoryItemsSearchOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.organizationId = _data["organizationId"];
            this.organizationName = _data["organizationName"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.partNo = _data["partNo"];
            this.partNoCPS = _data["partNoCPS"];
            this.partCode = _data["partCode"];
            this.color = _data["color"];
            this.partName = _data["partName"];
            this.partNameSupplier = _data["partNameSupplier"];
            this.unitPrice = _data["unitPrice"];
            this.currencyCode = _data["currencyCode"];
            this.currencyId = _data["currencyId"];
            this.supplierName = _data["supplierName"];
            this.supplierId = _data["supplierId"];
            this.taxPrice = _data["taxPrice"];
            this.productGroupName = _data["productGroupName"];
            this.primaryUomCode = _data["primaryUomCode"];
            this.primaryUnitOfMeasure = _data["primaryUnitOfMeasure"];
            this.effectiveFrom = _data["effectiveFrom"] ? DateTime.fromISO(_data["effectiveFrom"].toString()) : <any>undefined;
            this.effectiveTo = _data["effectiveTo"] ? DateTime.fromISO(_data["effectiveTo"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
            this.costOfSalesAccount = _data["costOfSalesAccount"];
            this.expenseAccount = _data["expenseAccount"];
            this.salesAccount = _data["salesAccount"];
            this.isActive = _data["isActive"];
            this.imageFileName = _data["imageFileName"];
            this.base64Image = _data["base64Image"];
            this.countItem = _data["countItem"];
            this.source = _data["source"];
            this.catalog = _data["catalog"];
            this.producer = _data["producer"];
            this.origin = _data["origin"];
            this.howToPack = _data["howToPack"];
            this.availableTime = _data["availableTime"] ? DateTime.fromISO(_data["availableTime"].toString()) : <any>undefined;
            this.priority = _data["priority"];
            this.safetyStockLevel = _data["safetyStockLevel"];
            this.minimumQuantity = _data["minimumQuantity"];
            this.factoryUse = _data["factoryUse"];
            this.convertionUnitOfCode = _data["convertionUnitOfCode"];
            this.material = _data["material"];
            this.length = _data["length"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.unitLength = _data["unitLength"];
            this.unitWidth = _data["unitWidth"];
            this.unitHeight = _data["unitHeight"];
            this.weight = _data["weight"];
            this.unitWeight = _data["unitWeight"];
        }
    }

    static fromJS(data: any): InventoryItemsSearchOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryItemsSearchOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["partNo"] = this.partNo;
        data["partNoCPS"] = this.partNoCPS;
        data["partCode"] = this.partCode;
        data["color"] = this.color;
        data["partName"] = this.partName;
        data["partNameSupplier"] = this.partNameSupplier;
        data["unitPrice"] = this.unitPrice;
        data["currencyCode"] = this.currencyCode;
        data["currencyId"] = this.currencyId;
        data["supplierName"] = this.supplierName;
        data["supplierId"] = this.supplierId;
        data["taxPrice"] = this.taxPrice;
        data["productGroupName"] = this.productGroupName;
        data["primaryUomCode"] = this.primaryUomCode;
        data["primaryUnitOfMeasure"] = this.primaryUnitOfMeasure;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toString() : <any>undefined;
        data["effectiveTo"] = this.effectiveTo ? this.effectiveTo.toString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["costOfSalesAccount"] = this.costOfSalesAccount;
        data["expenseAccount"] = this.expenseAccount;
        data["salesAccount"] = this.salesAccount;
        data["isActive"] = this.isActive;
        data["imageFileName"] = this.imageFileName;
        data["base64Image"] = this.base64Image;
        data["countItem"] = this.countItem;
        data["source"] = this.source;
        data["catalog"] = this.catalog;
        data["producer"] = this.producer;
        data["origin"] = this.origin;
        data["howToPack"] = this.howToPack;
        data["availableTime"] = this.availableTime ? this.availableTime.toString() : <any>undefined;
        data["priority"] = this.priority;
        data["safetyStockLevel"] = this.safetyStockLevel;
        data["minimumQuantity"] = this.minimumQuantity;
        data["factoryUse"] = this.factoryUse;
        data["convertionUnitOfCode"] = this.convertionUnitOfCode;
        data["material"] = this.material;
        data["length"] = this.length;
        data["width"] = this.width;
        data["height"] = this.height;
        data["unitLength"] = this.unitLength;
        data["unitWidth"] = this.unitWidth;
        data["unitHeight"] = this.unitHeight;
        data["weight"] = this.weight;
        data["unitWeight"] = this.unitWeight;
        return data;
    }
}

export interface IInventoryItemsSearchOutputDto {
    id: number;
    organizationId: number | undefined;
    organizationName: string | undefined;
    inventoryGroupId: number | undefined;
    partNo: string | undefined;
    partNoCPS: string | undefined;
    partCode: string | undefined;
    color: string | undefined;
    partName: string | undefined;
    partNameSupplier: string | undefined;
    unitPrice: number | undefined;
    currencyCode: string | undefined;
    currencyId: number | undefined;
    supplierName: string | undefined;
    supplierId: number | undefined;
    taxPrice: number | undefined;
    productGroupName: string | undefined;
    primaryUomCode: string | undefined;
    primaryUnitOfMeasure: string | undefined;
    effectiveFrom: DateTime | undefined;
    effectiveTo: DateTime | undefined;
    totalCount: number;
    costOfSalesAccount: string | undefined;
    expenseAccount: string | undefined;
    salesAccount: string | undefined;
    isActive: number | undefined;
    imageFileName: string | undefined;
    base64Image: string | undefined;
    countItem: number | undefined;
    source: string | undefined;
    catalog: number | undefined;
    producer: string | undefined;
    origin: string | undefined;
    howToPack: string | undefined;
    availableTime: DateTime | undefined;
    priority: number | undefined;
    safetyStockLevel: number | undefined;
    minimumQuantity: number | undefined;
    factoryUse: string | undefined;
    convertionUnitOfCode: string | undefined;
    material: string | undefined;
    length: number | undefined;
    width: number | undefined;
    height: number | undefined;
    unitLength: string | undefined;
    unitWidth: string | undefined;
    unitHeight: string | undefined;
    weight: number | undefined;
    unitWeight: string | undefined;
}

export class PagedResultDtoOfInventoryItemsSearchOutputDto implements IPagedResultDtoOfInventoryItemsSearchOutputDto {
    totalCount!: number;
    items!: InventoryItemsSearchOutputDto[] | undefined;

    constructor(data?: IPagedResultDtoOfInventoryItemsSearchOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InventoryItemsSearchOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfInventoryItemsSearchOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfInventoryItemsSearchOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfInventoryItemsSearchOutputDto {
    totalCount: number;
    items: InventoryItemsSearchOutputDto[] | undefined;
}

export class ProductImportDto implements IProductImportDto {
    productGroupName!: string | undefined;
    catalog!: string | undefined;
    itemsCode!: string | undefined;
    specification!: string | undefined;
    applicableProgram!: string | undefined;
    itemsName!: string | undefined;
    color!: string | undefined;
    partNameSupplier!: string | undefined;
    supplierName!: string | undefined;
    unitOfMeasure!: string | undefined;
    producer!: string | undefined;
    origin!: string | undefined;
    howToPack!: string | undefined;
    availableTime!: string | undefined;
    priority!: number;
    safetyStockLevel!: number;
    minimumQuantity!: number;
    factoryUse!: string | undefined;
    convertionUnitOfCode!: string | undefined;
    material!: string | undefined;
    length!: number;
    width!: number;
    height!: number;
    unitLength!: string | undefined;
    unitWidth!: string | undefined;
    unitHeight!: string | undefined;
    weight!: number;
    unitWeight!: string | undefined;
    inventoryItemId!: number | undefined;
    inventoryGroupId!: number | undefined;
    creatorUserId!: number | undefined;
    productImage!: string | undefined;
    byteFileImage!: string | undefined;
    remark!: string | undefined;
    currencyCode!: string | undefined;

    constructor(data?: IProductImportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productGroupName = _data["productGroupName"];
            this.catalog = _data["catalog"];
            this.itemsCode = _data["itemsCode"];
            this.specification = _data["specification"];
            this.applicableProgram = _data["applicableProgram"];
            this.itemsName = _data["itemsName"];
            this.color = _data["color"];
            this.partNameSupplier = _data["partNameSupplier"];
            this.supplierName = _data["supplierName"];
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.producer = _data["producer"];
            this.origin = _data["origin"];
            this.howToPack = _data["howToPack"];
            this.availableTime = _data["availableTime"];
            this.priority = _data["priority"];
            this.safetyStockLevel = _data["safetyStockLevel"];
            this.minimumQuantity = _data["minimumQuantity"];
            this.factoryUse = _data["factoryUse"];
            this.convertionUnitOfCode = _data["convertionUnitOfCode"];
            this.material = _data["material"];
            this.length = _data["length"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.unitLength = _data["unitLength"];
            this.unitWidth = _data["unitWidth"];
            this.unitHeight = _data["unitHeight"];
            this.weight = _data["weight"];
            this.unitWeight = _data["unitWeight"];
            this.inventoryItemId = _data["inventoryItemId"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.creatorUserId = _data["creatorUserId"];
            this.productImage = _data["productImage"];
            this.byteFileImage = _data["byteFileImage"];
            this.remark = _data["remark"];
            this.currencyCode = _data["currencyCode"];
        }
    }

    static fromJS(data: any): ProductImportDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductImportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productGroupName"] = this.productGroupName;
        data["catalog"] = this.catalog;
        data["itemsCode"] = this.itemsCode;
        data["specification"] = this.specification;
        data["applicableProgram"] = this.applicableProgram;
        data["itemsName"] = this.itemsName;
        data["color"] = this.color;
        data["partNameSupplier"] = this.partNameSupplier;
        data["supplierName"] = this.supplierName;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["producer"] = this.producer;
        data["origin"] = this.origin;
        data["howToPack"] = this.howToPack;
        data["availableTime"] = this.availableTime;
        data["priority"] = this.priority;
        data["safetyStockLevel"] = this.safetyStockLevel;
        data["minimumQuantity"] = this.minimumQuantity;
        data["factoryUse"] = this.factoryUse;
        data["convertionUnitOfCode"] = this.convertionUnitOfCode;
        data["material"] = this.material;
        data["length"] = this.length;
        data["width"] = this.width;
        data["height"] = this.height;
        data["unitLength"] = this.unitLength;
        data["unitWidth"] = this.unitWidth;
        data["unitHeight"] = this.unitHeight;
        data["weight"] = this.weight;
        data["unitWeight"] = this.unitWeight;
        data["inventoryItemId"] = this.inventoryItemId;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["creatorUserId"] = this.creatorUserId;
        data["productImage"] = this.productImage;
        data["byteFileImage"] = this.byteFileImage;
        data["remark"] = this.remark;
        data["currencyCode"] = this.currencyCode;
        return data;
    }
}

export interface IProductImportDto {
    productGroupName: string | undefined;
    catalog: string | undefined;
    itemsCode: string | undefined;
    specification: string | undefined;
    applicableProgram: string | undefined;
    itemsName: string | undefined;
    color: string | undefined;
    partNameSupplier: string | undefined;
    supplierName: string | undefined;
    unitOfMeasure: string | undefined;
    producer: string | undefined;
    origin: string | undefined;
    howToPack: string | undefined;
    availableTime: string | undefined;
    priority: number;
    safetyStockLevel: number;
    minimumQuantity: number;
    factoryUse: string | undefined;
    convertionUnitOfCode: string | undefined;
    material: string | undefined;
    length: number;
    width: number;
    height: number;
    unitLength: string | undefined;
    unitWidth: string | undefined;
    unitHeight: string | undefined;
    weight: number;
    unitWeight: string | undefined;
    inventoryItemId: number | undefined;
    inventoryGroupId: number | undefined;
    creatorUserId: number | undefined;
    productImage: string | undefined;
    byteFileImage: string | undefined;
    remark: string | undefined;
    currencyCode: string | undefined;
}

export class InventoryPriceSearchInputDto implements IInventoryPriceSearchInputDto {
    keyword!: string | undefined;
    inventoryGroupId!: number;
    supplierId!: number;
    page!: number;
    pageSize!: number;

    constructor(data?: IInventoryPriceSearchInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyword = _data["keyword"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.supplierId = _data["supplierId"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): InventoryPriceSearchInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryPriceSearchInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyword"] = this.keyword;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["supplierId"] = this.supplierId;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IInventoryPriceSearchInputDto {
    keyword: string | undefined;
    inventoryGroupId: number;
    supplierId: number;
    page: number;
    pageSize: number;
}

export class InventoryPriceSearchOutputDto implements IInventoryPriceSearchOutputDto {
    id!: number;
    partNo!: string | undefined;
    color!: string | undefined;
    partName!: string | undefined;
    partNameSupplier!: string | undefined;
    supplierName!: string | undefined;
    currencyCode!: string | undefined;
    unitPrice!: number | undefined;
    taxPrice!: number | undefined;
    effectiveFrom!: DateTime | undefined;
    effectiveTo!: DateTime | undefined;
    totalCount!: number;

    constructor(data?: IInventoryPriceSearchOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.partNo = _data["partNo"];
            this.color = _data["color"];
            this.partName = _data["partName"];
            this.partNameSupplier = _data["partNameSupplier"];
            this.supplierName = _data["supplierName"];
            this.currencyCode = _data["currencyCode"];
            this.unitPrice = _data["unitPrice"];
            this.taxPrice = _data["taxPrice"];
            this.effectiveFrom = _data["effectiveFrom"] ? DateTime.fromISO(_data["effectiveFrom"].toString()) : <any>undefined;
            this.effectiveTo = _data["effectiveTo"] ? DateTime.fromISO(_data["effectiveTo"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): InventoryPriceSearchOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryPriceSearchOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["partNo"] = this.partNo;
        data["color"] = this.color;
        data["partName"] = this.partName;
        data["partNameSupplier"] = this.partNameSupplier;
        data["supplierName"] = this.supplierName;
        data["currencyCode"] = this.currencyCode;
        data["unitPrice"] = this.unitPrice;
        data["taxPrice"] = this.taxPrice;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toString() : <any>undefined;
        data["effectiveTo"] = this.effectiveTo ? this.effectiveTo.toString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IInventoryPriceSearchOutputDto {
    id: number;
    partNo: string | undefined;
    color: string | undefined;
    partName: string | undefined;
    partNameSupplier: string | undefined;
    supplierName: string | undefined;
    currencyCode: string | undefined;
    unitPrice: number | undefined;
    taxPrice: number | undefined;
    effectiveFrom: DateTime | undefined;
    effectiveTo: DateTime | undefined;
    totalCount: number;
}

export class PagedResultDtoOfInventoryPriceSearchOutputDto implements IPagedResultDtoOfInventoryPriceSearchOutputDto {
    totalCount!: number;
    items!: InventoryPriceSearchOutputDto[] | undefined;

    constructor(data?: IPagedResultDtoOfInventoryPriceSearchOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InventoryPriceSearchOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfInventoryPriceSearchOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfInventoryPriceSearchOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfInventoryPriceSearchOutputDto {
    totalCount: number;
    items: InventoryPriceSearchOutputDto[] | undefined;
}

export class MstInventoryItemsDto implements IMstInventoryItemsDto {
    id!: number | undefined;
    inventoryItemId!: number | undefined;
    organizationId!: number | undefined;
    primaryUomCode!: string | undefined;
    primaryUnitOfMeasure!: string | undefined;
    itemType!: string | undefined;
    isActive!: number;
    inventoryItemFlag!: number;
    costOfSalesAccount!: string | undefined;
    expenseAccount!: string | undefined;
    salesAccount!: string | undefined;
    partNo!: string | undefined;
    partCode!: string | undefined;
    partNameSupplier!: string | undefined;
    unitPrice!: number | undefined;
    currencyCode!: string | undefined;
    supplierName!: string | undefined;
    taxPrice!: number | undefined;
    color!: string | undefined;
    partName!: string | undefined;
    listPrice!: number | undefined;
    inventoryGroupId!: number | undefined;
    effectiveFrom!: DateTime | undefined;
    effectiveTo!: DateTime | undefined;

    constructor(data?: IMstInventoryItemsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.inventoryItemId = _data["inventoryItemId"];
            this.organizationId = _data["organizationId"];
            this.primaryUomCode = _data["primaryUomCode"];
            this.primaryUnitOfMeasure = _data["primaryUnitOfMeasure"];
            this.itemType = _data["itemType"];
            this.isActive = _data["isActive"];
            this.inventoryItemFlag = _data["inventoryItemFlag"];
            this.costOfSalesAccount = _data["costOfSalesAccount"];
            this.expenseAccount = _data["expenseAccount"];
            this.salesAccount = _data["salesAccount"];
            this.partNo = _data["partNo"];
            this.partCode = _data["partCode"];
            this.partNameSupplier = _data["partNameSupplier"];
            this.unitPrice = _data["unitPrice"];
            this.currencyCode = _data["currencyCode"];
            this.supplierName = _data["supplierName"];
            this.taxPrice = _data["taxPrice"];
            this.color = _data["color"];
            this.partName = _data["partName"];
            this.listPrice = _data["listPrice"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.effectiveFrom = _data["effectiveFrom"] ? DateTime.fromISO(_data["effectiveFrom"].toString()) : <any>undefined;
            this.effectiveTo = _data["effectiveTo"] ? DateTime.fromISO(_data["effectiveTo"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MstInventoryItemsDto {
        data = typeof data === 'object' ? data : {};
        let result = new MstInventoryItemsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["inventoryItemId"] = this.inventoryItemId;
        data["organizationId"] = this.organizationId;
        data["primaryUomCode"] = this.primaryUomCode;
        data["primaryUnitOfMeasure"] = this.primaryUnitOfMeasure;
        data["itemType"] = this.itemType;
        data["isActive"] = this.isActive;
        data["inventoryItemFlag"] = this.inventoryItemFlag;
        data["costOfSalesAccount"] = this.costOfSalesAccount;
        data["expenseAccount"] = this.expenseAccount;
        data["salesAccount"] = this.salesAccount;
        data["partNo"] = this.partNo;
        data["partCode"] = this.partCode;
        data["partNameSupplier"] = this.partNameSupplier;
        data["unitPrice"] = this.unitPrice;
        data["currencyCode"] = this.currencyCode;
        data["supplierName"] = this.supplierName;
        data["taxPrice"] = this.taxPrice;
        data["color"] = this.color;
        data["partName"] = this.partName;
        data["listPrice"] = this.listPrice;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toString() : <any>undefined;
        data["effectiveTo"] = this.effectiveTo ? this.effectiveTo.toString() : <any>undefined;
        return data;
    }
}

export interface IMstInventoryItemsDto {
    id: number | undefined;
    inventoryItemId: number | undefined;
    organizationId: number | undefined;
    primaryUomCode: string | undefined;
    primaryUnitOfMeasure: string | undefined;
    itemType: string | undefined;
    isActive: number;
    inventoryItemFlag: number;
    costOfSalesAccount: string | undefined;
    expenseAccount: string | undefined;
    salesAccount: string | undefined;
    partNo: string | undefined;
    partCode: string | undefined;
    partNameSupplier: string | undefined;
    unitPrice: number | undefined;
    currencyCode: string | undefined;
    supplierName: string | undefined;
    taxPrice: number | undefined;
    color: string | undefined;
    partName: string | undefined;
    listPrice: number | undefined;
    inventoryGroupId: number | undefined;
    effectiveFrom: DateTime | undefined;
    effectiveTo: DateTime | undefined;
}

export class InputInventoryItemsSearchInputDto implements IInputInventoryItemsSearchInputDto {
    inventoryGroupId!: number;
    keyword!: string | undefined;
    page!: number;
    pageSize!: number;

    constructor(data?: IInputInventoryItemsSearchInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.keyword = _data["keyword"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): InputInventoryItemsSearchInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputInventoryItemsSearchInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["keyword"] = this.keyword;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IInputInventoryItemsSearchInputDto {
    inventoryGroupId: number;
    keyword: string | undefined;
    page: number;
    pageSize: number;
}

export class GettemsSubInventoriesDto implements IGettemsSubInventoriesDto {
    subInventory!: string | undefined;
    description!: string | undefined;

    constructor(data?: IGettemsSubInventoriesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subInventory = _data["subInventory"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GettemsSubInventoriesDto {
        data = typeof data === 'object' ? data : {};
        let result = new GettemsSubInventoriesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subInventory"] = this.subInventory;
        data["description"] = this.description;
        return data;
    }
}

export interface IGettemsSubInventoriesDto {
    subInventory: string | undefined;
    description: string | undefined;
}

export class GetMstLineTypeDto implements IGetMstLineTypeDto {
    id!: number;
    lineTypeCode!: string | undefined;
    lineTypeName!: string | undefined;

    constructor(data?: IGetMstLineTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.lineTypeCode = _data["lineTypeCode"];
            this.lineTypeName = _data["lineTypeName"];
        }
    }

    static fromJS(data: any): GetMstLineTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMstLineTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lineTypeCode"] = this.lineTypeCode;
        data["lineTypeName"] = this.lineTypeName;
        return data;
    }
}

export interface IGetMstLineTypeDto {
    id: number;
    lineTypeCode: string | undefined;
    lineTypeName: string | undefined;
}

export class GetAllOutputDto implements IGetAllOutputDto {
    id!: number;
    nationName!: string | undefined;

    constructor(data?: IGetAllOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nationName = _data["nationName"];
        }
    }

    static fromJS(data: any): GetAllOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nationName"] = this.nationName;
        return data;
    }
}

export interface IGetAllOutputDto {
    id: number;
    nationName: string | undefined;
}

export class ListPeriodDto implements IListPeriodDto {
    id!: number;
    periodName!: string | undefined;
    periodYear!: number;
    isCurrent!: boolean;
    fromDate!: DateTime;
    todate!: DateTime;
    description!: string | undefined;

    constructor(data?: IListPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.periodName = _data["periodName"];
            this.periodYear = _data["periodYear"];
            this.isCurrent = _data["isCurrent"];
            this.fromDate = _data["fromDate"] ? DateTime.fromISO(_data["fromDate"].toString()) : <any>undefined;
            this.todate = _data["todate"] ? DateTime.fromISO(_data["todate"].toString()) : <any>undefined;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ListPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["periodName"] = this.periodName;
        data["periodYear"] = this.periodYear;
        data["isCurrent"] = this.isCurrent;
        data["fromDate"] = this.fromDate ? this.fromDate.toString() : <any>undefined;
        data["todate"] = this.todate ? this.todate.toString() : <any>undefined;
        data["description"] = this.description;
        return data;
    }
}

export interface IListPeriodDto {
    id: number;
    periodName: string | undefined;
    periodYear: number;
    isCurrent: boolean;
    fromDate: DateTime;
    todate: DateTime;
    description: string | undefined;
}

export class InputSearchMstPeriodDto implements IInputSearchMstPeriodDto {
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IInputSearchMstPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): InputSearchMstPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputSearchMstPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data;
    }
}

export interface IInputSearchMstPeriodDto {
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class PagedResultDtoOfListPeriodDto implements IPagedResultDtoOfListPeriodDto {
    totalCount!: number;
    items!: ListPeriodDto[] | undefined;

    constructor(data?: IPagedResultDtoOfListPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ListPeriodDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfListPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfListPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfListPeriodDto {
    totalCount: number;
    items: ListPeriodDto[] | undefined;
}

export class MstProductGroupDto implements IMstProductGroupDto {
    id!: number;
    productGroupCode!: string | undefined;
    productGroupName!: string | undefined;
    parentGroupName!: string | undefined;
    parentId!: number | undefined;
    status!: string | undefined;

    constructor(data?: IMstProductGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productGroupCode = _data["productGroupCode"];
            this.productGroupName = _data["productGroupName"];
            this.parentGroupName = _data["parentGroupName"];
            this.parentId = _data["parentId"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): MstProductGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new MstProductGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productGroupCode"] = this.productGroupCode;
        data["productGroupName"] = this.productGroupName;
        data["parentGroupName"] = this.parentGroupName;
        data["parentId"] = this.parentId;
        data["status"] = this.status;
        return data;
    }
}

export interface IMstProductGroupDto {
    id: number;
    productGroupCode: string | undefined;
    productGroupName: string | undefined;
    parentGroupName: string | undefined;
    parentId: number | undefined;
    status: string | undefined;
}

export class PagedResultDtoOfMstProductGroupDto implements IPagedResultDtoOfMstProductGroupDto {
    totalCount!: number;
    items!: MstProductGroupDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMstProductGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MstProductGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMstProductGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMstProductGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMstProductGroupDto {
    totalCount: number;
    items: MstProductGroupDto[] | undefined;
}

export class InputProductGroupDto implements IInputProductGroupDto {
    code!: string | undefined;
    name!: string | undefined;

    constructor(data?: IInputProductGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): InputProductGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputProductGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        return data;
    }
}

export interface IInputProductGroupDto {
    code: string | undefined;
    name: string | undefined;
}

export class MstProjectDto implements IMstProjectDto {
    id!: number;
    projectCode!: string | undefined;
    projectName!: string | undefined;
    numberStage!: number | undefined;
    startDateActive!: DateTime | undefined;
    endDateActive!: DateTime | undefined;
    status!: string | undefined;
    category!: string | undefined;

    constructor(data?: IMstProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectCode = _data["projectCode"];
            this.projectName = _data["projectName"];
            this.numberStage = _data["numberStage"];
            this.startDateActive = _data["startDateActive"] ? DateTime.fromISO(_data["startDateActive"].toString()) : <any>undefined;
            this.endDateActive = _data["endDateActive"] ? DateTime.fromISO(_data["endDateActive"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.category = _data["category"];
        }
    }

    static fromJS(data: any): MstProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new MstProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectCode"] = this.projectCode;
        data["projectName"] = this.projectName;
        data["numberStage"] = this.numberStage;
        data["startDateActive"] = this.startDateActive ? this.startDateActive.toString() : <any>undefined;
        data["endDateActive"] = this.endDateActive ? this.endDateActive.toString() : <any>undefined;
        data["status"] = this.status;
        data["category"] = this.category;
        return data;
    }
}

export interface IMstProjectDto {
    id: number;
    projectCode: string | undefined;
    projectName: string | undefined;
    numberStage: number | undefined;
    startDateActive: DateTime | undefined;
    endDateActive: DateTime | undefined;
    status: string | undefined;
    category: string | undefined;
}

export class PagedResultDtoOfMstProjectDto implements IPagedResultDtoOfMstProjectDto {
    totalCount!: number;
    items!: MstProjectDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMstProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MstProjectDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMstProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMstProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMstProjectDto {
    totalCount: number;
    items: MstProjectDto[] | undefined;
}

export class InputExportProjectDto implements IInputExportProjectDto {
    projectCode!: string | undefined;
    projectName!: string | undefined;

    constructor(data?: IInputExportProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectCode = _data["projectCode"];
            this.projectName = _data["projectName"];
        }
    }

    static fromJS(data: any): InputExportProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputExportProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectCode"] = this.projectCode;
        data["projectName"] = this.projectName;
        return data;
    }
}

export interface IInputExportProjectDto {
    projectCode: string | undefined;
    projectName: string | undefined;
}

export class InputSearchMstProject implements IInputSearchMstProject {
    projectCode!: string | undefined;
    projectName!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IInputSearchMstProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectCode = _data["projectCode"];
            this.projectName = _data["projectName"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): InputSearchMstProject {
        data = typeof data === 'object' ? data : {};
        let result = new InputSearchMstProject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectCode"] = this.projectCode;
        data["projectName"] = this.projectName;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data;
    }
}

export interface IInputSearchMstProject {
    projectCode: string | undefined;
    projectName: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class GetByNationIdOutputDto implements IGetByNationIdOutputDto {
    id!: number;
    provinceName!: string | undefined;
    nationId!: number;

    constructor(data?: IGetByNationIdOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.provinceName = _data["provinceName"];
            this.nationId = _data["nationId"];
        }
    }

    static fromJS(data: any): GetByNationIdOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetByNationIdOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["provinceName"] = this.provinceName;
        data["nationId"] = this.nationId;
        return data;
    }
}

export interface IGetByNationIdOutputDto {
    id: number;
    provinceName: string | undefined;
    nationId: number;
}

export class GetPurchasePurposeDto implements IGetPurchasePurposeDto {
    id!: number;
    purchasePurposeName!: string | undefined;
    purchasePurposeCode!: string | undefined;
    haveBudgetCode!: boolean | undefined;
    status!: string | undefined;

    constructor(data?: IGetPurchasePurposeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.purchasePurposeName = _data["purchasePurposeName"];
            this.purchasePurposeCode = _data["purchasePurposeCode"];
            this.haveBudgetCode = _data["haveBudgetCode"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): GetPurchasePurposeDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPurchasePurposeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["purchasePurposeName"] = this.purchasePurposeName;
        data["purchasePurposeCode"] = this.purchasePurposeCode;
        data["haveBudgetCode"] = this.haveBudgetCode;
        data["status"] = this.status;
        return data;
    }
}

export interface IGetPurchasePurposeDto {
    id: number;
    purchasePurposeName: string | undefined;
    purchasePurposeCode: string | undefined;
    haveBudgetCode: boolean | undefined;
    status: string | undefined;
}

export class PagedResultDtoOfGetPurchasePurposeDto implements IPagedResultDtoOfGetPurchasePurposeDto {
    totalCount!: number;
    items!: GetPurchasePurposeDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPurchasePurposeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetPurchasePurposeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPurchasePurposeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPurchasePurposeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetPurchasePurposeDto {
    totalCount: number;
    items: GetPurchasePurposeDto[] | undefined;
}

export class InputPurchasePurposeDto implements IInputPurchasePurposeDto {
    id!: number;
    purchasePurposeName!: string | undefined;
    purchasePurposeCode!: string | undefined;
    haveBudgetCode!: boolean | undefined;
    status!: number | undefined;

    constructor(data?: IInputPurchasePurposeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.purchasePurposeName = _data["purchasePurposeName"];
            this.purchasePurposeCode = _data["purchasePurposeCode"];
            this.haveBudgetCode = _data["haveBudgetCode"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): InputPurchasePurposeDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputPurchasePurposeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["purchasePurposeName"] = this.purchasePurposeName;
        data["purchasePurposeCode"] = this.purchasePurposeCode;
        data["haveBudgetCode"] = this.haveBudgetCode;
        data["status"] = this.status;
        return data;
    }
}

export interface IInputPurchasePurposeDto {
    id: number;
    purchasePurposeName: string | undefined;
    purchasePurposeCode: string | undefined;
    haveBudgetCode: boolean | undefined;
    status: number | undefined;
}

export class PurchasePurposeImportDto implements IPurchasePurposeImportDto {
    id!: number;
    purchasePurposeName!: string | undefined;
    purchasePurposeCode!: string | undefined;
    haveBudgetCode!: number | undefined;
    status!: number | undefined;
    remark!: string | undefined;

    constructor(data?: IPurchasePurposeImportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.purchasePurposeName = _data["purchasePurposeName"];
            this.purchasePurposeCode = _data["purchasePurposeCode"];
            this.haveBudgetCode = _data["haveBudgetCode"];
            this.status = _data["status"];
            this.remark = _data["remark"];
        }
    }

    static fromJS(data: any): PurchasePurposeImportDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchasePurposeImportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["purchasePurposeName"] = this.purchasePurposeName;
        data["purchasePurposeCode"] = this.purchasePurposeCode;
        data["haveBudgetCode"] = this.haveBudgetCode;
        data["status"] = this.status;
        data["remark"] = this.remark;
        return data;
    }
}

export interface IPurchasePurposeImportDto {
    id: number;
    purchasePurposeName: string | undefined;
    purchasePurposeCode: string | undefined;
    haveBudgetCode: number | undefined;
    status: number | undefined;
    remark: string | undefined;
}

export class MstQuotaExpenseDto implements IMstQuotaExpenseDto {
    id!: number;
    quotaCode!: string | undefined;
    quotaName!: string | undefined;
    quotaType!: number | undefined;
    orgId!: string | undefined;
    titleId!: number | undefined;
    quotaPrice!: number | undefined;
    currencyCode!: number;
    currencyName!: string | undefined;
    startDate!: DateTime | undefined;
    endDate!: DateTime | undefined;
    creationDate!: DateTime | undefined;
    status!: string | undefined;
    quoTypeStr!: string | undefined;
    titleName!: string | undefined;
    orgName!: string | undefined;

    constructor(data?: IMstQuotaExpenseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.quotaCode = _data["quotaCode"];
            this.quotaName = _data["quotaName"];
            this.quotaType = _data["quotaType"];
            this.orgId = _data["orgId"];
            this.titleId = _data["titleId"];
            this.quotaPrice = _data["quotaPrice"];
            this.currencyCode = _data["currencyCode"];
            this.currencyName = _data["currencyName"];
            this.startDate = _data["startDate"] ? DateTime.fromISO(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? DateTime.fromISO(_data["endDate"].toString()) : <any>undefined;
            this.creationDate = _data["creationDate"] ? DateTime.fromISO(_data["creationDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.quoTypeStr = _data["quoTypeStr"];
            this.titleName = _data["titleName"];
            this.orgName = _data["orgName"];
        }
    }

    static fromJS(data: any): MstQuotaExpenseDto {
        data = typeof data === 'object' ? data : {};
        let result = new MstQuotaExpenseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quotaCode"] = this.quotaCode;
        data["quotaName"] = this.quotaName;
        data["quotaType"] = this.quotaType;
        data["orgId"] = this.orgId;
        data["titleId"] = this.titleId;
        data["quotaPrice"] = this.quotaPrice;
        data["currencyCode"] = this.currencyCode;
        data["currencyName"] = this.currencyName;
        data["startDate"] = this.startDate ? this.startDate.toString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toString() : <any>undefined;
        data["creationDate"] = this.creationDate ? this.creationDate.toString() : <any>undefined;
        data["status"] = this.status;
        data["quoTypeStr"] = this.quoTypeStr;
        data["titleName"] = this.titleName;
        data["orgName"] = this.orgName;
        return data;
    }
}

export interface IMstQuotaExpenseDto {
    id: number;
    quotaCode: string | undefined;
    quotaName: string | undefined;
    quotaType: number | undefined;
    orgId: string | undefined;
    titleId: number | undefined;
    quotaPrice: number | undefined;
    currencyCode: number;
    currencyName: string | undefined;
    startDate: DateTime | undefined;
    endDate: DateTime | undefined;
    creationDate: DateTime | undefined;
    status: string | undefined;
    quoTypeStr: string | undefined;
    titleName: string | undefined;
    orgName: string | undefined;
}

export class PagedResultDtoOfMstQuotaExpenseDto implements IPagedResultDtoOfMstQuotaExpenseDto {
    totalCount!: number;
    items!: MstQuotaExpenseDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMstQuotaExpenseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MstQuotaExpenseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMstQuotaExpenseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMstQuotaExpenseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMstQuotaExpenseDto {
    totalCount: number;
    items: MstQuotaExpenseDto[] | undefined;
}

export class InputExportQuotaExpenseDto implements IInputExportQuotaExpenseDto {
    quotaCode!: string | undefined;
    quoType!: number;

    constructor(data?: IInputExportQuotaExpenseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quotaCode = _data["quotaCode"];
            this.quoType = _data["quoType"];
        }
    }

    static fromJS(data: any): InputExportQuotaExpenseDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputExportQuotaExpenseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quotaCode"] = this.quotaCode;
        data["quoType"] = this.quoType;
        return data;
    }
}

export interface IInputExportQuotaExpenseDto {
    quotaCode: string | undefined;
    quoType: number;
}

export class SupplierDropdownDto implements ISupplierDropdownDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: ISupplierDropdownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SupplierDropdownDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierDropdownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ISupplierDropdownDto {
    id: number;
    name: string | undefined;
}

export class SupplierOutputSelectDto implements ISupplierOutputSelectDto {
    id!: number;
    supplierName!: string | undefined;
    supplierNumber!: string | undefined;
    vatRegistrationNum!: string | undefined;
    vatRegistrationInvoice!: string | undefined;
    taxPayerId!: string | undefined;
    registryId!: number | undefined;
    startDateActive!: DateTime | undefined;
    endDateActive!: DateTime | undefined;
    abbreviateName!: string | undefined;

    constructor(data?: ISupplierOutputSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.supplierName = _data["supplierName"];
            this.supplierNumber = _data["supplierNumber"];
            this.vatRegistrationNum = _data["vatRegistrationNum"];
            this.vatRegistrationInvoice = _data["vatRegistrationInvoice"];
            this.taxPayerId = _data["taxPayerId"];
            this.registryId = _data["registryId"];
            this.startDateActive = _data["startDateActive"] ? DateTime.fromISO(_data["startDateActive"].toString()) : <any>undefined;
            this.endDateActive = _data["endDateActive"] ? DateTime.fromISO(_data["endDateActive"].toString()) : <any>undefined;
            this.abbreviateName = _data["abbreviateName"];
        }
    }

    static fromJS(data: any): SupplierOutputSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierOutputSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["supplierName"] = this.supplierName;
        data["supplierNumber"] = this.supplierNumber;
        data["vatRegistrationNum"] = this.vatRegistrationNum;
        data["vatRegistrationInvoice"] = this.vatRegistrationInvoice;
        data["taxPayerId"] = this.taxPayerId;
        data["registryId"] = this.registryId;
        data["startDateActive"] = this.startDateActive ? this.startDateActive.toString() : <any>undefined;
        data["endDateActive"] = this.endDateActive ? this.endDateActive.toString() : <any>undefined;
        data["abbreviateName"] = this.abbreviateName;
        return data;
    }
}

export interface ISupplierOutputSelectDto {
    id: number;
    supplierName: string | undefined;
    supplierNumber: string | undefined;
    vatRegistrationNum: string | undefined;
    vatRegistrationInvoice: string | undefined;
    taxPayerId: string | undefined;
    registryId: number | undefined;
    startDateActive: DateTime | undefined;
    endDateActive: DateTime | undefined;
    abbreviateName: string | undefined;
}

export class PagedResultDtoOfSupplierOutputSelectDto implements IPagedResultDtoOfSupplierOutputSelectDto {
    totalCount!: number;
    items!: SupplierOutputSelectDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSupplierOutputSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SupplierOutputSelectDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSupplierOutputSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSupplierOutputSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfSupplierOutputSelectDto {
    totalCount: number;
    items: SupplierOutputSelectDto[] | undefined;
}

export class SupplierSiteOutputSelectDto implements ISupplierSiteOutputSelectDto {
    id!: number;
    country!: string | undefined;
    supplierId!: number;
    vendorSiteCode!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    legalBusinessName!: string | undefined;
    isSiteDefault!: boolean | undefined;
    bankName!: string | undefined;
    bankAccountName!: string | undefined;
    bankAccountNum!: string | undefined;

    constructor(data?: ISupplierSiteOutputSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.country = _data["country"];
            this.supplierId = _data["supplierId"];
            this.vendorSiteCode = _data["vendorSiteCode"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.legalBusinessName = _data["legalBusinessName"];
            this.isSiteDefault = _data["isSiteDefault"];
            this.bankName = _data["bankName"];
            this.bankAccountName = _data["bankAccountName"];
            this.bankAccountNum = _data["bankAccountNum"];
        }
    }

    static fromJS(data: any): SupplierSiteOutputSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierSiteOutputSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["country"] = this.country;
        data["supplierId"] = this.supplierId;
        data["vendorSiteCode"] = this.vendorSiteCode;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["legalBusinessName"] = this.legalBusinessName;
        data["isSiteDefault"] = this.isSiteDefault;
        data["bankName"] = this.bankName;
        data["bankAccountName"] = this.bankAccountName;
        data["bankAccountNum"] = this.bankAccountNum;
        return data;
    }
}

export interface ISupplierSiteOutputSelectDto {
    id: number;
    country: string | undefined;
    supplierId: number;
    vendorSiteCode: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    legalBusinessName: string | undefined;
    isSiteDefault: boolean | undefined;
    bankName: string | undefined;
    bankAccountName: string | undefined;
    bankAccountNum: string | undefined;
}

export class PagedResultDtoOfSupplierSiteOutputSelectDto implements IPagedResultDtoOfSupplierSiteOutputSelectDto {
    totalCount!: number;
    items!: SupplierSiteOutputSelectDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSupplierSiteOutputSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SupplierSiteOutputSelectDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSupplierSiteOutputSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSupplierSiteOutputSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfSupplierSiteOutputSelectDto {
    totalCount: number;
    items: SupplierSiteOutputSelectDto[] | undefined;
}

export class SupplierContacOutputSelectDto implements ISupplierContacOutputSelectDto {
    id!: number;
    supplierSiteId!: number | undefined;
    fullName!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;
    prefix!: string | undefined;
    title!: string | undefined;
    areaCode!: string | undefined;
    phone!: string | undefined;
    inactiveDate!: DateTime | undefined;
    isActive!: boolean | undefined;
    emailAddress!: string | undefined;

    constructor(data?: ISupplierContacOutputSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.supplierSiteId = _data["supplierSiteId"];
            this.fullName = _data["fullName"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.prefix = _data["prefix"];
            this.title = _data["title"];
            this.areaCode = _data["areaCode"];
            this.phone = _data["phone"];
            this.inactiveDate = _data["inactiveDate"] ? DateTime.fromISO(_data["inactiveDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): SupplierContacOutputSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierContacOutputSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["supplierSiteId"] = this.supplierSiteId;
        data["fullName"] = this.fullName;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["prefix"] = this.prefix;
        data["title"] = this.title;
        data["areaCode"] = this.areaCode;
        data["phone"] = this.phone;
        data["inactiveDate"] = this.inactiveDate ? this.inactiveDate.toString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface ISupplierContacOutputSelectDto {
    id: number;
    supplierSiteId: number | undefined;
    fullName: string | undefined;
    userName: string | undefined;
    password: string | undefined;
    prefix: string | undefined;
    title: string | undefined;
    areaCode: string | undefined;
    phone: string | undefined;
    inactiveDate: DateTime | undefined;
    isActive: boolean | undefined;
    emailAddress: string | undefined;
}

export class PagedResultDtoOfSupplierContacOutputSelectDto implements IPagedResultDtoOfSupplierContacOutputSelectDto {
    totalCount!: number;
    items!: SupplierContacOutputSelectDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSupplierContacOutputSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SupplierContacOutputSelectDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSupplierContacOutputSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSupplierContacOutputSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfSupplierContacOutputSelectDto {
    totalCount: number;
    items: SupplierContacOutputSelectDto[] | undefined;
}

export class SupplierContactSaveDto implements ISupplierContactSaveDto {
    id!: number;
    supplierSiteId!: number;
    supplierName!: string | undefined;
    supplierNumber!: string | undefined;
    siteAddress!: string | undefined;
    fullName!: string | undefined;
    firstName!: string | undefined;
    midName!: string | undefined;
    lastName!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;
    rePassword!: string | undefined;
    phone!: string | undefined;
    emailAddress!: string | undefined;
    supplierId!: number | undefined;

    constructor(data?: ISupplierContactSaveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.supplierSiteId = _data["supplierSiteId"];
            this.supplierName = _data["supplierName"];
            this.supplierNumber = _data["supplierNumber"];
            this.siteAddress = _data["siteAddress"];
            this.fullName = _data["fullName"];
            this.firstName = _data["firstName"];
            this.midName = _data["midName"];
            this.lastName = _data["lastName"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.rePassword = _data["rePassword"];
            this.phone = _data["phone"];
            this.emailAddress = _data["emailAddress"];
            this.supplierId = _data["supplierId"];
        }
    }

    static fromJS(data: any): SupplierContactSaveDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierContactSaveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["supplierSiteId"] = this.supplierSiteId;
        data["supplierName"] = this.supplierName;
        data["supplierNumber"] = this.supplierNumber;
        data["siteAddress"] = this.siteAddress;
        data["fullName"] = this.fullName;
        data["firstName"] = this.firstName;
        data["midName"] = this.midName;
        data["lastName"] = this.lastName;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["rePassword"] = this.rePassword;
        data["phone"] = this.phone;
        data["emailAddress"] = this.emailAddress;
        data["supplierId"] = this.supplierId;
        return data;
    }
}

export interface ISupplierContactSaveDto {
    id: number;
    supplierSiteId: number;
    supplierName: string | undefined;
    supplierNumber: string | undefined;
    siteAddress: string | undefined;
    fullName: string | undefined;
    firstName: string | undefined;
    midName: string | undefined;
    lastName: string | undefined;
    userName: string | undefined;
    password: string | undefined;
    rePassword: string | undefined;
    phone: string | undefined;
    emailAddress: string | undefined;
    supplierId: number | undefined;
}

export class SupplierSaveDto implements ISupplierSaveDto {
    id!: number;
    supplierName!: string | undefined;
    supplierNumber!: string | undefined;
    vatRegistrationNum!: string | undefined;
    vatRegistrationInvoice!: string | undefined;
    taxPayerId!: string | undefined;
    startDateActive!: DateTime | undefined;
    endDateActive!: DateTime | undefined;
    abbreviateName!: string | undefined;

    constructor(data?: ISupplierSaveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.supplierName = _data["supplierName"];
            this.supplierNumber = _data["supplierNumber"];
            this.vatRegistrationNum = _data["vatRegistrationNum"];
            this.vatRegistrationInvoice = _data["vatRegistrationInvoice"];
            this.taxPayerId = _data["taxPayerId"];
            this.startDateActive = _data["startDateActive"] ? DateTime.fromISO(_data["startDateActive"].toString()) : <any>undefined;
            this.endDateActive = _data["endDateActive"] ? DateTime.fromISO(_data["endDateActive"].toString()) : <any>undefined;
            this.abbreviateName = _data["abbreviateName"];
        }
    }

    static fromJS(data: any): SupplierSaveDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierSaveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["supplierName"] = this.supplierName;
        data["supplierNumber"] = this.supplierNumber;
        data["vatRegistrationNum"] = this.vatRegistrationNum;
        data["vatRegistrationInvoice"] = this.vatRegistrationInvoice;
        data["taxPayerId"] = this.taxPayerId;
        data["startDateActive"] = this.startDateActive ? this.startDateActive.toString() : <any>undefined;
        data["endDateActive"] = this.endDateActive ? this.endDateActive.toString() : <any>undefined;
        data["abbreviateName"] = this.abbreviateName;
        return data;
    }
}

export interface ISupplierSaveDto {
    id: number;
    supplierName: string | undefined;
    supplierNumber: string | undefined;
    vatRegistrationNum: string | undefined;
    vatRegistrationInvoice: string | undefined;
    taxPayerId: string | undefined;
    startDateActive: DateTime | undefined;
    endDateActive: DateTime | undefined;
    abbreviateName: string | undefined;
}

export class ValSupplierSaveDto implements IValSupplierSaveDto {
    name!: string | undefined;
    code!: string | undefined;

    constructor(data?: IValSupplierSaveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): ValSupplierSaveDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValSupplierSaveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IValSupplierSaveDto {
    name: string | undefined;
    code: string | undefined;
}

export class SupplierSiteSaveDto implements ISupplierSiteSaveDto {
    id!: number;
    country!: string | undefined;
    supplierId!: number;
    addressLine1!: string | undefined;
    legalBusinessName!: string | undefined;
    isSiteDefault!: boolean | undefined;

    constructor(data?: ISupplierSiteSaveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.country = _data["country"];
            this.supplierId = _data["supplierId"];
            this.addressLine1 = _data["addressLine1"];
            this.legalBusinessName = _data["legalBusinessName"];
            this.isSiteDefault = _data["isSiteDefault"];
        }
    }

    static fromJS(data: any): SupplierSiteSaveDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierSiteSaveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["country"] = this.country;
        data["supplierId"] = this.supplierId;
        data["addressLine1"] = this.addressLine1;
        data["legalBusinessName"] = this.legalBusinessName;
        data["isSiteDefault"] = this.isSiteDefault;
        return data;
    }
}

export interface ISupplierSiteSaveDto {
    id: number;
    country: string | undefined;
    supplierId: number;
    addressLine1: string | undefined;
    legalBusinessName: string | undefined;
    isSiteDefault: boolean | undefined;
}

export class SupplierRequestInfoDto implements ISupplierRequestInfoDto {
    supplierName!: string | undefined;
    taxRegistrationNumber!: string | undefined;
    address!: string | undefined;
    tel!: string | undefined;
    tax!: string | undefined;
    conntactPerson1!: string | undefined;
    contactEmail1!: string | undefined;
    contactMobile1!: string | undefined;
    conntactPerson2!: string | undefined;
    contactEmail2!: string | undefined;
    contactMobile2!: string | undefined;
    conntactPerson3!: string | undefined;
    contactEmail3!: string | undefined;
    contactMobile3!: string | undefined;
    classificationType!: string | undefined;
    beneficiaryName!: string | undefined;
    beneficiaryAccount!: string | undefined;
    bankCode!: string | undefined;
    bankName!: string | undefined;
    bankBranch!: string | undefined;
    bankAddress!: string | undefined;
    requestPerson!: string | undefined;
    requestEmail!: string | undefined;
    location!: string | undefined;
    transferStatus!: string | undefined;
    requestUniqueId!: string;
    requestExpiredDate!: DateTime | undefined;
    nationId!: number | undefined;
    provinceId!: number | undefined;
    districtId!: number | undefined;
    currencyId!: number | undefined;
    abbreviateName!: string | undefined;
    representName!: string | undefined;
    createAccount!: boolean;
    supContactId!: number;
    contactSurName!: string | undefined;
    approvalStatus!: string | undefined;
    requestNo!: string | undefined;
    departmentApprovalName!: string | undefined;
    picNote!: string | undefined;
    requestBaseUrl!: string | undefined;
    isExpired!: boolean;
    errMess!: string | undefined;
    isUpdateRequestOnly!: boolean;
    id!: number | undefined;

    constructor(data?: ISupplierRequestInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supplierName = _data["supplierName"];
            this.taxRegistrationNumber = _data["taxRegistrationNumber"];
            this.address = _data["address"];
            this.tel = _data["tel"];
            this.tax = _data["tax"];
            this.conntactPerson1 = _data["conntactPerson1"];
            this.contactEmail1 = _data["contactEmail1"];
            this.contactMobile1 = _data["contactMobile1"];
            this.conntactPerson2 = _data["conntactPerson2"];
            this.contactEmail2 = _data["contactEmail2"];
            this.contactMobile2 = _data["contactMobile2"];
            this.conntactPerson3 = _data["conntactPerson3"];
            this.contactEmail3 = _data["contactEmail3"];
            this.contactMobile3 = _data["contactMobile3"];
            this.classificationType = _data["classificationType"];
            this.beneficiaryName = _data["beneficiaryName"];
            this.beneficiaryAccount = _data["beneficiaryAccount"];
            this.bankCode = _data["bankCode"];
            this.bankName = _data["bankName"];
            this.bankBranch = _data["bankBranch"];
            this.bankAddress = _data["bankAddress"];
            this.requestPerson = _data["requestPerson"];
            this.requestEmail = _data["requestEmail"];
            this.location = _data["location"];
            this.transferStatus = _data["transferStatus"];
            this.requestUniqueId = _data["requestUniqueId"];
            this.requestExpiredDate = _data["requestExpiredDate"] ? DateTime.fromISO(_data["requestExpiredDate"].toString()) : <any>undefined;
            this.nationId = _data["nationId"];
            this.provinceId = _data["provinceId"];
            this.districtId = _data["districtId"];
            this.currencyId = _data["currencyId"];
            this.abbreviateName = _data["abbreviateName"];
            this.representName = _data["representName"];
            this.createAccount = _data["createAccount"];
            this.supContactId = _data["supContactId"];
            this.contactSurName = _data["contactSurName"];
            this.approvalStatus = _data["approvalStatus"];
            this.requestNo = _data["requestNo"];
            this.departmentApprovalName = _data["departmentApprovalName"];
            this.picNote = _data["picNote"];
            this.requestBaseUrl = _data["requestBaseUrl"];
            this.isExpired = _data["isExpired"];
            this.errMess = _data["errMess"];
            this.isUpdateRequestOnly = _data["isUpdateRequestOnly"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SupplierRequestInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierRequestInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supplierName"] = this.supplierName;
        data["taxRegistrationNumber"] = this.taxRegistrationNumber;
        data["address"] = this.address;
        data["tel"] = this.tel;
        data["tax"] = this.tax;
        data["conntactPerson1"] = this.conntactPerson1;
        data["contactEmail1"] = this.contactEmail1;
        data["contactMobile1"] = this.contactMobile1;
        data["conntactPerson2"] = this.conntactPerson2;
        data["contactEmail2"] = this.contactEmail2;
        data["contactMobile2"] = this.contactMobile2;
        data["conntactPerson3"] = this.conntactPerson3;
        data["contactEmail3"] = this.contactEmail3;
        data["contactMobile3"] = this.contactMobile3;
        data["classificationType"] = this.classificationType;
        data["beneficiaryName"] = this.beneficiaryName;
        data["beneficiaryAccount"] = this.beneficiaryAccount;
        data["bankCode"] = this.bankCode;
        data["bankName"] = this.bankName;
        data["bankBranch"] = this.bankBranch;
        data["bankAddress"] = this.bankAddress;
        data["requestPerson"] = this.requestPerson;
        data["requestEmail"] = this.requestEmail;
        data["location"] = this.location;
        data["transferStatus"] = this.transferStatus;
        data["requestUniqueId"] = this.requestUniqueId;
        data["requestExpiredDate"] = this.requestExpiredDate ? this.requestExpiredDate.toString() : <any>undefined;
        data["nationId"] = this.nationId;
        data["provinceId"] = this.provinceId;
        data["districtId"] = this.districtId;
        data["currencyId"] = this.currencyId;
        data["abbreviateName"] = this.abbreviateName;
        data["representName"] = this.representName;
        data["createAccount"] = this.createAccount;
        data["supContactId"] = this.supContactId;
        data["contactSurName"] = this.contactSurName;
        data["approvalStatus"] = this.approvalStatus;
        data["requestNo"] = this.requestNo;
        data["departmentApprovalName"] = this.departmentApprovalName;
        data["picNote"] = this.picNote;
        data["requestBaseUrl"] = this.requestBaseUrl;
        data["isExpired"] = this.isExpired;
        data["errMess"] = this.errMess;
        data["isUpdateRequestOnly"] = this.isUpdateRequestOnly;
        data["id"] = this.id;
        return data;
    }
}

export interface ISupplierRequestInfoDto {
    supplierName: string | undefined;
    taxRegistrationNumber: string | undefined;
    address: string | undefined;
    tel: string | undefined;
    tax: string | undefined;
    conntactPerson1: string | undefined;
    contactEmail1: string | undefined;
    contactMobile1: string | undefined;
    conntactPerson2: string | undefined;
    contactEmail2: string | undefined;
    contactMobile2: string | undefined;
    conntactPerson3: string | undefined;
    contactEmail3: string | undefined;
    contactMobile3: string | undefined;
    classificationType: string | undefined;
    beneficiaryName: string | undefined;
    beneficiaryAccount: string | undefined;
    bankCode: string | undefined;
    bankName: string | undefined;
    bankBranch: string | undefined;
    bankAddress: string | undefined;
    requestPerson: string | undefined;
    requestEmail: string | undefined;
    location: string | undefined;
    transferStatus: string | undefined;
    requestUniqueId: string;
    requestExpiredDate: DateTime | undefined;
    nationId: number | undefined;
    provinceId: number | undefined;
    districtId: number | undefined;
    currencyId: number | undefined;
    abbreviateName: string | undefined;
    representName: string | undefined;
    createAccount: boolean;
    supContactId: number;
    contactSurName: string | undefined;
    approvalStatus: string | undefined;
    requestNo: string | undefined;
    departmentApprovalName: string | undefined;
    picNote: string | undefined;
    requestBaseUrl: string | undefined;
    isExpired: boolean;
    errMess: string | undefined;
    isUpdateRequestOnly: boolean;
    id: number | undefined;
}

export class PagedResultDtoOfSupplierRequestInfoDto implements IPagedResultDtoOfSupplierRequestInfoDto {
    totalCount!: number;
    items!: SupplierRequestInfoDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSupplierRequestInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SupplierRequestInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSupplierRequestInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSupplierRequestInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfSupplierRequestInfoDto {
    totalCount: number;
    items: SupplierRequestInfoDto[] | undefined;
}

export class UnitOfMeasureDto implements IUnitOfMeasureDto {
    id!: number;
    unitOfMeasure!: string | undefined;
    uomCode!: string | undefined;
    uomClass!: string | undefined;
    description!: string | undefined;
    status!: string | undefined;

    constructor(data?: IUnitOfMeasureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.uomCode = _data["uomCode"];
            this.uomClass = _data["uomClass"];
            this.description = _data["description"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UnitOfMeasureDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnitOfMeasureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["uomCode"] = this.uomCode;
        data["uomClass"] = this.uomClass;
        data["description"] = this.description;
        data["status"] = this.status;
        return data;
    }
}

export interface IUnitOfMeasureDto {
    id: number;
    unitOfMeasure: string | undefined;
    uomCode: string | undefined;
    uomClass: string | undefined;
    description: string | undefined;
    status: string | undefined;
}

export class PagedResultDtoOfUnitOfMeasureDto implements IPagedResultDtoOfUnitOfMeasureDto {
    totalCount!: number;
    items!: UnitOfMeasureDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUnitOfMeasureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UnitOfMeasureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUnitOfMeasureDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUnitOfMeasureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfUnitOfMeasureDto {
    totalCount: number;
    items: UnitOfMeasureDto[] | undefined;
}

export class InputUOMExportDto implements IInputUOMExportDto {
    unitOfMeasure!: string | undefined;
    uomCode!: string | undefined;
    uomClass!: string | undefined;

    constructor(data?: IInputUOMExportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.uomCode = _data["uomCode"];
            this.uomClass = _data["uomClass"];
        }
    }

    static fromJS(data: any): InputUOMExportDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputUOMExportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["uomCode"] = this.uomCode;
        data["uomClass"] = this.uomClass;
        return data;
    }
}

export interface IInputUOMExportDto {
    unitOfMeasure: string | undefined;
    uomCode: string | undefined;
    uomClass: string | undefined;
}

export enum UserNotificationState {
    Unread = 0,
    Read = 1,
}

export class NotificationData implements INotificationData {
    readonly type!: string | undefined;
    properties!: { [key: string]: any; } | undefined;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).type = _data["type"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        return data;
    }
}

export interface INotificationData {
    type: string | undefined;
    properties: { [key: string]: any; } | undefined;
}

export enum NotificationSeverity {
    Info = 0,
    Success = 1,
    Warn = 2,
    Error = 3,
    Fatal = 4,
}

export class TenantNotification implements ITenantNotification {
    tenantId!: number | undefined;
    notificationName!: string | undefined;
    data!: NotificationData;
    entityType!: string | undefined;
    entityTypeName!: string | undefined;
    entityId!: any | undefined;
    severity!: NotificationSeverity;
    creationTime!: DateTime;
    id!: string;

    constructor(data?: ITenantNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.notificationName = _data["notificationName"];
            this.data = _data["data"] ? NotificationData.fromJS(_data["data"]) : <any>undefined;
            this.entityType = _data["entityType"];
            this.entityTypeName = _data["entityTypeName"];
            this.entityId = _data["entityId"];
            this.severity = _data["severity"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantNotification {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["entityTypeName"] = this.entityTypeName;
        data["entityId"] = this.entityId;
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: any | undefined;
    severity: NotificationSeverity;
    creationTime: DateTime;
    id: string;
}

export class UserNotification implements IUserNotification {
    tenantId!: number | undefined;
    userId!: number;
    state!: UserNotificationState;
    notification!: TenantNotification;
    id!: string;

    constructor(data?: IUserNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.state = _data["state"];
            this.notification = _data["notification"] ? TenantNotification.fromJS(_data["notification"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserNotification {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserNotification {
    tenantId: number | undefined;
    userId: number;
    state: UserNotificationState;
    notification: TenantNotification;
    id: string;
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    unreadCount!: number;
    totalCount!: number;
    items!: UserNotification[] | undefined;

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unreadCount = _data["unreadCount"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unreadCount"] = this.unreadCount;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetNotificationsOutput {
    unreadCount: number;
    totalCount: number;
    items: UserNotification[] | undefined;
}

export class EntityDtoOfGuid implements IEntityDtoOfGuid {
    id!: string;

    constructor(data?: IEntityDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityDtoOfGuid {
    id: string;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    displayName!: string | undefined;
    description!: string | undefined;
    name!: string;
    isSubscribed!: boolean;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.isSubscribed = _data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data;
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string;
    isSubscribed: boolean;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications!: boolean;
    notifications!: NotificationSubscriptionWithDisplayNameDto[] | undefined;

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.receiveNotifications = _data["receiveNotifications"];
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name!: string;
    isSubscribed!: boolean;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isSubscribed = _data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data;
    }
}

export interface INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications!: boolean;
    notifications!: NotificationSubscriptionDto[] | undefined;

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.receiveNotifications = _data["receiveNotifications"];
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionDto[] | undefined;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    parentId!: number | undefined;
    code!: string | undefined;
    displayName!: string | undefined;
    memberCount!: number;
    roleCount!: number;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.displayName = _data["displayName"];
            this.memberCount = _data["memberCount"];
            this.roleCount = _data["roleCount"];
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["roleCount"] = this.roleCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationUnitDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number;
    roleCount: number;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class ListResultDtoOfOrganizationUnitDto implements IListResultDtoOfOrganizationUnitDto {
    items!: OrganizationUnitDto[] | undefined;

    constructor(data?: IListResultDtoOfOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfOrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfOrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfOrganizationUnitDto {
    items: OrganizationUnitDto[] | undefined;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    addedTime!: DateTime;
    id!: number;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.profilePictureId = _data["profilePictureId"];
            this.addedTime = _data["addedTime"] ? DateTime.fromISO(_data["addedTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationUnitUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: DateTime;
    id: number;
}

export class PagedResultDtoOfOrganizationUnitUserListDto implements IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount!: number;
    items!: OrganizationUnitUserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number;
    items: OrganizationUnitUserListDto[] | undefined;
}

export class OrganizationUnitRoleListDto implements IOrganizationUnitRoleListDto {
    displayName!: string | undefined;
    name!: string | undefined;
    addedTime!: DateTime;
    id!: number;

    constructor(data?: IOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.name = _data["name"];
            this.addedTime = _data["addedTime"] ? DateTime.fromISO(_data["addedTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["name"] = this.name;
        data["addedTime"] = this.addedTime ? this.addedTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationUnitRoleListDto {
    displayName: string | undefined;
    name: string | undefined;
    addedTime: DateTime;
    id: number;
}

export class PagedResultDtoOfOrganizationUnitRoleListDto implements IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount!: number;
    items!: OrganizationUnitRoleListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitRoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount: number;
    items: OrganizationUnitRoleListDto[] | undefined;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId!: number | undefined;
    displayName!: string;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id!: number;
    displayName!: string;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number;
    displayName: string;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id!: number;
    newParentId!: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.newParentId = _data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data;
    }
}

export interface IMoveOrganizationUnitInput {
    id: number;
    newParentId: number | undefined;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds!: number[] | undefined;
    organizationUnitId!: number;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number;
}

export class RolesToOrganizationUnitInput implements IRolesToOrganizationUnitInput {
    roleIds!: number[] | undefined;
    organizationUnitId!: number;

    constructor(data?: IRolesToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roleIds"])) {
                this.roleIds = [] as any;
                for (let item of _data["roleIds"])
                    this.roleIds!.push(item);
            }
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): RolesToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new RolesToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roleIds)) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }
}

export interface IRolesToOrganizationUnitInput {
    roleIds: number[] | undefined;
    organizationUnitId: number;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    organizationUnitId!: number;
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitId = _data["organizationUnitId"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IFindOrganizationUnitUsersInput {
    organizationUnitId: number;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
}

export class FindOrganizationUnitRolesInput implements IFindOrganizationUnitRolesInput {
    organizationUnitId!: number;
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitId = _data["organizationUnitId"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IFindOrganizationUnitRolesInput {
    organizationUnitId: number;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
}

export class EditionSelectDto implements IEditionSelectDto {
    id!: number;
    name!: string | undefined;
    displayName!: string | undefined;
    expiringEditionId!: number | undefined;
    dailyPrice!: number | undefined;
    weeklyPrice!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    isFree!: boolean;
    additionalData!: AdditionalData | undefined;

    constructor(data?: IEditionSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.expiringEditionId = _data["expiringEditionId"];
            this.dailyPrice = _data["dailyPrice"];
            this.weeklyPrice = _data["weeklyPrice"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.trialDayCount = _data["trialDayCount"];
            this.waitingDayAfterExpire = _data["waitingDayAfterExpire"];
            this.isFree = _data["isFree"];
            this.additionalData = _data["additionalData"] ? AdditionalData.fromJS(_data["additionalData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EditionSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["isFree"] = this.isFree;
        data["additionalData"] = this.additionalData ? this.additionalData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEditionSelectDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    expiringEditionId: number | undefined;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    isFree: boolean;
    additionalData: AdditionalData | undefined;
}

export class PaymentInfoDto implements IPaymentInfoDto {
    edition!: EditionSelectDto;
    additionalPrice!: number;

    constructor(data?: IPaymentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionSelectDto.fromJS(_data["edition"]) : <any>undefined;
            this.additionalPrice = _data["additionalPrice"];
        }
    }

    static fromJS(data: any): PaymentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["additionalPrice"] = this.additionalPrice;
        return data;
    }
}

export interface IPaymentInfoDto {
    edition: EditionSelectDto;
    additionalPrice: number;
}

export enum EditionPaymentType {
    NewRegistration = 0,
    BuyNow = 1,
    Upgrade = 2,
    Extend = 3,
}

export enum PaymentPeriodType {
    Daily = 1,
    Weekly = 7,
    Monthly = 30,
    Annual = 365,
}

export enum SubscriptionPaymentGatewayType {
    Paypal = 1,
    Stripe = 2,
}

export class CreatePaymentDto implements ICreatePaymentDto {
    editionId!: number;
    editionPaymentType!: EditionPaymentType;
    paymentPeriodType!: PaymentPeriodType;
    subscriptionPaymentGatewayType!: SubscriptionPaymentGatewayType;
    recurringPaymentEnabled!: boolean;
    successUrl!: string | undefined;
    errorUrl!: string | undefined;

    constructor(data?: ICreatePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.editionId = _data["editionId"];
            this.editionPaymentType = _data["editionPaymentType"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.subscriptionPaymentGatewayType = _data["subscriptionPaymentGatewayType"];
            this.recurringPaymentEnabled = _data["recurringPaymentEnabled"];
            this.successUrl = _data["successUrl"];
            this.errorUrl = _data["errorUrl"];
        }
    }

    static fromJS(data: any): CreatePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editionId"] = this.editionId;
        data["editionPaymentType"] = this.editionPaymentType;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionPaymentGatewayType"] = this.subscriptionPaymentGatewayType;
        data["recurringPaymentEnabled"] = this.recurringPaymentEnabled;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        return data;
    }
}

export interface ICreatePaymentDto {
    editionId: number;
    editionPaymentType: EditionPaymentType;
    paymentPeriodType: PaymentPeriodType;
    subscriptionPaymentGatewayType: SubscriptionPaymentGatewayType;
    recurringPaymentEnabled: boolean;
    successUrl: string | undefined;
    errorUrl: string | undefined;
}

export class CancelPaymentDto implements ICancelPaymentDto {
    paymentId!: string | undefined;
    gateway!: SubscriptionPaymentGatewayType;

    constructor(data?: ICancelPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentId = _data["paymentId"];
            this.gateway = _data["gateway"];
        }
    }

    static fromJS(data: any): CancelPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CancelPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["gateway"] = this.gateway;
        return data;
    }
}

export interface ICancelPaymentDto {
    paymentId: string | undefined;
    gateway: SubscriptionPaymentGatewayType;
}

export class SubscriptionPaymentListDto implements ISubscriptionPaymentListDto {
    gateway!: string | undefined;
    amount!: number;
    editionId!: number;
    dayCount!: number;
    paymentPeriodType!: string | undefined;
    externalPaymentId!: string | undefined;
    payerId!: string | undefined;
    status!: string | undefined;
    editionDisplayName!: string | undefined;
    tenantId!: number;
    invoiceNo!: string | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ISubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gateway = _data["gateway"];
            this.amount = _data["amount"];
            this.editionId = _data["editionId"];
            this.dayCount = _data["dayCount"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.externalPaymentId = _data["externalPaymentId"];
            this.payerId = _data["payerId"];
            this.status = _data["status"];
            this.editionDisplayName = _data["editionDisplayName"];
            this.tenantId = _data["tenantId"];
            this.invoiceNo = _data["invoiceNo"];
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["externalPaymentId"] = this.externalPaymentId;
        data["payerId"] = this.payerId;
        data["status"] = this.status;
        data["editionDisplayName"] = this.editionDisplayName;
        data["tenantId"] = this.tenantId;
        data["invoiceNo"] = this.invoiceNo;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISubscriptionPaymentListDto {
    gateway: string | undefined;
    amount: number;
    editionId: number;
    dayCount: number;
    paymentPeriodType: string | undefined;
    externalPaymentId: string | undefined;
    payerId: string | undefined;
    status: string | undefined;
    editionDisplayName: string | undefined;
    tenantId: number;
    invoiceNo: string | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class PagedResultDtoOfSubscriptionPaymentListDto implements IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount!: number;
    items!: SubscriptionPaymentListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SubscriptionPaymentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount: number;
    items: SubscriptionPaymentListDto[] | undefined;
}

export class PaymentGatewayModel implements IPaymentGatewayModel {
    gatewayType!: SubscriptionPaymentGatewayType;
    supportsRecurringPayments!: boolean;

    constructor(data?: IPaymentGatewayModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gatewayType = _data["gatewayType"];
            this.supportsRecurringPayments = _data["supportsRecurringPayments"];
        }
    }

    static fromJS(data: any): PaymentGatewayModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentGatewayModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayType"] = this.gatewayType;
        data["supportsRecurringPayments"] = this.supportsRecurringPayments;
        return data;
    }
}

export interface IPaymentGatewayModel {
    gatewayType: SubscriptionPaymentGatewayType;
    supportsRecurringPayments: boolean;
}

export enum SubscriptionPaymentStatus {
    NotPaid = 1,
    Paid = 2,
    Failed = 3,
    Cancelled = 4,
    Completed = 5,
}

export class SubscriptionPaymentDto implements ISubscriptionPaymentDto {
    description!: string | undefined;
    gateway!: SubscriptionPaymentGatewayType;
    amount!: number;
    editionId!: number;
    tenantId!: number;
    dayCount!: number;
    paymentPeriodType!: PaymentPeriodType;
    paymentId!: string | undefined;
    payerId!: string | undefined;
    editionDisplayName!: string | undefined;
    invoiceNo!: number;
    status!: SubscriptionPaymentStatus;
    isRecurring!: boolean;
    externalPaymentId!: string | undefined;
    successUrl!: string | undefined;
    errorUrl!: string | undefined;
    editionPaymentType!: EditionPaymentType;
    id!: number;

    constructor(data?: ISubscriptionPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.gateway = _data["gateway"];
            this.amount = _data["amount"];
            this.editionId = _data["editionId"];
            this.tenantId = _data["tenantId"];
            this.dayCount = _data["dayCount"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.paymentId = _data["paymentId"];
            this.payerId = _data["payerId"];
            this.editionDisplayName = _data["editionDisplayName"];
            this.invoiceNo = _data["invoiceNo"];
            this.status = _data["status"];
            this.isRecurring = _data["isRecurring"];
            this.externalPaymentId = _data["externalPaymentId"];
            this.successUrl = _data["successUrl"];
            this.errorUrl = _data["errorUrl"];
            this.editionPaymentType = _data["editionPaymentType"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["tenantId"] = this.tenantId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["status"] = this.status;
        data["isRecurring"] = this.isRecurring;
        data["externalPaymentId"] = this.externalPaymentId;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        data["editionPaymentType"] = this.editionPaymentType;
        data["id"] = this.id;
        return data;
    }
}

export interface ISubscriptionPaymentDto {
    description: string | undefined;
    gateway: SubscriptionPaymentGatewayType;
    amount: number;
    editionId: number;
    tenantId: number;
    dayCount: number;
    paymentPeriodType: PaymentPeriodType;
    paymentId: string | undefined;
    payerId: string | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: number;
    status: SubscriptionPaymentStatus;
    isRecurring: boolean;
    externalPaymentId: string | undefined;
    successUrl: string | undefined;
    errorUrl: string | undefined;
    editionPaymentType: EditionPaymentType;
    id: number;
}

export class PaymentFromSuppliersDto implements IPaymentFromSuppliersDto {
    id!: number;
    paymentNo!: string | undefined;
    requestDate!: DateTime;
    requestDuedate!: DateTime;
    description!: string | undefined;
    employeeId!: number | undefined;
    vendorId!: number | undefined;
    vendorSiteId!: number | undefined;
    currencyCode!: string | undefined;
    totalAmount!: number | undefined;
    totalCount!: number;
    employeeName!: string | undefined;
    supplierName!: string | undefined;
    vendorSiteCode!: string | undefined;
    authorizationStatus!: string | undefined;
    status!: number;
    paymentMethod!: string | undefined;
    bankAccountName!: string | undefined;
    bankAccountNumber!: string | undefined;
    bankName!: string | undefined;
    bankBranchName!: string | undefined;
    invoiceNumber!: string | undefined;
    invoiceAmount!: number | undefined;
    invoiceDate!: DateTime | undefined;
    prepaymentAmount!: number | undefined;
    poNo!: string | undefined;
    invoiceId!: number | undefined;
    poHeaderId!: number | undefined;
    totalPrice!: number | undefined;
    totalPriceUsd!: number | undefined;
    sourcePayment!: number;
    availableAmount!: number | undefined;

    constructor(data?: IPaymentFromSuppliersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paymentNo = _data["paymentNo"];
            this.requestDate = _data["requestDate"] ? DateTime.fromISO(_data["requestDate"].toString()) : <any>undefined;
            this.requestDuedate = _data["requestDuedate"] ? DateTime.fromISO(_data["requestDuedate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.employeeId = _data["employeeId"];
            this.vendorId = _data["vendorId"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.currencyCode = _data["currencyCode"];
            this.totalAmount = _data["totalAmount"];
            this.totalCount = _data["totalCount"];
            this.employeeName = _data["employeeName"];
            this.supplierName = _data["supplierName"];
            this.vendorSiteCode = _data["vendorSiteCode"];
            this.authorizationStatus = _data["authorizationStatus"];
            this.status = _data["status"];
            this.paymentMethod = _data["paymentMethod"];
            this.bankAccountName = _data["bankAccountName"];
            this.bankAccountNumber = _data["bankAccountNumber"];
            this.bankName = _data["bankName"];
            this.bankBranchName = _data["bankBranchName"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.invoiceAmount = _data["invoiceAmount"];
            this.invoiceDate = _data["invoiceDate"] ? DateTime.fromISO(_data["invoiceDate"].toString()) : <any>undefined;
            this.prepaymentAmount = _data["prepaymentAmount"];
            this.poNo = _data["poNo"];
            this.invoiceId = _data["invoiceId"];
            this.poHeaderId = _data["poHeaderId"];
            this.totalPrice = _data["totalPrice"];
            this.totalPriceUsd = _data["totalPriceUsd"];
            this.sourcePayment = _data["sourcePayment"];
            this.availableAmount = _data["availableAmount"];
        }
    }

    static fromJS(data: any): PaymentFromSuppliersDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentFromSuppliersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paymentNo"] = this.paymentNo;
        data["requestDate"] = this.requestDate ? this.requestDate.toString() : <any>undefined;
        data["requestDuedate"] = this.requestDuedate ? this.requestDuedate.toString() : <any>undefined;
        data["description"] = this.description;
        data["employeeId"] = this.employeeId;
        data["vendorId"] = this.vendorId;
        data["vendorSiteId"] = this.vendorSiteId;
        data["currencyCode"] = this.currencyCode;
        data["totalAmount"] = this.totalAmount;
        data["totalCount"] = this.totalCount;
        data["employeeName"] = this.employeeName;
        data["supplierName"] = this.supplierName;
        data["vendorSiteCode"] = this.vendorSiteCode;
        data["authorizationStatus"] = this.authorizationStatus;
        data["status"] = this.status;
        data["paymentMethod"] = this.paymentMethod;
        data["bankAccountName"] = this.bankAccountName;
        data["bankAccountNumber"] = this.bankAccountNumber;
        data["bankName"] = this.bankName;
        data["bankBranchName"] = this.bankBranchName;
        data["invoiceNumber"] = this.invoiceNumber;
        data["invoiceAmount"] = this.invoiceAmount;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toString() : <any>undefined;
        data["prepaymentAmount"] = this.prepaymentAmount;
        data["poNo"] = this.poNo;
        data["invoiceId"] = this.invoiceId;
        data["poHeaderId"] = this.poHeaderId;
        data["totalPrice"] = this.totalPrice;
        data["totalPriceUsd"] = this.totalPriceUsd;
        data["sourcePayment"] = this.sourcePayment;
        data["availableAmount"] = this.availableAmount;
        return data;
    }
}

export interface IPaymentFromSuppliersDto {
    id: number;
    paymentNo: string | undefined;
    requestDate: DateTime;
    requestDuedate: DateTime;
    description: string | undefined;
    employeeId: number | undefined;
    vendorId: number | undefined;
    vendorSiteId: number | undefined;
    currencyCode: string | undefined;
    totalAmount: number | undefined;
    totalCount: number;
    employeeName: string | undefined;
    supplierName: string | undefined;
    vendorSiteCode: string | undefined;
    authorizationStatus: string | undefined;
    status: number;
    paymentMethod: string | undefined;
    bankAccountName: string | undefined;
    bankAccountNumber: string | undefined;
    bankName: string | undefined;
    bankBranchName: string | undefined;
    invoiceNumber: string | undefined;
    invoiceAmount: number | undefined;
    invoiceDate: DateTime | undefined;
    prepaymentAmount: number | undefined;
    poNo: string | undefined;
    invoiceId: number | undefined;
    poHeaderId: number | undefined;
    totalPrice: number | undefined;
    totalPriceUsd: number | undefined;
    sourcePayment: number;
    availableAmount: number | undefined;
}

export class PagedResultDtoOfPaymentFromSuppliersDto implements IPagedResultDtoOfPaymentFromSuppliersDto {
    totalCount!: number;
    items!: PaymentFromSuppliersDto[] | undefined;

    constructor(data?: IPagedResultDtoOfPaymentFromSuppliersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PaymentFromSuppliersDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPaymentFromSuppliersDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPaymentFromSuppliersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfPaymentFromSuppliersDto {
    totalCount: number;
    items: PaymentFromSuppliersDto[] | undefined;
}

export class GetInvoiceHeadersDto implements IGetInvoiceHeadersDto {
    checked!: boolean;
    id!: number;
    invoiceNum!: string | undefined;
    description!: string | undefined;
    invoiceDate!: DateTime | undefined;
    vendorId!: number | undefined;
    vendorName!: string | undefined;
    vendorNumber!: string | undefined;
    vendorSiteId!: number | undefined;
    currencyCode!: string | undefined;
    rate!: number | undefined;
    rateDate!: DateTime | undefined;
    invoiceAmount!: number | undefined;
    amountVat!: number | undefined;
    taxId!: number | undefined;
    taxName!: string | undefined;
    taxRate!: number | undefined;
    differency!: number | undefined;
    amountDeducted!: number | undefined;
    supplierName!: string | undefined;
    adjustmentForInvoiceId!: number | undefined;
    isAdjustmentInvoice!: boolean;
    preAmount!: number | undefined;
    availableAmount!: number | undefined;
    totalCount!: number;
    poNo!: string | undefined;

    constructor(data?: IGetInvoiceHeadersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checked = _data["checked"];
            this.id = _data["id"];
            this.invoiceNum = _data["invoiceNum"];
            this.description = _data["description"];
            this.invoiceDate = _data["invoiceDate"] ? DateTime.fromISO(_data["invoiceDate"].toString()) : <any>undefined;
            this.vendorId = _data["vendorId"];
            this.vendorName = _data["vendorName"];
            this.vendorNumber = _data["vendorNumber"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.currencyCode = _data["currencyCode"];
            this.rate = _data["rate"];
            this.rateDate = _data["rateDate"] ? DateTime.fromISO(_data["rateDate"].toString()) : <any>undefined;
            this.invoiceAmount = _data["invoiceAmount"];
            this.amountVat = _data["amountVat"];
            this.taxId = _data["taxId"];
            this.taxName = _data["taxName"];
            this.taxRate = _data["taxRate"];
            this.differency = _data["differency"];
            this.amountDeducted = _data["amountDeducted"];
            this.supplierName = _data["supplierName"];
            this.adjustmentForInvoiceId = _data["adjustmentForInvoiceId"];
            this.isAdjustmentInvoice = _data["isAdjustmentInvoice"];
            this.preAmount = _data["preAmount"];
            this.availableAmount = _data["availableAmount"];
            this.totalCount = _data["totalCount"];
            this.poNo = _data["poNo"];
        }
    }

    static fromJS(data: any): GetInvoiceHeadersDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetInvoiceHeadersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checked"] = this.checked;
        data["id"] = this.id;
        data["invoiceNum"] = this.invoiceNum;
        data["description"] = this.description;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toString() : <any>undefined;
        data["vendorId"] = this.vendorId;
        data["vendorName"] = this.vendorName;
        data["vendorNumber"] = this.vendorNumber;
        data["vendorSiteId"] = this.vendorSiteId;
        data["currencyCode"] = this.currencyCode;
        data["rate"] = this.rate;
        data["rateDate"] = this.rateDate ? this.rateDate.toString() : <any>undefined;
        data["invoiceAmount"] = this.invoiceAmount;
        data["amountVat"] = this.amountVat;
        data["taxId"] = this.taxId;
        data["taxName"] = this.taxName;
        data["taxRate"] = this.taxRate;
        data["differency"] = this.differency;
        data["amountDeducted"] = this.amountDeducted;
        data["supplierName"] = this.supplierName;
        data["adjustmentForInvoiceId"] = this.adjustmentForInvoiceId;
        data["isAdjustmentInvoice"] = this.isAdjustmentInvoice;
        data["preAmount"] = this.preAmount;
        data["availableAmount"] = this.availableAmount;
        data["totalCount"] = this.totalCount;
        data["poNo"] = this.poNo;
        return data;
    }
}

export interface IGetInvoiceHeadersDto {
    checked: boolean;
    id: number;
    invoiceNum: string | undefined;
    description: string | undefined;
    invoiceDate: DateTime | undefined;
    vendorId: number | undefined;
    vendorName: string | undefined;
    vendorNumber: string | undefined;
    vendorSiteId: number | undefined;
    currencyCode: string | undefined;
    rate: number | undefined;
    rateDate: DateTime | undefined;
    invoiceAmount: number | undefined;
    amountVat: number | undefined;
    taxId: number | undefined;
    taxName: string | undefined;
    taxRate: number | undefined;
    differency: number | undefined;
    amountDeducted: number | undefined;
    supplierName: string | undefined;
    adjustmentForInvoiceId: number | undefined;
    isAdjustmentInvoice: boolean;
    preAmount: number | undefined;
    availableAmount: number | undefined;
    totalCount: number;
    poNo: string | undefined;
}

export class PagedResultDtoOfGetInvoiceHeadersDto implements IPagedResultDtoOfGetInvoiceHeadersDto {
    totalCount!: number;
    items!: GetInvoiceHeadersDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetInvoiceHeadersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetInvoiceHeadersDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetInvoiceHeadersDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetInvoiceHeadersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetInvoiceHeadersDto {
    totalCount: number;
    items: GetInvoiceHeadersDto[] | undefined;
}

export class GetPoHeadersDto implements IGetPoHeadersDto {
    poHeaderId!: number;
    vendorId!: number | undefined;
    vendorSiteId!: number | undefined;
    poNo!: string | undefined;
    vendorName!: string | undefined;
    approvedDate!: DateTime | undefined;
    totalCount!: number | undefined;
    preAmount!: number;
    availableAmount!: number;
    totalPrice!: number;
    totalPriceUsd!: number;

    constructor(data?: IGetPoHeadersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.poHeaderId = _data["poHeaderId"];
            this.vendorId = _data["vendorId"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.poNo = _data["poNo"];
            this.vendorName = _data["vendorName"];
            this.approvedDate = _data["approvedDate"] ? DateTime.fromISO(_data["approvedDate"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
            this.preAmount = _data["preAmount"];
            this.availableAmount = _data["availableAmount"];
            this.totalPrice = _data["totalPrice"];
            this.totalPriceUsd = _data["totalPriceUsd"];
        }
    }

    static fromJS(data: any): GetPoHeadersDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPoHeadersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["poHeaderId"] = this.poHeaderId;
        data["vendorId"] = this.vendorId;
        data["vendorSiteId"] = this.vendorSiteId;
        data["poNo"] = this.poNo;
        data["vendorName"] = this.vendorName;
        data["approvedDate"] = this.approvedDate ? this.approvedDate.toString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["preAmount"] = this.preAmount;
        data["availableAmount"] = this.availableAmount;
        data["totalPrice"] = this.totalPrice;
        data["totalPriceUsd"] = this.totalPriceUsd;
        return data;
    }
}

export interface IGetPoHeadersDto {
    poHeaderId: number;
    vendorId: number | undefined;
    vendorSiteId: number | undefined;
    poNo: string | undefined;
    vendorName: string | undefined;
    approvedDate: DateTime | undefined;
    totalCount: number | undefined;
    preAmount: number;
    availableAmount: number;
    totalPrice: number;
    totalPriceUsd: number;
}

export class PagedResultDtoOfGetPoHeadersDto implements IPagedResultDtoOfGetPoHeadersDto {
    totalCount!: number;
    items!: GetPoHeadersDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPoHeadersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetPoHeadersDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPoHeadersDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPoHeadersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetPoHeadersDto {
    totalCount: number;
    items: GetPoHeadersDto[] | undefined;
}

export class PaymentFromSupplierAttachmentsDto implements IPaymentFromSupplierAttachmentsDto {
    id!: number;
    paymentHeaderId!: number;
    serverFileName!: string | undefined;
    serverLink!: string | undefined;
    contentType!: string | undefined;

    constructor(data?: IPaymentFromSupplierAttachmentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paymentHeaderId = _data["paymentHeaderId"];
            this.serverFileName = _data["serverFileName"];
            this.serverLink = _data["serverLink"];
            this.contentType = _data["contentType"];
        }
    }

    static fromJS(data: any): PaymentFromSupplierAttachmentsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentFromSupplierAttachmentsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paymentHeaderId"] = this.paymentHeaderId;
        data["serverFileName"] = this.serverFileName;
        data["serverLink"] = this.serverLink;
        data["contentType"] = this.contentType;
        return data;
    }
}

export interface IPaymentFromSupplierAttachmentsDto {
    id: number;
    paymentHeaderId: number;
    serverFileName: string | undefined;
    serverLink: string | undefined;
    contentType: string | undefined;
}

export class InputPaymentFromSuppliersDto implements IInputPaymentFromSuppliersDto {
    id!: number;
    paymentNo!: string | undefined;
    requestDate!: DateTime;
    requestDuedate!: DateTime;
    description!: string | undefined;
    employeeId!: number | undefined;
    vendorId!: number | undefined;
    vendorSiteId!: number | undefined;
    currencyCode!: string | undefined;
    totalAmount!: number | undefined;
    totalCount!: number;
    paymentMethod!: string | undefined;
    bankAccountName!: string | undefined;
    bankAccountNumber!: string | undefined;
    bankName!: string | undefined;
    bankBranchName!: string | undefined;
    invoiceNumber!: string | undefined;
    invoiceAmount!: number | undefined;
    invoiceDate!: DateTime | undefined;
    prepaymentAmount!: number | undefined;
    poNo!: string | undefined;
    invoiceId!: number | undefined;
    poHeaderId!: number | undefined;
    totalPrice!: number | undefined;
    totalPriceUsd!: number | undefined;
    sourcePayment!: number;
    availableAmount!: number | undefined;
    attachments!: PaymentFromSupplierAttachmentsDto[] | undefined;

    constructor(data?: IInputPaymentFromSuppliersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paymentNo = _data["paymentNo"];
            this.requestDate = _data["requestDate"] ? DateTime.fromISO(_data["requestDate"].toString()) : <any>undefined;
            this.requestDuedate = _data["requestDuedate"] ? DateTime.fromISO(_data["requestDuedate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.employeeId = _data["employeeId"];
            this.vendorId = _data["vendorId"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.currencyCode = _data["currencyCode"];
            this.totalAmount = _data["totalAmount"];
            this.totalCount = _data["totalCount"];
            this.paymentMethod = _data["paymentMethod"];
            this.bankAccountName = _data["bankAccountName"];
            this.bankAccountNumber = _data["bankAccountNumber"];
            this.bankName = _data["bankName"];
            this.bankBranchName = _data["bankBranchName"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.invoiceAmount = _data["invoiceAmount"];
            this.invoiceDate = _data["invoiceDate"] ? DateTime.fromISO(_data["invoiceDate"].toString()) : <any>undefined;
            this.prepaymentAmount = _data["prepaymentAmount"];
            this.poNo = _data["poNo"];
            this.invoiceId = _data["invoiceId"];
            this.poHeaderId = _data["poHeaderId"];
            this.totalPrice = _data["totalPrice"];
            this.totalPriceUsd = _data["totalPriceUsd"];
            this.sourcePayment = _data["sourcePayment"];
            this.availableAmount = _data["availableAmount"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(PaymentFromSupplierAttachmentsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InputPaymentFromSuppliersDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputPaymentFromSuppliersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paymentNo"] = this.paymentNo;
        data["requestDate"] = this.requestDate ? this.requestDate.toString() : <any>undefined;
        data["requestDuedate"] = this.requestDuedate ? this.requestDuedate.toString() : <any>undefined;
        data["description"] = this.description;
        data["employeeId"] = this.employeeId;
        data["vendorId"] = this.vendorId;
        data["vendorSiteId"] = this.vendorSiteId;
        data["currencyCode"] = this.currencyCode;
        data["totalAmount"] = this.totalAmount;
        data["totalCount"] = this.totalCount;
        data["paymentMethod"] = this.paymentMethod;
        data["bankAccountName"] = this.bankAccountName;
        data["bankAccountNumber"] = this.bankAccountNumber;
        data["bankName"] = this.bankName;
        data["bankBranchName"] = this.bankBranchName;
        data["invoiceNumber"] = this.invoiceNumber;
        data["invoiceAmount"] = this.invoiceAmount;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toString() : <any>undefined;
        data["prepaymentAmount"] = this.prepaymentAmount;
        data["poNo"] = this.poNo;
        data["invoiceId"] = this.invoiceId;
        data["poHeaderId"] = this.poHeaderId;
        data["totalPrice"] = this.totalPrice;
        data["totalPriceUsd"] = this.totalPriceUsd;
        data["sourcePayment"] = this.sourcePayment;
        data["availableAmount"] = this.availableAmount;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInputPaymentFromSuppliersDto {
    id: number;
    paymentNo: string | undefined;
    requestDate: DateTime;
    requestDuedate: DateTime;
    description: string | undefined;
    employeeId: number | undefined;
    vendorId: number | undefined;
    vendorSiteId: number | undefined;
    currencyCode: string | undefined;
    totalAmount: number | undefined;
    totalCount: number;
    paymentMethod: string | undefined;
    bankAccountName: string | undefined;
    bankAccountNumber: string | undefined;
    bankName: string | undefined;
    bankBranchName: string | undefined;
    invoiceNumber: string | undefined;
    invoiceAmount: number | undefined;
    invoiceDate: DateTime | undefined;
    prepaymentAmount: number | undefined;
    poNo: string | undefined;
    invoiceId: number | undefined;
    poHeaderId: number | undefined;
    totalPrice: number | undefined;
    totalPriceUsd: number | undefined;
    sourcePayment: number;
    availableAmount: number | undefined;
    attachments: PaymentFromSupplierAttachmentsDto[] | undefined;
}

export class InputPaymentLinesDto implements IInputPaymentLinesDto {
    id!: number | undefined;
    paymentHeaderId!: number | undefined;
    paymentAmount!: number | undefined;
    invoiceId!: number | undefined;
    invoiceDate!: DateTime | undefined;
    invoiceNumber!: string | undefined;
    invoiceAmount!: number | undefined;
    prepaymentAmount!: number | undefined;
    isAdjustmentInvoice!: boolean;
    poNo!: string | undefined;
    addedPrepaymentId!: number | undefined;
    amountVat!: number | undefined;

    constructor(data?: IInputPaymentLinesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paymentHeaderId = _data["paymentHeaderId"];
            this.paymentAmount = _data["paymentAmount"];
            this.invoiceId = _data["invoiceId"];
            this.invoiceDate = _data["invoiceDate"] ? DateTime.fromISO(_data["invoiceDate"].toString()) : <any>undefined;
            this.invoiceNumber = _data["invoiceNumber"];
            this.invoiceAmount = _data["invoiceAmount"];
            this.prepaymentAmount = _data["prepaymentAmount"];
            this.isAdjustmentInvoice = _data["isAdjustmentInvoice"];
            this.poNo = _data["poNo"];
            this.addedPrepaymentId = _data["addedPrepaymentId"];
            this.amountVat = _data["amountVat"];
        }
    }

    static fromJS(data: any): InputPaymentLinesDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputPaymentLinesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paymentHeaderId"] = this.paymentHeaderId;
        data["paymentAmount"] = this.paymentAmount;
        data["invoiceId"] = this.invoiceId;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toString() : <any>undefined;
        data["invoiceNumber"] = this.invoiceNumber;
        data["invoiceAmount"] = this.invoiceAmount;
        data["prepaymentAmount"] = this.prepaymentAmount;
        data["isAdjustmentInvoice"] = this.isAdjustmentInvoice;
        data["poNo"] = this.poNo;
        data["addedPrepaymentId"] = this.addedPrepaymentId;
        data["amountVat"] = this.amountVat;
        return data;
    }
}

export interface IInputPaymentLinesDto {
    id: number | undefined;
    paymentHeaderId: number | undefined;
    paymentAmount: number | undefined;
    invoiceId: number | undefined;
    invoiceDate: DateTime | undefined;
    invoiceNumber: string | undefined;
    invoiceAmount: number | undefined;
    prepaymentAmount: number | undefined;
    isAdjustmentInvoice: boolean;
    poNo: string | undefined;
    addedPrepaymentId: number | undefined;
    amountVat: number | undefined;
}

export class GetPaymentReportDto implements IGetPaymentReportDto {
    id!: number;
    paymentNo!: string | undefined;
    requestDate!: DateTime;
    requestDuedate!: DateTime;
    formatRequestDate!: string | undefined;
    formatRequestDuedate!: string | undefined;
    description!: string | undefined;
    employeeId!: number | undefined;
    vendorId!: number | undefined;
    vendorSiteId!: number | undefined;
    creatorUserId!: number;
    currencyCode!: string | undefined;
    totalAmount!: number | undefined;
    totalCount!: number;
    employeeName!: string | undefined;
    employeeCode!: string | undefined;
    employeeDept!: string | undefined;
    supplierName!: string | undefined;
    bankAccountName!: string | undefined;
    bankAccountNumber!: string | undefined;
    bankName!: string | undefined;
    vendorSiteCode!: string | undefined;
    creatorName!: string | undefined;
    creatorTitle!: string | undefined;
    checker1!: string | undefined;
    checker2!: string | undefined;
    checker3!: string | undefined;
    checker4!: string | undefined;
    title1!: string | undefined;
    title2!: string | undefined;
    title3!: string | undefined;
    title4!: string | undefined;
    paymentLines!: InputPaymentLinesDto[] | undefined;

    constructor(data?: IGetPaymentReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paymentNo = _data["paymentNo"];
            this.requestDate = _data["requestDate"] ? DateTime.fromISO(_data["requestDate"].toString()) : <any>undefined;
            this.requestDuedate = _data["requestDuedate"] ? DateTime.fromISO(_data["requestDuedate"].toString()) : <any>undefined;
            this.formatRequestDate = _data["formatRequestDate"];
            this.formatRequestDuedate = _data["formatRequestDuedate"];
            this.description = _data["description"];
            this.employeeId = _data["employeeId"];
            this.vendorId = _data["vendorId"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.creatorUserId = _data["creatorUserId"];
            this.currencyCode = _data["currencyCode"];
            this.totalAmount = _data["totalAmount"];
            this.totalCount = _data["totalCount"];
            this.employeeName = _data["employeeName"];
            this.employeeCode = _data["employeeCode"];
            this.employeeDept = _data["employeeDept"];
            this.supplierName = _data["supplierName"];
            this.bankAccountName = _data["bankAccountName"];
            this.bankAccountNumber = _data["bankAccountNumber"];
            this.bankName = _data["bankName"];
            this.vendorSiteCode = _data["vendorSiteCode"];
            this.creatorName = _data["creatorName"];
            this.creatorTitle = _data["creatorTitle"];
            this.checker1 = _data["checker1"];
            this.checker2 = _data["checker2"];
            this.checker3 = _data["checker3"];
            this.checker4 = _data["checker4"];
            this.title1 = _data["title1"];
            this.title2 = _data["title2"];
            this.title3 = _data["title3"];
            this.title4 = _data["title4"];
            if (Array.isArray(_data["paymentLines"])) {
                this.paymentLines = [] as any;
                for (let item of _data["paymentLines"])
                    this.paymentLines!.push(InputPaymentLinesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPaymentReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPaymentReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paymentNo"] = this.paymentNo;
        data["requestDate"] = this.requestDate ? this.requestDate.toString() : <any>undefined;
        data["requestDuedate"] = this.requestDuedate ? this.requestDuedate.toString() : <any>undefined;
        data["formatRequestDate"] = this.formatRequestDate;
        data["formatRequestDuedate"] = this.formatRequestDuedate;
        data["description"] = this.description;
        data["employeeId"] = this.employeeId;
        data["vendorId"] = this.vendorId;
        data["vendorSiteId"] = this.vendorSiteId;
        data["creatorUserId"] = this.creatorUserId;
        data["currencyCode"] = this.currencyCode;
        data["totalAmount"] = this.totalAmount;
        data["totalCount"] = this.totalCount;
        data["employeeName"] = this.employeeName;
        data["employeeCode"] = this.employeeCode;
        data["employeeDept"] = this.employeeDept;
        data["supplierName"] = this.supplierName;
        data["bankAccountName"] = this.bankAccountName;
        data["bankAccountNumber"] = this.bankAccountNumber;
        data["bankName"] = this.bankName;
        data["vendorSiteCode"] = this.vendorSiteCode;
        data["creatorName"] = this.creatorName;
        data["creatorTitle"] = this.creatorTitle;
        data["checker1"] = this.checker1;
        data["checker2"] = this.checker2;
        data["checker3"] = this.checker3;
        data["checker4"] = this.checker4;
        data["title1"] = this.title1;
        data["title2"] = this.title2;
        data["title3"] = this.title3;
        data["title4"] = this.title4;
        if (Array.isArray(this.paymentLines)) {
            data["paymentLines"] = [];
            for (let item of this.paymentLines)
                data["paymentLines"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetPaymentReportDto {
    id: number;
    paymentNo: string | undefined;
    requestDate: DateTime;
    requestDuedate: DateTime;
    formatRequestDate: string | undefined;
    formatRequestDuedate: string | undefined;
    description: string | undefined;
    employeeId: number | undefined;
    vendorId: number | undefined;
    vendorSiteId: number | undefined;
    creatorUserId: number;
    currencyCode: string | undefined;
    totalAmount: number | undefined;
    totalCount: number;
    employeeName: string | undefined;
    employeeCode: string | undefined;
    employeeDept: string | undefined;
    supplierName: string | undefined;
    bankAccountName: string | undefined;
    bankAccountNumber: string | undefined;
    bankName: string | undefined;
    vendorSiteCode: string | undefined;
    creatorName: string | undefined;
    creatorTitle: string | undefined;
    checker1: string | undefined;
    checker2: string | undefined;
    checker3: string | undefined;
    checker4: string | undefined;
    title1: string | undefined;
    title2: string | undefined;
    title3: string | undefined;
    title4: string | undefined;
    paymentLines: InputPaymentLinesDto[] | undefined;
}

export class PaymentHeadersDto implements IPaymentHeadersDto {
    id!: number;
    paymentNo!: string | undefined;
    invoiceNo!: string | undefined;
    requestDate!: DateTime;
    requestDuedate!: DateTime;
    description!: string | undefined;
    employeeId!: number | undefined;
    vendorId!: number | undefined;
    vendorSiteId!: number | undefined;
    currencyCode!: string | undefined;
    totalAmount!: number | undefined;
    totalCount!: number;
    employeeName!: string | undefined;
    supplierName!: string | undefined;
    vendorSiteCode!: string | undefined;
    authorizationStatus!: string | undefined;
    status!: number;
    paymentMethod!: string | undefined;
    bankAccountName!: string | undefined;
    bankAccountNumber!: string | undefined;
    bankName!: string | undefined;
    bankBranchName!: string | undefined;
    documentId!: number | undefined;
    departmentApprovalName!: string | undefined;

    constructor(data?: IPaymentHeadersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paymentNo = _data["paymentNo"];
            this.invoiceNo = _data["invoiceNo"];
            this.requestDate = _data["requestDate"] ? DateTime.fromISO(_data["requestDate"].toString()) : <any>undefined;
            this.requestDuedate = _data["requestDuedate"] ? DateTime.fromISO(_data["requestDuedate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.employeeId = _data["employeeId"];
            this.vendorId = _data["vendorId"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.currencyCode = _data["currencyCode"];
            this.totalAmount = _data["totalAmount"];
            this.totalCount = _data["totalCount"];
            this.employeeName = _data["employeeName"];
            this.supplierName = _data["supplierName"];
            this.vendorSiteCode = _data["vendorSiteCode"];
            this.authorizationStatus = _data["authorizationStatus"];
            this.status = _data["status"];
            this.paymentMethod = _data["paymentMethod"];
            this.bankAccountName = _data["bankAccountName"];
            this.bankAccountNumber = _data["bankAccountNumber"];
            this.bankName = _data["bankName"];
            this.bankBranchName = _data["bankBranchName"];
            this.documentId = _data["documentId"];
            this.departmentApprovalName = _data["departmentApprovalName"];
        }
    }

    static fromJS(data: any): PaymentHeadersDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentHeadersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paymentNo"] = this.paymentNo;
        data["invoiceNo"] = this.invoiceNo;
        data["requestDate"] = this.requestDate ? this.requestDate.toString() : <any>undefined;
        data["requestDuedate"] = this.requestDuedate ? this.requestDuedate.toString() : <any>undefined;
        data["description"] = this.description;
        data["employeeId"] = this.employeeId;
        data["vendorId"] = this.vendorId;
        data["vendorSiteId"] = this.vendorSiteId;
        data["currencyCode"] = this.currencyCode;
        data["totalAmount"] = this.totalAmount;
        data["totalCount"] = this.totalCount;
        data["employeeName"] = this.employeeName;
        data["supplierName"] = this.supplierName;
        data["vendorSiteCode"] = this.vendorSiteCode;
        data["authorizationStatus"] = this.authorizationStatus;
        data["status"] = this.status;
        data["paymentMethod"] = this.paymentMethod;
        data["bankAccountName"] = this.bankAccountName;
        data["bankAccountNumber"] = this.bankAccountNumber;
        data["bankName"] = this.bankName;
        data["bankBranchName"] = this.bankBranchName;
        data["documentId"] = this.documentId;
        data["departmentApprovalName"] = this.departmentApprovalName;
        return data;
    }
}

export interface IPaymentHeadersDto {
    id: number;
    paymentNo: string | undefined;
    invoiceNo: string | undefined;
    requestDate: DateTime;
    requestDuedate: DateTime;
    description: string | undefined;
    employeeId: number | undefined;
    vendorId: number | undefined;
    vendorSiteId: number | undefined;
    currencyCode: string | undefined;
    totalAmount: number | undefined;
    totalCount: number;
    employeeName: string | undefined;
    supplierName: string | undefined;
    vendorSiteCode: string | undefined;
    authorizationStatus: string | undefined;
    status: number;
    paymentMethod: string | undefined;
    bankAccountName: string | undefined;
    bankAccountNumber: string | undefined;
    bankName: string | undefined;
    bankBranchName: string | undefined;
    documentId: number | undefined;
    departmentApprovalName: string | undefined;
}

export class PagedResultDtoOfPaymentHeadersDto implements IPagedResultDtoOfPaymentHeadersDto {
    totalCount!: number;
    items!: PaymentHeadersDto[] | undefined;

    constructor(data?: IPagedResultDtoOfPaymentHeadersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PaymentHeadersDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPaymentHeadersDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPaymentHeadersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfPaymentHeadersDto {
    totalCount: number;
    items: PaymentHeadersDto[] | undefined;
}

export class GetPrepaymentDto implements IGetPrepaymentDto {
    checked!: boolean;
    id!: number;
    poNo!: string | undefined;
    vendorId!: number | undefined;
    vendorSiteId!: number | undefined;
    amount!: number | undefined;
    advancedDate!: DateTime | undefined;
    isPaymentAdded!: boolean;
    paymentId!: number | undefined;
    paymentNo!: string | undefined;
    paymentRequestDate!: DateTime | undefined;
    supplierName!: string | undefined;
    poHeaderId!: number | undefined;
    invoiceId!: number | undefined;

    constructor(data?: IGetPrepaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checked = _data["checked"];
            this.id = _data["id"];
            this.poNo = _data["poNo"];
            this.vendorId = _data["vendorId"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.amount = _data["amount"];
            this.advancedDate = _data["advancedDate"] ? DateTime.fromISO(_data["advancedDate"].toString()) : <any>undefined;
            this.isPaymentAdded = _data["isPaymentAdded"];
            this.paymentId = _data["paymentId"];
            this.paymentNo = _data["paymentNo"];
            this.paymentRequestDate = _data["paymentRequestDate"] ? DateTime.fromISO(_data["paymentRequestDate"].toString()) : <any>undefined;
            this.supplierName = _data["supplierName"];
            this.poHeaderId = _data["poHeaderId"];
            this.invoiceId = _data["invoiceId"];
        }
    }

    static fromJS(data: any): GetPrepaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPrepaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checked"] = this.checked;
        data["id"] = this.id;
        data["poNo"] = this.poNo;
        data["vendorId"] = this.vendorId;
        data["vendorSiteId"] = this.vendorSiteId;
        data["amount"] = this.amount;
        data["advancedDate"] = this.advancedDate ? this.advancedDate.toString() : <any>undefined;
        data["isPaymentAdded"] = this.isPaymentAdded;
        data["paymentId"] = this.paymentId;
        data["paymentNo"] = this.paymentNo;
        data["paymentRequestDate"] = this.paymentRequestDate ? this.paymentRequestDate.toString() : <any>undefined;
        data["supplierName"] = this.supplierName;
        data["poHeaderId"] = this.poHeaderId;
        data["invoiceId"] = this.invoiceId;
        return data;
    }
}

export interface IGetPrepaymentDto {
    checked: boolean;
    id: number;
    poNo: string | undefined;
    vendorId: number | undefined;
    vendorSiteId: number | undefined;
    amount: number | undefined;
    advancedDate: DateTime | undefined;
    isPaymentAdded: boolean;
    paymentId: number | undefined;
    paymentNo: string | undefined;
    paymentRequestDate: DateTime | undefined;
    supplierName: string | undefined;
    poHeaderId: number | undefined;
    invoiceId: number | undefined;
}

export class PagedResultDtoOfGetPrepaymentDto implements IPagedResultDtoOfGetPrepaymentDto {
    totalCount!: number;
    items!: GetPrepaymentDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPrepaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetPrepaymentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPrepaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPrepaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetPrepaymentDto {
    totalCount: number;
    items: GetPrepaymentDto[] | undefined;
}

export class PaymentAttachmentsDto implements IPaymentAttachmentsDto {
    id!: number;
    paymentHeaderId!: number;
    serverFileName!: string | undefined;
    serverLink!: string | undefined;
    contentType!: string | undefined;

    constructor(data?: IPaymentAttachmentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paymentHeaderId = _data["paymentHeaderId"];
            this.serverFileName = _data["serverFileName"];
            this.serverLink = _data["serverLink"];
            this.contentType = _data["contentType"];
        }
    }

    static fromJS(data: any): PaymentAttachmentsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentAttachmentsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paymentHeaderId"] = this.paymentHeaderId;
        data["serverFileName"] = this.serverFileName;
        data["serverLink"] = this.serverLink;
        data["contentType"] = this.contentType;
        return data;
    }
}

export interface IPaymentAttachmentsDto {
    id: number;
    paymentHeaderId: number;
    serverFileName: string | undefined;
    serverLink: string | undefined;
    contentType: string | undefined;
}

export class InputPaymentHeadersDto implements IInputPaymentHeadersDto {
    id!: number;
    paymentNo!: string | undefined;
    requestDate!: DateTime;
    requestDuedate!: DateTime;
    description!: string | undefined;
    employeeId!: number | undefined;
    vendorId!: number | undefined;
    vendorSiteId!: number | undefined;
    currencyCode!: string | undefined;
    totalAmount!: number | undefined;
    totalCount!: number;
    paymentMethod!: string | undefined;
    bankAccountName!: string | undefined;
    bankAccountNumber!: string | undefined;
    bankName!: string | undefined;
    bankBranchName!: string | undefined;
    documentId!: number | undefined;
    authorizationStatus!: string | undefined;
    status!: number;
    inputPaymentLinesDto!: InputPaymentLinesDto[] | undefined;
    attachments!: PaymentAttachmentsDto[] | undefined;

    constructor(data?: IInputPaymentHeadersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paymentNo = _data["paymentNo"];
            this.requestDate = _data["requestDate"] ? DateTime.fromISO(_data["requestDate"].toString()) : <any>undefined;
            this.requestDuedate = _data["requestDuedate"] ? DateTime.fromISO(_data["requestDuedate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.employeeId = _data["employeeId"];
            this.vendorId = _data["vendorId"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.currencyCode = _data["currencyCode"];
            this.totalAmount = _data["totalAmount"];
            this.totalCount = _data["totalCount"];
            this.paymentMethod = _data["paymentMethod"];
            this.bankAccountName = _data["bankAccountName"];
            this.bankAccountNumber = _data["bankAccountNumber"];
            this.bankName = _data["bankName"];
            this.bankBranchName = _data["bankBranchName"];
            this.documentId = _data["documentId"];
            this.authorizationStatus = _data["authorizationStatus"];
            this.status = _data["status"];
            if (Array.isArray(_data["inputPaymentLinesDto"])) {
                this.inputPaymentLinesDto = [] as any;
                for (let item of _data["inputPaymentLinesDto"])
                    this.inputPaymentLinesDto!.push(InputPaymentLinesDto.fromJS(item));
            }
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(PaymentAttachmentsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InputPaymentHeadersDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputPaymentHeadersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paymentNo"] = this.paymentNo;
        data["requestDate"] = this.requestDate ? this.requestDate.toString() : <any>undefined;
        data["requestDuedate"] = this.requestDuedate ? this.requestDuedate.toString() : <any>undefined;
        data["description"] = this.description;
        data["employeeId"] = this.employeeId;
        data["vendorId"] = this.vendorId;
        data["vendorSiteId"] = this.vendorSiteId;
        data["currencyCode"] = this.currencyCode;
        data["totalAmount"] = this.totalAmount;
        data["totalCount"] = this.totalCount;
        data["paymentMethod"] = this.paymentMethod;
        data["bankAccountName"] = this.bankAccountName;
        data["bankAccountNumber"] = this.bankAccountNumber;
        data["bankName"] = this.bankName;
        data["bankBranchName"] = this.bankBranchName;
        data["documentId"] = this.documentId;
        data["authorizationStatus"] = this.authorizationStatus;
        data["status"] = this.status;
        if (Array.isArray(this.inputPaymentLinesDto)) {
            data["inputPaymentLinesDto"] = [];
            for (let item of this.inputPaymentLinesDto)
                data["inputPaymentLinesDto"].push(item.toJSON());
        }
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInputPaymentHeadersDto {
    id: number;
    paymentNo: string | undefined;
    requestDate: DateTime;
    requestDuedate: DateTime;
    description: string | undefined;
    employeeId: number | undefined;
    vendorId: number | undefined;
    vendorSiteId: number | undefined;
    currencyCode: string | undefined;
    totalAmount: number | undefined;
    totalCount: number;
    paymentMethod: string | undefined;
    bankAccountName: string | undefined;
    bankAccountNumber: string | undefined;
    bankName: string | undefined;
    bankBranchName: string | undefined;
    documentId: number | undefined;
    authorizationStatus: string | undefined;
    status: number;
    inputPaymentLinesDto: InputPaymentLinesDto[] | undefined;
    attachments: PaymentAttachmentsDto[] | undefined;
}

export class GetEmployeesDto implements IGetEmployeesDto {
    id!: number;
    name!: string | undefined;
    userName!: string | undefined;
    posCode!: string | undefined;
    emailAddress!: string | undefined;
    employeeCode!: string | undefined;
    titleCode!: string | undefined;
    deptName!: string | undefined;
    titleDescription!: string | undefined;
    hrOrgStructureId!: string | undefined;
    parentId!: string | undefined;

    constructor(data?: IGetEmployeesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.userName = _data["userName"];
            this.posCode = _data["posCode"];
            this.emailAddress = _data["emailAddress"];
            this.employeeCode = _data["employeeCode"];
            this.titleCode = _data["titleCode"];
            this.deptName = _data["deptName"];
            this.titleDescription = _data["titleDescription"];
            this.hrOrgStructureId = _data["hrOrgStructureId"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): GetEmployeesDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["posCode"] = this.posCode;
        data["emailAddress"] = this.emailAddress;
        data["employeeCode"] = this.employeeCode;
        data["titleCode"] = this.titleCode;
        data["deptName"] = this.deptName;
        data["titleDescription"] = this.titleDescription;
        data["hrOrgStructureId"] = this.hrOrgStructureId;
        data["parentId"] = this.parentId;
        return data;
    }
}

export interface IGetEmployeesDto {
    id: number;
    name: string | undefined;
    userName: string | undefined;
    posCode: string | undefined;
    emailAddress: string | undefined;
    employeeCode: string | undefined;
    titleCode: string | undefined;
    deptName: string | undefined;
    titleDescription: string | undefined;
    hrOrgStructureId: string | undefined;
    parentId: string | undefined;
}

export class PagedResultDtoOfInputPaymentLinesDto implements IPagedResultDtoOfInputPaymentLinesDto {
    totalCount!: number;
    items!: InputPaymentLinesDto[] | undefined;

    constructor(data?: IPagedResultDtoOfInputPaymentLinesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InputPaymentLinesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfInputPaymentLinesDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfInputPaymentLinesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfInputPaymentLinesDto {
    totalCount: number;
    items: InputPaymentLinesDto[] | undefined;
}

export class SupplierBankAccountDto implements ISupplierBankAccountDto {
    supplierId!: number | undefined;
    supplierSiteId!: number | undefined;
    currencyId!: number | undefined;
    isPrimary!: number;
    bankName!: string | undefined;
    bankAccountName!: string | undefined;
    bankAccountNum!: string | undefined;
    id!: number | undefined;

    constructor(data?: ISupplierBankAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supplierId = _data["supplierId"];
            this.supplierSiteId = _data["supplierSiteId"];
            this.currencyId = _data["currencyId"];
            this.isPrimary = _data["isPrimary"];
            this.bankName = _data["bankName"];
            this.bankAccountName = _data["bankAccountName"];
            this.bankAccountNum = _data["bankAccountNum"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SupplierBankAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierBankAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supplierId"] = this.supplierId;
        data["supplierSiteId"] = this.supplierSiteId;
        data["currencyId"] = this.currencyId;
        data["isPrimary"] = this.isPrimary;
        data["bankName"] = this.bankName;
        data["bankAccountName"] = this.bankAccountName;
        data["bankAccountNum"] = this.bankAccountNum;
        data["id"] = this.id;
        return data;
    }
}

export interface ISupplierBankAccountDto {
    supplierId: number | undefined;
    supplierSiteId: number | undefined;
    currencyId: number | undefined;
    isPrimary: number;
    bankName: string | undefined;
    bankAccountName: string | undefined;
    bankAccountNum: string | undefined;
    id: number | undefined;
}

export class PayPalConfigurationDto implements IPayPalConfigurationDto {
    clientId!: string | undefined;
    demoUsername!: string | undefined;
    demoPassword!: string | undefined;

    constructor(data?: IPayPalConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.demoUsername = _data["demoUsername"];
            this.demoPassword = _data["demoPassword"];
        }
    }

    static fromJS(data: any): PayPalConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["demoUsername"] = this.demoUsername;
        data["demoPassword"] = this.demoPassword;
        return data;
    }
}

export interface IPayPalConfigurationDto {
    clientId: string | undefined;
    demoUsername: string | undefined;
    demoPassword: string | undefined;
}

export class MainDashboardActionsForViewDto implements IMainDashboardActionsForViewDto {
    type!: string | undefined;
    subject!: string | undefined;
    requester!: string | undefined;
    requestDate!: DateTime;
    approvalStatus!: string | undefined;
    requisitionNo!: string | undefined;
    id!: number;

    constructor(data?: IMainDashboardActionsForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.subject = _data["subject"];
            this.requester = _data["requester"];
            this.requestDate = _data["requestDate"] ? DateTime.fromISO(_data["requestDate"].toString()) : <any>undefined;
            this.approvalStatus = _data["approvalStatus"];
            this.requisitionNo = _data["requisitionNo"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MainDashboardActionsForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainDashboardActionsForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["subject"] = this.subject;
        data["requester"] = this.requester;
        data["requestDate"] = this.requestDate ? this.requestDate.toString() : <any>undefined;
        data["approvalStatus"] = this.approvalStatus;
        data["requisitionNo"] = this.requisitionNo;
        data["id"] = this.id;
        return data;
    }
}

export interface IMainDashboardActionsForViewDto {
    type: string | undefined;
    subject: string | undefined;
    requester: string | undefined;
    requestDate: DateTime;
    approvalStatus: string | undefined;
    requisitionNo: string | undefined;
    id: number;
}

export class GetAllSystemFunctionForViewDto implements IGetAllSystemFunctionForViewDto {
    functionName!: string | undefined;
    functionKey!: string | undefined;
    id!: number;

    constructor(data?: IGetAllSystemFunctionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.functionName = _data["functionName"];
            this.functionKey = _data["functionKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAllSystemFunctionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSystemFunctionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["functionName"] = this.functionName;
        data["functionKey"] = this.functionKey;
        data["id"] = this.id;
        return data;
    }
}

export interface IGetAllSystemFunctionForViewDto {
    functionName: string | undefined;
    functionKey: string | undefined;
    id: number;
}

export class GetAllUserFunctionsForViewDto implements IGetAllUserFunctionsForViewDto {
    functionName!: string | undefined;
    functionKey!: string | undefined;
    functionId!: number;
    ordering!: number;
    id!: number;

    constructor(data?: IGetAllUserFunctionsForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.functionName = _data["functionName"];
            this.functionKey = _data["functionKey"];
            this.functionId = _data["functionId"];
            this.ordering = _data["ordering"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAllUserFunctionsForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllUserFunctionsForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["functionName"] = this.functionName;
        data["functionKey"] = this.functionKey;
        data["functionId"] = this.functionId;
        data["ordering"] = this.ordering;
        data["id"] = this.id;
        return data;
    }
}

export interface IGetAllUserFunctionsForViewDto {
    functionName: string | undefined;
    functionKey: string | undefined;
    functionId: number;
    ordering: number;
    id: number;
}

export class CreateOrEditUserFunctionListInput implements ICreateOrEditUserFunctionListInput {
    functionId!: number;
    ordering!: number;
    id!: number;

    constructor(data?: ICreateOrEditUserFunctionListInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.functionId = _data["functionId"];
            this.ordering = _data["ordering"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditUserFunctionListInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditUserFunctionListInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["functionId"] = this.functionId;
        data["ordering"] = this.ordering;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditUserFunctionListInput {
    functionId: number;
    ordering: number;
    id: number;
}

export class UserRequestDeliveryDto implements IUserRequestDeliveryDto {
    deliveryDate!: string | undefined;
    quantity!: string | undefined;

    constructor(data?: IUserRequestDeliveryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deliveryDate = _data["deliveryDate"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): UserRequestDeliveryDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRequestDeliveryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deliveryDate"] = this.deliveryDate;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IUserRequestDeliveryDto {
    deliveryDate: string | undefined;
    quantity: string | undefined;
}

export class UserRequestExcelDataDto implements IUserRequestExcelDataDto {
    inventoryGroupId!: number | undefined;
    picDepartmentId!: string | undefined;
    productGroupName!: string | undefined;
    productId!: number | undefined;
    productCodeColor!: string | undefined;
    productCode!: string | undefined;
    colorCode!: string | undefined;
    productName!: string | undefined;
    uom!: string | undefined;
    uomId!: number;
    organizationCode!: string | undefined;
    unitPrice!: number;
    currencyId!: number | undefined;
    currencyCode!: string | undefined;
    supplierId!: number | undefined;
    vendorCode!: string | undefined;
    vendorName!: string | undefined;
    deliveries!: UserRequestDeliveryDto[] | undefined;
    monthN1!: string | undefined;
    monthN2!: string | undefined;
    monthN3!: string | undefined;
    exception!: string | undefined;
    sumQty!: number;

    constructor(data?: IUserRequestExcelDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.picDepartmentId = _data["picDepartmentId"];
            this.productGroupName = _data["productGroupName"];
            this.productId = _data["productId"];
            this.productCodeColor = _data["productCodeColor"];
            this.productCode = _data["productCode"];
            this.colorCode = _data["colorCode"];
            this.productName = _data["productName"];
            this.uom = _data["uom"];
            this.uomId = _data["uomId"];
            this.organizationCode = _data["organizationCode"];
            this.unitPrice = _data["unitPrice"];
            this.currencyId = _data["currencyId"];
            this.currencyCode = _data["currencyCode"];
            this.supplierId = _data["supplierId"];
            this.vendorCode = _data["vendorCode"];
            this.vendorName = _data["vendorName"];
            if (Array.isArray(_data["deliveries"])) {
                this.deliveries = [] as any;
                for (let item of _data["deliveries"])
                    this.deliveries!.push(UserRequestDeliveryDto.fromJS(item));
            }
            this.monthN1 = _data["monthN1"];
            this.monthN2 = _data["monthN2"];
            this.monthN3 = _data["monthN3"];
            this.exception = _data["exception"];
            this.sumQty = _data["sumQty"];
        }
    }

    static fromJS(data: any): UserRequestExcelDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRequestExcelDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["picDepartmentId"] = this.picDepartmentId;
        data["productGroupName"] = this.productGroupName;
        data["productId"] = this.productId;
        data["productCodeColor"] = this.productCodeColor;
        data["productCode"] = this.productCode;
        data["colorCode"] = this.colorCode;
        data["productName"] = this.productName;
        data["uom"] = this.uom;
        data["uomId"] = this.uomId;
        data["organizationCode"] = this.organizationCode;
        data["unitPrice"] = this.unitPrice;
        data["currencyId"] = this.currencyId;
        data["currencyCode"] = this.currencyCode;
        data["supplierId"] = this.supplierId;
        data["vendorCode"] = this.vendorCode;
        data["vendorName"] = this.vendorName;
        if (Array.isArray(this.deliveries)) {
            data["deliveries"] = [];
            for (let item of this.deliveries)
                data["deliveries"].push(item.toJSON());
        }
        data["monthN1"] = this.monthN1;
        data["monthN2"] = this.monthN2;
        data["monthN3"] = this.monthN3;
        data["exception"] = this.exception;
        data["sumQty"] = this.sumQty;
        return data;
    }
}

export interface IUserRequestExcelDataDto {
    inventoryGroupId: number | undefined;
    picDepartmentId: string | undefined;
    productGroupName: string | undefined;
    productId: number | undefined;
    productCodeColor: string | undefined;
    productCode: string | undefined;
    colorCode: string | undefined;
    productName: string | undefined;
    uom: string | undefined;
    uomId: number;
    organizationCode: string | undefined;
    unitPrice: number;
    currencyId: number | undefined;
    currencyCode: string | undefined;
    supplierId: number | undefined;
    vendorCode: string | undefined;
    vendorName: string | undefined;
    deliveries: UserRequestDeliveryDto[] | undefined;
    monthN1: string | undefined;
    monthN2: string | undefined;
    monthN3: string | undefined;
    exception: string | undefined;
    sumQty: number;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    level!: number;
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.level = _data["level"];
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isGrantedByDefault = _data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data;
    }
}

export interface IFlatPermissionWithLevelDto {
    level: number;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
}

export class ListResultDtoOfFlatPermissionWithLevelDto implements IListResultDtoOfFlatPermissionWithLevelDto {
    items!: FlatPermissionWithLevelDto[] | undefined;

    constructor(data?: IListResultDtoOfFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfFlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[] | undefined;
}

export class MstHrOrgStructureOutputSelectDto implements IMstHrOrgStructureOutputSelectDto {
    id!: string;
    name!: string | undefined;
    description!: string | undefined;
    orgStructureTypeName!: string | undefined;
    orgStructureTypeCode!: string | undefined;

    constructor(data?: IMstHrOrgStructureOutputSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.orgStructureTypeName = _data["orgStructureTypeName"];
            this.orgStructureTypeCode = _data["orgStructureTypeCode"];
        }
    }

    static fromJS(data: any): MstHrOrgStructureOutputSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new MstHrOrgStructureOutputSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["orgStructureTypeName"] = this.orgStructureTypeName;
        data["orgStructureTypeCode"] = this.orgStructureTypeCode;
        return data;
    }
}

export interface IMstHrOrgStructureOutputSelectDto {
    id: string;
    name: string | undefined;
    description: string | undefined;
    orgStructureTypeName: string | undefined;
    orgStructureTypeCode: string | undefined;
}

export class PagedResultDtoOfMstHrOrgStructureOutputSelectDto implements IPagedResultDtoOfMstHrOrgStructureOutputSelectDto {
    totalCount!: number;
    items!: MstHrOrgStructureOutputSelectDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMstHrOrgStructureOutputSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MstHrOrgStructureOutputSelectDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMstHrOrgStructureOutputSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMstHrOrgStructureOutputSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMstHrOrgStructureOutputSelectDto {
    totalCount: number;
    items: MstHrOrgStructureOutputSelectDto[] | undefined;
}

export class PersonnelOutputSelectDto implements IPersonnelOutputSelectDto {
    id!: number;
    emailAddress!: string | undefined;
    name!: string | undefined;
    employeesCode!: string | undefined;
    title!: string | undefined;
    position!: string | undefined;
    status!: string | undefined;

    constructor(data?: IPersonnelOutputSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailAddress = _data["emailAddress"];
            this.name = _data["name"];
            this.employeesCode = _data["employeesCode"];
            this.title = _data["title"];
            this.position = _data["position"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): PersonnelOutputSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonnelOutputSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailAddress"] = this.emailAddress;
        data["name"] = this.name;
        data["employeesCode"] = this.employeesCode;
        data["title"] = this.title;
        data["position"] = this.position;
        data["status"] = this.status;
        return data;
    }
}

export interface IPersonnelOutputSelectDto {
    id: number;
    emailAddress: string | undefined;
    name: string | undefined;
    employeesCode: string | undefined;
    title: string | undefined;
    position: string | undefined;
    status: string | undefined;
}

export class PagedResultDtoOfPersonnelOutputSelectDto implements IPagedResultDtoOfPersonnelOutputSelectDto {
    totalCount!: number;
    items!: PersonnelOutputSelectDto[] | undefined;

    constructor(data?: IPagedResultDtoOfPersonnelOutputSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PersonnelOutputSelectDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPersonnelOutputSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPersonnelOutputSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfPersonnelOutputSelectDto {
    totalCount: number;
    items: PersonnelOutputSelectDto[] | undefined;
}

export class GetAllContractHeaderDto implements IGetAllContractHeaderDto {
    contractNo!: string | undefined;
    effectiveFrom!: DateTime | undefined;
    effectiveTo!: DateTime | undefined;
    description!: string | undefined;
    approvalStatus!: string | undefined;
    departmentApprovalName!: string | undefined;
    totalCount!: number;
    attachFiles!: GetAttachFileDto[] | undefined;
    id!: number;

    constructor(data?: IGetAllContractHeaderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractNo = _data["contractNo"];
            this.effectiveFrom = _data["effectiveFrom"] ? DateTime.fromISO(_data["effectiveFrom"].toString()) : <any>undefined;
            this.effectiveTo = _data["effectiveTo"] ? DateTime.fromISO(_data["effectiveTo"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.approvalStatus = _data["approvalStatus"];
            this.departmentApprovalName = _data["departmentApprovalName"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["attachFiles"])) {
                this.attachFiles = [] as any;
                for (let item of _data["attachFiles"])
                    this.attachFiles!.push(GetAttachFileDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAllContractHeaderDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllContractHeaderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractNo"] = this.contractNo;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toString() : <any>undefined;
        data["effectiveTo"] = this.effectiveTo ? this.effectiveTo.toString() : <any>undefined;
        data["description"] = this.description;
        data["approvalStatus"] = this.approvalStatus;
        data["departmentApprovalName"] = this.departmentApprovalName;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.attachFiles)) {
            data["attachFiles"] = [];
            for (let item of this.attachFiles)
                data["attachFiles"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IGetAllContractHeaderDto {
    contractNo: string | undefined;
    effectiveFrom: DateTime | undefined;
    effectiveTo: DateTime | undefined;
    description: string | undefined;
    approvalStatus: string | undefined;
    departmentApprovalName: string | undefined;
    totalCount: number;
    attachFiles: GetAttachFileDto[] | undefined;
    id: number;
}

export class PagedResultDtoOfGetAllContractHeaderDto implements IPagedResultDtoOfGetAllContractHeaderDto {
    totalCount!: number;
    items!: GetAllContractHeaderDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAllContractHeaderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllContractHeaderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAllContractHeaderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAllContractHeaderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAllContractHeaderDto {
    totalCount: number;
    items: GetAllContractHeaderDto[] | undefined;
}

export class GetContactLineByIdOutputDto implements IGetContactLineByIdOutputDto {
    id!: number;
    partNo!: string | undefined;
    color!: string | undefined;
    partName!: string | undefined;
    partNameSupplier!: string | undefined;
    supplierName!: string | undefined;
    currencyCode!: string | undefined;
    unitPrice!: number;
    taxPrice!: number;
    effectiveFrom!: DateTime | undefined;
    effectiveTo!: DateTime | undefined;

    constructor(data?: IGetContactLineByIdOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.partNo = _data["partNo"];
            this.color = _data["color"];
            this.partName = _data["partName"];
            this.partNameSupplier = _data["partNameSupplier"];
            this.supplierName = _data["supplierName"];
            this.currencyCode = _data["currencyCode"];
            this.unitPrice = _data["unitPrice"];
            this.taxPrice = _data["taxPrice"];
            this.effectiveFrom = _data["effectiveFrom"] ? DateTime.fromISO(_data["effectiveFrom"].toString()) : <any>undefined;
            this.effectiveTo = _data["effectiveTo"] ? DateTime.fromISO(_data["effectiveTo"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetContactLineByIdOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetContactLineByIdOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["partNo"] = this.partNo;
        data["color"] = this.color;
        data["partName"] = this.partName;
        data["partNameSupplier"] = this.partNameSupplier;
        data["supplierName"] = this.supplierName;
        data["currencyCode"] = this.currencyCode;
        data["unitPrice"] = this.unitPrice;
        data["taxPrice"] = this.taxPrice;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toString() : <any>undefined;
        data["effectiveTo"] = this.effectiveTo ? this.effectiveTo.toString() : <any>undefined;
        return data;
    }
}

export interface IGetContactLineByIdOutputDto {
    id: number;
    partNo: string | undefined;
    color: string | undefined;
    partName: string | undefined;
    partNameSupplier: string | undefined;
    supplierName: string | undefined;
    currencyCode: string | undefined;
    unitPrice: number;
    taxPrice: number;
    effectiveFrom: DateTime | undefined;
    effectiveTo: DateTime | undefined;
}

export class PrcContractTemplateDto implements IPrcContractTemplateDto {
    id!: number | undefined;
    contractId!: number | undefined;
    contractNo!: string | undefined;
    contractDate!: DateTime | undefined;
    contractDateStr!: string | undefined;
    appendixDate!: DateTime | undefined;
    appendixDateStr!: string | undefined;
    effectiveFrom!: DateTime | undefined;
    effectiveFromStr!: string | undefined;
    effectiveTo!: DateTime | undefined;
    creationTime!: DateTime | undefined;
    effectiveToStr!: string | undefined;
    supplierId!: number | undefined;
    supplierName!: string | undefined;
    description!: string | undefined;
    approvalStatus!: string | undefined;
    departmentApprovalName!: string | undefined;
    approveName!: string | undefined;
    signer_By!: string | undefined;
    signer_By_Suplier!: string | undefined;
    signer_By_Titles!: string | undefined;
    signer_By_Suplier_Titles!: string | undefined;
    totalAmount!: number | undefined;
    totalCount!: number | undefined;
    countItem!: number | undefined;
    inventoryGroupId!: number | undefined;
    paymentTermsId!: number | undefined;
    productGroupName!: string | undefined;
    paymentermsName!: string | undefined;
    titleSigner!: string | undefined;
    titleSignerNcc!: string | undefined;
    placeOfDelivery!: string | undefined;
    shipment!: string | undefined;
    paidBy!: string | undefined;
    orthers!: string | undefined;
    contractAppendixNo!: string | undefined;
    effectiveFromAppendix!: DateTime | undefined;
    effectiveFromStrAppendix!: string | undefined;
    effectiveToAppendix!: DateTime | undefined;
    effectiveToStrAppendix!: string | undefined;
    descriptionAppendix!: string | undefined;
    signerByAppendix!: string | undefined;
    signerBySuplierAppendix!: string | undefined;
    titlesSignerByAppendix!: string | undefined;
    titlesSignerBySuplierAppendix!: string | undefined;
    erroR_DESCRIPTION!: string | undefined;

    constructor(data?: IPrcContractTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contractId = _data["contractId"];
            this.contractNo = _data["contractNo"];
            this.contractDate = _data["contractDate"] ? DateTime.fromISO(_data["contractDate"].toString()) : <any>undefined;
            this.contractDateStr = _data["contractDateStr"];
            this.appendixDate = _data["appendixDate"] ? DateTime.fromISO(_data["appendixDate"].toString()) : <any>undefined;
            this.appendixDateStr = _data["appendixDateStr"];
            this.effectiveFrom = _data["effectiveFrom"] ? DateTime.fromISO(_data["effectiveFrom"].toString()) : <any>undefined;
            this.effectiveFromStr = _data["effectiveFromStr"];
            this.effectiveTo = _data["effectiveTo"] ? DateTime.fromISO(_data["effectiveTo"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.effectiveToStr = _data["effectiveToStr"];
            this.supplierId = _data["supplierId"];
            this.supplierName = _data["supplierName"];
            this.description = _data["description"];
            this.approvalStatus = _data["approvalStatus"];
            this.departmentApprovalName = _data["departmentApprovalName"];
            this.approveName = _data["approveName"];
            this.signer_By = _data["signer_By"];
            this.signer_By_Suplier = _data["signer_By_Suplier"];
            this.signer_By_Titles = _data["signer_By_Titles"];
            this.signer_By_Suplier_Titles = _data["signer_By_Suplier_Titles"];
            this.totalAmount = _data["totalAmount"];
            this.totalCount = _data["totalCount"];
            this.countItem = _data["countItem"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.paymentTermsId = _data["paymentTermsId"];
            this.productGroupName = _data["productGroupName"];
            this.paymentermsName = _data["paymentermsName"];
            this.titleSigner = _data["titleSigner"];
            this.titleSignerNcc = _data["titleSignerNcc"];
            this.placeOfDelivery = _data["placeOfDelivery"];
            this.shipment = _data["shipment"];
            this.paidBy = _data["paidBy"];
            this.orthers = _data["orthers"];
            this.contractAppendixNo = _data["contractAppendixNo"];
            this.effectiveFromAppendix = _data["effectiveFromAppendix"] ? DateTime.fromISO(_data["effectiveFromAppendix"].toString()) : <any>undefined;
            this.effectiveFromStrAppendix = _data["effectiveFromStrAppendix"];
            this.effectiveToAppendix = _data["effectiveToAppendix"] ? DateTime.fromISO(_data["effectiveToAppendix"].toString()) : <any>undefined;
            this.effectiveToStrAppendix = _data["effectiveToStrAppendix"];
            this.descriptionAppendix = _data["descriptionAppendix"];
            this.signerByAppendix = _data["signerByAppendix"];
            this.signerBySuplierAppendix = _data["signerBySuplierAppendix"];
            this.titlesSignerByAppendix = _data["titlesSignerByAppendix"];
            this.titlesSignerBySuplierAppendix = _data["titlesSignerBySuplierAppendix"];
            this.erroR_DESCRIPTION = _data["erroR_DESCRIPTION"];
        }
    }

    static fromJS(data: any): PrcContractTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrcContractTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contractId"] = this.contractId;
        data["contractNo"] = this.contractNo;
        data["contractDate"] = this.contractDate ? this.contractDate.toString() : <any>undefined;
        data["contractDateStr"] = this.contractDateStr;
        data["appendixDate"] = this.appendixDate ? this.appendixDate.toString() : <any>undefined;
        data["appendixDateStr"] = this.appendixDateStr;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toString() : <any>undefined;
        data["effectiveFromStr"] = this.effectiveFromStr;
        data["effectiveTo"] = this.effectiveTo ? this.effectiveTo.toString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["effectiveToStr"] = this.effectiveToStr;
        data["supplierId"] = this.supplierId;
        data["supplierName"] = this.supplierName;
        data["description"] = this.description;
        data["approvalStatus"] = this.approvalStatus;
        data["departmentApprovalName"] = this.departmentApprovalName;
        data["approveName"] = this.approveName;
        data["signer_By"] = this.signer_By;
        data["signer_By_Suplier"] = this.signer_By_Suplier;
        data["signer_By_Titles"] = this.signer_By_Titles;
        data["signer_By_Suplier_Titles"] = this.signer_By_Suplier_Titles;
        data["totalAmount"] = this.totalAmount;
        data["totalCount"] = this.totalCount;
        data["countItem"] = this.countItem;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["paymentTermsId"] = this.paymentTermsId;
        data["productGroupName"] = this.productGroupName;
        data["paymentermsName"] = this.paymentermsName;
        data["titleSigner"] = this.titleSigner;
        data["titleSignerNcc"] = this.titleSignerNcc;
        data["placeOfDelivery"] = this.placeOfDelivery;
        data["shipment"] = this.shipment;
        data["paidBy"] = this.paidBy;
        data["orthers"] = this.orthers;
        data["contractAppendixNo"] = this.contractAppendixNo;
        data["effectiveFromAppendix"] = this.effectiveFromAppendix ? this.effectiveFromAppendix.toString() : <any>undefined;
        data["effectiveFromStrAppendix"] = this.effectiveFromStrAppendix;
        data["effectiveToAppendix"] = this.effectiveToAppendix ? this.effectiveToAppendix.toString() : <any>undefined;
        data["effectiveToStrAppendix"] = this.effectiveToStrAppendix;
        data["descriptionAppendix"] = this.descriptionAppendix;
        data["signerByAppendix"] = this.signerByAppendix;
        data["signerBySuplierAppendix"] = this.signerBySuplierAppendix;
        data["titlesSignerByAppendix"] = this.titlesSignerByAppendix;
        data["titlesSignerBySuplierAppendix"] = this.titlesSignerBySuplierAppendix;
        data["erroR_DESCRIPTION"] = this.erroR_DESCRIPTION;
        return data;
    }
}

export interface IPrcContractTemplateDto {
    id: number | undefined;
    contractId: number | undefined;
    contractNo: string | undefined;
    contractDate: DateTime | undefined;
    contractDateStr: string | undefined;
    appendixDate: DateTime | undefined;
    appendixDateStr: string | undefined;
    effectiveFrom: DateTime | undefined;
    effectiveFromStr: string | undefined;
    effectiveTo: DateTime | undefined;
    creationTime: DateTime | undefined;
    effectiveToStr: string | undefined;
    supplierId: number | undefined;
    supplierName: string | undefined;
    description: string | undefined;
    approvalStatus: string | undefined;
    departmentApprovalName: string | undefined;
    approveName: string | undefined;
    signer_By: string | undefined;
    signer_By_Suplier: string | undefined;
    signer_By_Titles: string | undefined;
    signer_By_Suplier_Titles: string | undefined;
    totalAmount: number | undefined;
    totalCount: number | undefined;
    countItem: number | undefined;
    inventoryGroupId: number | undefined;
    paymentTermsId: number | undefined;
    productGroupName: string | undefined;
    paymentermsName: string | undefined;
    titleSigner: string | undefined;
    titleSignerNcc: string | undefined;
    placeOfDelivery: string | undefined;
    shipment: string | undefined;
    paidBy: string | undefined;
    orthers: string | undefined;
    contractAppendixNo: string | undefined;
    effectiveFromAppendix: DateTime | undefined;
    effectiveFromStrAppendix: string | undefined;
    effectiveToAppendix: DateTime | undefined;
    effectiveToStrAppendix: string | undefined;
    descriptionAppendix: string | undefined;
    signerByAppendix: string | undefined;
    signerBySuplierAppendix: string | undefined;
    titlesSignerByAppendix: string | undefined;
    titlesSignerBySuplierAppendix: string | undefined;
    erroR_DESCRIPTION: string | undefined;
}

export class PagedResultDtoOfPrcContractTemplateDto implements IPagedResultDtoOfPrcContractTemplateDto {
    totalCount!: number;
    items!: PrcContractTemplateDto[] | undefined;

    constructor(data?: IPagedResultDtoOfPrcContractTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PrcContractTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPrcContractTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPrcContractTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfPrcContractTemplateDto {
    totalCount: number;
    items: PrcContractTemplateDto[] | undefined;
}

export class PrcAppendixContractDto implements IPrcAppendixContractDto {
    id!: number | undefined;
    appendixId!: number | undefined;
    creatorUserId!: number | undefined;
    appendixNo!: string | undefined;
    appendixDate!: DateTime | undefined;
    effectiveFrom!: DateTime | undefined;
    effectiveTo!: DateTime | undefined;
    contractId!: number | undefined;
    contractNo!: string | undefined;
    description!: string | undefined;
    approvalStatus!: string | undefined;
    signer_By!: string | undefined;
    signer_By_Suplier!: string | undefined;
    totalAmount!: number | undefined;
    countItem!: number | undefined;
    supplierName!: string | undefined;
    expiryBackdate!: number | undefined;
    noteOfBackdate!: string | undefined;
    titleSigner!: string | undefined;
    titleSignerNcc!: string | undefined;
    placeOfDelivery!: string | undefined;
    shipment!: string | undefined;
    paidBy!: string | undefined;
    orthers!: string | undefined;
    supplierId!: number;
    isBackdate!: boolean | undefined;

    constructor(data?: IPrcAppendixContractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.appendixId = _data["appendixId"];
            this.creatorUserId = _data["creatorUserId"];
            this.appendixNo = _data["appendixNo"];
            this.appendixDate = _data["appendixDate"] ? DateTime.fromISO(_data["appendixDate"].toString()) : <any>undefined;
            this.effectiveFrom = _data["effectiveFrom"] ? DateTime.fromISO(_data["effectiveFrom"].toString()) : <any>undefined;
            this.effectiveTo = _data["effectiveTo"] ? DateTime.fromISO(_data["effectiveTo"].toString()) : <any>undefined;
            this.contractId = _data["contractId"];
            this.contractNo = _data["contractNo"];
            this.description = _data["description"];
            this.approvalStatus = _data["approvalStatus"];
            this.signer_By = _data["signer_By"];
            this.signer_By_Suplier = _data["signer_By_Suplier"];
            this.totalAmount = _data["totalAmount"];
            this.countItem = _data["countItem"];
            this.supplierName = _data["supplierName"];
            this.expiryBackdate = _data["expiryBackdate"];
            this.noteOfBackdate = _data["noteOfBackdate"];
            this.titleSigner = _data["titleSigner"];
            this.titleSignerNcc = _data["titleSignerNcc"];
            this.placeOfDelivery = _data["placeOfDelivery"];
            this.shipment = _data["shipment"];
            this.paidBy = _data["paidBy"];
            this.orthers = _data["orthers"];
            this.supplierId = _data["supplierId"];
            this.isBackdate = _data["isBackdate"];
        }
    }

    static fromJS(data: any): PrcAppendixContractDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrcAppendixContractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["appendixId"] = this.appendixId;
        data["creatorUserId"] = this.creatorUserId;
        data["appendixNo"] = this.appendixNo;
        data["appendixDate"] = this.appendixDate ? this.appendixDate.toString() : <any>undefined;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toString() : <any>undefined;
        data["effectiveTo"] = this.effectiveTo ? this.effectiveTo.toString() : <any>undefined;
        data["contractId"] = this.contractId;
        data["contractNo"] = this.contractNo;
        data["description"] = this.description;
        data["approvalStatus"] = this.approvalStatus;
        data["signer_By"] = this.signer_By;
        data["signer_By_Suplier"] = this.signer_By_Suplier;
        data["totalAmount"] = this.totalAmount;
        data["countItem"] = this.countItem;
        data["supplierName"] = this.supplierName;
        data["expiryBackdate"] = this.expiryBackdate;
        data["noteOfBackdate"] = this.noteOfBackdate;
        data["titleSigner"] = this.titleSigner;
        data["titleSignerNcc"] = this.titleSignerNcc;
        data["placeOfDelivery"] = this.placeOfDelivery;
        data["shipment"] = this.shipment;
        data["paidBy"] = this.paidBy;
        data["orthers"] = this.orthers;
        data["supplierId"] = this.supplierId;
        data["isBackdate"] = this.isBackdate;
        return data;
    }
}

export interface IPrcAppendixContractDto {
    id: number | undefined;
    appendixId: number | undefined;
    creatorUserId: number | undefined;
    appendixNo: string | undefined;
    appendixDate: DateTime | undefined;
    effectiveFrom: DateTime | undefined;
    effectiveTo: DateTime | undefined;
    contractId: number | undefined;
    contractNo: string | undefined;
    description: string | undefined;
    approvalStatus: string | undefined;
    signer_By: string | undefined;
    signer_By_Suplier: string | undefined;
    totalAmount: number | undefined;
    countItem: number | undefined;
    supplierName: string | undefined;
    expiryBackdate: number | undefined;
    noteOfBackdate: string | undefined;
    titleSigner: string | undefined;
    titleSignerNcc: string | undefined;
    placeOfDelivery: string | undefined;
    shipment: string | undefined;
    paidBy: string | undefined;
    orthers: string | undefined;
    supplierId: number;
    isBackdate: boolean | undefined;
}

export class PrcAppendixContractItemsDto implements IPrcAppendixContractItemsDto {
    id!: number | undefined;
    appendixId!: number | undefined;
    contractId!: number | undefined;
    itemId!: number | undefined;
    partNo!: string | undefined;
    color!: string | undefined;
    inventoryGroupName!: string | undefined;
    partName!: string | undefined;
    partNameSupplier!: string | undefined;
    unitPrice!: number | undefined;
    taxPrice!: number | undefined;
    qty!: number | undefined;
    currencyCode!: string | undefined;
    unitOfMeasure!: string | undefined;
    countItem!: number | undefined;
    unitOfMeasureId!: number;
    totalAmount!: number | undefined;

    constructor(data?: IPrcAppendixContractItemsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.appendixId = _data["appendixId"];
            this.contractId = _data["contractId"];
            this.itemId = _data["itemId"];
            this.partNo = _data["partNo"];
            this.color = _data["color"];
            this.inventoryGroupName = _data["inventoryGroupName"];
            this.partName = _data["partName"];
            this.partNameSupplier = _data["partNameSupplier"];
            this.unitPrice = _data["unitPrice"];
            this.taxPrice = _data["taxPrice"];
            this.qty = _data["qty"];
            this.currencyCode = _data["currencyCode"];
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.countItem = _data["countItem"];
            this.unitOfMeasureId = _data["unitOfMeasureId"];
            this.totalAmount = _data["totalAmount"];
        }
    }

    static fromJS(data: any): PrcAppendixContractItemsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrcAppendixContractItemsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["appendixId"] = this.appendixId;
        data["contractId"] = this.contractId;
        data["itemId"] = this.itemId;
        data["partNo"] = this.partNo;
        data["color"] = this.color;
        data["inventoryGroupName"] = this.inventoryGroupName;
        data["partName"] = this.partName;
        data["partNameSupplier"] = this.partNameSupplier;
        data["unitPrice"] = this.unitPrice;
        data["taxPrice"] = this.taxPrice;
        data["qty"] = this.qty;
        data["currencyCode"] = this.currencyCode;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["countItem"] = this.countItem;
        data["unitOfMeasureId"] = this.unitOfMeasureId;
        data["totalAmount"] = this.totalAmount;
        return data;
    }
}

export interface IPrcAppendixContractItemsDto {
    id: number | undefined;
    appendixId: number | undefined;
    contractId: number | undefined;
    itemId: number | undefined;
    partNo: string | undefined;
    color: string | undefined;
    inventoryGroupName: string | undefined;
    partName: string | undefined;
    partNameSupplier: string | undefined;
    unitPrice: number | undefined;
    taxPrice: number | undefined;
    qty: number | undefined;
    currencyCode: string | undefined;
    unitOfMeasure: string | undefined;
    countItem: number | undefined;
    unitOfMeasureId: number;
    totalAmount: number | undefined;
}

export class PrcContractTemplateImportDto implements IPrcContractTemplateImportDto {
    appendixId!: number | undefined;
    contractId!: number | undefined;
    contractNo!: string | undefined;
    contractAppendixNo!: string | undefined;
    itemId!: number | undefined;
    partNo!: string | undefined;
    partName!: string | undefined;
    partNameSupplier!: string | undefined;
    unitPrice!: number | undefined;
    currency!: string | undefined;
    taxPrice!: number | undefined;
    qty!: number | undefined;
    currencyCode!: string | undefined;
    unitOfMeasureId!: number | undefined;
    inventoryGroupId!: number | undefined;
    catalogId!: number | undefined;
    length!: string | undefined;
    width!: string | undefined;
    height!: string | undefined;
    unitLength!: string | undefined;
    unitWidth!: string | undefined;
    unitHeight!: string | undefined;
    weight!: string | undefined;
    unitWeight!: string | undefined;
    coo!: string | undefined;
    material!: string | undefined;
    unitOfProduct!: string | undefined;
    unitOfExchangeProduct!: string | undefined;
    producer!: string | undefined;
    erroR_DESCRIPTION!: string | undefined;
    no!: string | undefined;
    invetoryGroupName!: string | undefined;
    catalogName!: string | undefined;
    qtyStr!: string | undefined;
    unitOfMeasure!: string | undefined;
    unitPriceStr!: string | undefined;
    taxPriceStr!: string | undefined;
    salesAmount!: string | undefined;
    description!: string | undefined;

    constructor(data?: IPrcContractTemplateImportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appendixId = _data["appendixId"];
            this.contractId = _data["contractId"];
            this.contractNo = _data["contractNo"];
            this.contractAppendixNo = _data["contractAppendixNo"];
            this.itemId = _data["itemId"];
            this.partNo = _data["partNo"];
            this.partName = _data["partName"];
            this.partNameSupplier = _data["partNameSupplier"];
            this.unitPrice = _data["unitPrice"];
            this.currency = _data["currency"];
            this.taxPrice = _data["taxPrice"];
            this.qty = _data["qty"];
            this.currencyCode = _data["currencyCode"];
            this.unitOfMeasureId = _data["unitOfMeasureId"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.catalogId = _data["catalogId"];
            this.length = _data["length"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.unitLength = _data["unitLength"];
            this.unitWidth = _data["unitWidth"];
            this.unitHeight = _data["unitHeight"];
            this.weight = _data["weight"];
            this.unitWeight = _data["unitWeight"];
            this.coo = _data["coo"];
            this.material = _data["material"];
            this.unitOfProduct = _data["unitOfProduct"];
            this.unitOfExchangeProduct = _data["unitOfExchangeProduct"];
            this.producer = _data["producer"];
            this.erroR_DESCRIPTION = _data["erroR_DESCRIPTION"];
            this.no = _data["no"];
            this.invetoryGroupName = _data["invetoryGroupName"];
            this.catalogName = _data["catalogName"];
            this.qtyStr = _data["qtyStr"];
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.unitPriceStr = _data["unitPriceStr"];
            this.taxPriceStr = _data["taxPriceStr"];
            this.salesAmount = _data["salesAmount"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PrcContractTemplateImportDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrcContractTemplateImportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appendixId"] = this.appendixId;
        data["contractId"] = this.contractId;
        data["contractNo"] = this.contractNo;
        data["contractAppendixNo"] = this.contractAppendixNo;
        data["itemId"] = this.itemId;
        data["partNo"] = this.partNo;
        data["partName"] = this.partName;
        data["partNameSupplier"] = this.partNameSupplier;
        data["unitPrice"] = this.unitPrice;
        data["currency"] = this.currency;
        data["taxPrice"] = this.taxPrice;
        data["qty"] = this.qty;
        data["currencyCode"] = this.currencyCode;
        data["unitOfMeasureId"] = this.unitOfMeasureId;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["catalogId"] = this.catalogId;
        data["length"] = this.length;
        data["width"] = this.width;
        data["height"] = this.height;
        data["unitLength"] = this.unitLength;
        data["unitWidth"] = this.unitWidth;
        data["unitHeight"] = this.unitHeight;
        data["weight"] = this.weight;
        data["unitWeight"] = this.unitWeight;
        data["coo"] = this.coo;
        data["material"] = this.material;
        data["unitOfProduct"] = this.unitOfProduct;
        data["unitOfExchangeProduct"] = this.unitOfExchangeProduct;
        data["producer"] = this.producer;
        data["erroR_DESCRIPTION"] = this.erroR_DESCRIPTION;
        data["no"] = this.no;
        data["invetoryGroupName"] = this.invetoryGroupName;
        data["catalogName"] = this.catalogName;
        data["qtyStr"] = this.qtyStr;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["unitPriceStr"] = this.unitPriceStr;
        data["taxPriceStr"] = this.taxPriceStr;
        data["salesAmount"] = this.salesAmount;
        data["description"] = this.description;
        return data;
    }
}

export interface IPrcContractTemplateImportDto {
    appendixId: number | undefined;
    contractId: number | undefined;
    contractNo: string | undefined;
    contractAppendixNo: string | undefined;
    itemId: number | undefined;
    partNo: string | undefined;
    partName: string | undefined;
    partNameSupplier: string | undefined;
    unitPrice: number | undefined;
    currency: string | undefined;
    taxPrice: number | undefined;
    qty: number | undefined;
    currencyCode: string | undefined;
    unitOfMeasureId: number | undefined;
    inventoryGroupId: number | undefined;
    catalogId: number | undefined;
    length: string | undefined;
    width: string | undefined;
    height: string | undefined;
    unitLength: string | undefined;
    unitWidth: string | undefined;
    unitHeight: string | undefined;
    weight: string | undefined;
    unitWeight: string | undefined;
    coo: string | undefined;
    material: string | undefined;
    unitOfProduct: string | undefined;
    unitOfExchangeProduct: string | undefined;
    producer: string | undefined;
    erroR_DESCRIPTION: string | undefined;
    no: string | undefined;
    invetoryGroupName: string | undefined;
    catalogName: string | undefined;
    qtyStr: string | undefined;
    unitOfMeasure: string | undefined;
    unitPriceStr: string | undefined;
    taxPriceStr: string | undefined;
    salesAmount: string | undefined;
    description: string | undefined;
}

export class PrcContractTemplateInsertDto implements IPrcContractTemplateInsertDto {
    p_appendix_no!: string | undefined;
    dto!: PrcContractTemplateDto;
    listAppendix!: PrcAppendixContractDto[] | undefined;
    listItems!: PrcContractTemplateImportDto[] | undefined;

    constructor(data?: IPrcContractTemplateInsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.p_appendix_no = _data["p_appendix_no"];
            this.dto = _data["dto"] ? PrcContractTemplateDto.fromJS(_data["dto"]) : <any>undefined;
            if (Array.isArray(_data["listAppendix"])) {
                this.listAppendix = [] as any;
                for (let item of _data["listAppendix"])
                    this.listAppendix!.push(PrcAppendixContractDto.fromJS(item));
            }
            if (Array.isArray(_data["listItems"])) {
                this.listItems = [] as any;
                for (let item of _data["listItems"])
                    this.listItems!.push(PrcContractTemplateImportDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PrcContractTemplateInsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrcContractTemplateInsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["p_appendix_no"] = this.p_appendix_no;
        data["dto"] = this.dto ? this.dto.toJSON() : <any>undefined;
        if (Array.isArray(this.listAppendix)) {
            data["listAppendix"] = [];
            for (let item of this.listAppendix)
                data["listAppendix"].push(item.toJSON());
        }
        if (Array.isArray(this.listItems)) {
            data["listItems"] = [];
            for (let item of this.listItems)
                data["listItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPrcContractTemplateInsertDto {
    p_appendix_no: string | undefined;
    dto: PrcContractTemplateDto;
    listAppendix: PrcAppendixContractDto[] | undefined;
    listItems: PrcContractTemplateImportDto[] | undefined;
}

export class PrcContractTemplateInsertOutputDto implements IPrcContractTemplateInsertOutputDto {
    contractId!: number | undefined;
    appendixId!: number[] | undefined;

    constructor(data?: IPrcContractTemplateInsertOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractId = _data["contractId"];
            if (Array.isArray(_data["appendixId"])) {
                this.appendixId = [] as any;
                for (let item of _data["appendixId"])
                    this.appendixId!.push(item);
            }
        }
    }

    static fromJS(data: any): PrcContractTemplateInsertOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrcContractTemplateInsertOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractId"] = this.contractId;
        if (Array.isArray(this.appendixId)) {
            data["appendixId"] = [];
            for (let item of this.appendixId)
                data["appendixId"].push(item);
        }
        return data;
    }
}

export interface IPrcContractTemplateInsertOutputDto {
    contractId: number | undefined;
    appendixId: number[] | undefined;
}

export class PrcAppendixContractInsertDto implements IPrcAppendixContractInsertDto {
    isInsertIttems!: boolean;
    dtoAppendix!: PrcAppendixContractDto;
    listItems!: PrcContractTemplateImportDto[] | undefined;

    constructor(data?: IPrcAppendixContractInsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isInsertIttems = _data["isInsertIttems"];
            this.dtoAppendix = _data["dtoAppendix"] ? PrcAppendixContractDto.fromJS(_data["dtoAppendix"]) : <any>undefined;
            if (Array.isArray(_data["listItems"])) {
                this.listItems = [] as any;
                for (let item of _data["listItems"])
                    this.listItems!.push(PrcContractTemplateImportDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PrcAppendixContractInsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrcAppendixContractInsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isInsertIttems"] = this.isInsertIttems;
        data["dtoAppendix"] = this.dtoAppendix ? this.dtoAppendix.toJSON() : <any>undefined;
        if (Array.isArray(this.listItems)) {
            data["listItems"] = [];
            for (let item of this.listItems)
                data["listItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPrcAppendixContractInsertDto {
    isInsertIttems: boolean;
    dtoAppendix: PrcAppendixContractDto;
    listItems: PrcContractTemplateImportDto[] | undefined;
}

export class PrcContractTemplateImportMultipleDto implements IPrcContractTemplateImportMultipleDto {
    listContract!: PrcContractTemplateDto[] | undefined;
    listItems!: PrcContractTemplateImportDto[] | undefined;

    constructor(data?: IPrcContractTemplateImportMultipleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listContract"])) {
                this.listContract = [] as any;
                for (let item of _data["listContract"])
                    this.listContract!.push(PrcContractTemplateDto.fromJS(item));
            }
            if (Array.isArray(_data["listItems"])) {
                this.listItems = [] as any;
                for (let item of _data["listItems"])
                    this.listItems!.push(PrcContractTemplateImportDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PrcContractTemplateImportMultipleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrcContractTemplateImportMultipleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listContract)) {
            data["listContract"] = [];
            for (let item of this.listContract)
                data["listContract"].push(item.toJSON());
        }
        if (Array.isArray(this.listItems)) {
            data["listItems"] = [];
            for (let item of this.listItems)
                data["listItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPrcContractTemplateImportMultipleDto {
    listContract: PrcContractTemplateDto[] | undefined;
    listItems: PrcContractTemplateImportDto[] | undefined;
}

export class InputContractBackdateDto implements IInputContractBackdateDto {
    id!: number;
    expiryBackdate!: number | undefined;
    noteOfBackdate!: string | undefined;

    constructor(data?: IInputContractBackdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.expiryBackdate = _data["expiryBackdate"];
            this.noteOfBackdate = _data["noteOfBackdate"];
        }
    }

    static fromJS(data: any): InputContractBackdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputContractBackdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["expiryBackdate"] = this.expiryBackdate;
        data["noteOfBackdate"] = this.noteOfBackdate;
        return data;
    }
}

export interface IInputContractBackdateDto {
    id: number;
    expiryBackdate: number | undefined;
    noteOfBackdate: string | undefined;
}

export class PaymentPrepaymentDto implements IPaymentPrepaymentDto {
    id!: number;
    poNo!: string | undefined;
    vendorId!: number | undefined;
    vendorSiteId!: number | undefined;
    amount!: number | undefined;
    advancedDate!: DateTime | undefined;
    isPaymentAdded!: boolean;
    isAppliedInvoice!: boolean;
    supplierName!: string | undefined;
    poHeaderId!: number | undefined;
    invoiceNum!: string | undefined;
    invoiceDate!: DateTime | undefined;
    paymentId!: number | undefined;
    paymentNo!: string | undefined;
    paymentRequestDate!: DateTime | undefined;

    constructor(data?: IPaymentPrepaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.poNo = _data["poNo"];
            this.vendorId = _data["vendorId"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.amount = _data["amount"];
            this.advancedDate = _data["advancedDate"] ? DateTime.fromISO(_data["advancedDate"].toString()) : <any>undefined;
            this.isPaymentAdded = _data["isPaymentAdded"];
            this.isAppliedInvoice = _data["isAppliedInvoice"];
            this.supplierName = _data["supplierName"];
            this.poHeaderId = _data["poHeaderId"];
            this.invoiceNum = _data["invoiceNum"];
            this.invoiceDate = _data["invoiceDate"] ? DateTime.fromISO(_data["invoiceDate"].toString()) : <any>undefined;
            this.paymentId = _data["paymentId"];
            this.paymentNo = _data["paymentNo"];
            this.paymentRequestDate = _data["paymentRequestDate"] ? DateTime.fromISO(_data["paymentRequestDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PaymentPrepaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentPrepaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["poNo"] = this.poNo;
        data["vendorId"] = this.vendorId;
        data["vendorSiteId"] = this.vendorSiteId;
        data["amount"] = this.amount;
        data["advancedDate"] = this.advancedDate ? this.advancedDate.toString() : <any>undefined;
        data["isPaymentAdded"] = this.isPaymentAdded;
        data["isAppliedInvoice"] = this.isAppliedInvoice;
        data["supplierName"] = this.supplierName;
        data["poHeaderId"] = this.poHeaderId;
        data["invoiceNum"] = this.invoiceNum;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toString() : <any>undefined;
        data["paymentId"] = this.paymentId;
        data["paymentNo"] = this.paymentNo;
        data["paymentRequestDate"] = this.paymentRequestDate ? this.paymentRequestDate.toString() : <any>undefined;
        return data;
    }
}

export interface IPaymentPrepaymentDto {
    id: number;
    poNo: string | undefined;
    vendorId: number | undefined;
    vendorSiteId: number | undefined;
    amount: number | undefined;
    advancedDate: DateTime | undefined;
    isPaymentAdded: boolean;
    isAppliedInvoice: boolean;
    supplierName: string | undefined;
    poHeaderId: number | undefined;
    invoiceNum: string | undefined;
    invoiceDate: DateTime | undefined;
    paymentId: number | undefined;
    paymentNo: string | undefined;
    paymentRequestDate: DateTime | undefined;
}

export class PagedResultDtoOfPaymentPrepaymentDto implements IPagedResultDtoOfPaymentPrepaymentDto {
    totalCount!: number;
    items!: PaymentPrepaymentDto[] | undefined;

    constructor(data?: IPagedResultDtoOfPaymentPrepaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PaymentPrepaymentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPaymentPrepaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPaymentPrepaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfPaymentPrepaymentDto {
    totalCount: number;
    items: PaymentPrepaymentDto[] | undefined;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    isPhoneNumberConfirmed!: boolean;
    timezone!: string | undefined;
    qrCodeSetupImageUrl!: string | undefined;
    isGoogleAuthenticatorEnabled!: boolean;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.isPhoneNumberConfirmed = _data["isPhoneNumberConfirmed"];
            this.timezone = _data["timezone"];
            this.qrCodeSetupImageUrl = _data["qrCodeSetupImageUrl"];
            this.isGoogleAuthenticatorEnabled = _data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data;
    }
}

export interface ICurrentUserProfileEditDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    timezone: string | undefined;
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean;
}

export class UpdateGoogleAuthenticatorKeyOutput implements IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl!: string | undefined;

    constructor(data?: IUpdateGoogleAuthenticatorKeyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.qrCodeSetupImageUrl = _data["qrCodeSetupImageUrl"];
        }
    }

    static fromJS(data: any): UpdateGoogleAuthenticatorKeyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        return data;
    }
}

export interface IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;
}

export class SendVerificationSmsInputDto implements ISendVerificationSmsInputDto {
    phoneNumber!: string | undefined;

    constructor(data?: ISendVerificationSmsInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): SendVerificationSmsInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendVerificationSmsInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface ISendVerificationSmsInputDto {
    phoneNumber: string | undefined;
}

export class VerifySmsCodeInputDto implements IVerifySmsCodeInputDto {
    code!: string | undefined;
    phoneNumber!: string | undefined;

    constructor(data?: IVerifySmsCodeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): VerifySmsCodeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifySmsCodeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface IVerifySmsCodeInputDto {
    code: string | undefined;
    phoneNumber: string | undefined;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword!: string;
    newPassword!: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordInput {
    currentPassword: string;
    newPassword: string;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
    fileToken!: string | undefined;
    x!: number;
    y!: number;
    width!: number;
    height!: number;
    useGravatarProfilePicture!: boolean;

    constructor(data?: IUpdateProfilePictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileToken = _data["fileToken"];
            this.x = _data["x"];
            this.y = _data["y"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.useGravatarProfilePicture = _data["useGravatarProfilePicture"];
        }
    }

    static fromJS(data: any): UpdateProfilePictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfilePictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileToken"] = this.fileToken;
        data["x"] = this.x;
        data["y"] = this.y;
        data["width"] = this.width;
        data["height"] = this.height;
        data["useGravatarProfilePicture"] = this.useGravatarProfilePicture;
        return data;
    }
}

export interface IUpdateProfilePictureInput {
    fileToken: string | undefined;
    x: number;
    y: number;
    width: number;
    height: number;
    useGravatarProfilePicture: boolean;
}

export class GetPasswordComplexitySettingOutput implements IGetPasswordComplexitySettingOutput {
    setting!: PasswordComplexitySetting;

    constructor(data?: IGetPasswordComplexitySettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setting = _data["setting"] ? PasswordComplexitySetting.fromJS(_data["setting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPasswordComplexitySettingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPasswordComplexitySettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting;
}

export class GetProfilePictureOutput implements IGetProfilePictureOutput {
    profilePicture!: string | undefined;

    constructor(data?: IGetProfilePictureOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.profilePicture = _data["profilePicture"];
        }
    }

    static fromJS(data: any): GetProfilePictureOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfilePictureOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePicture"] = this.profilePicture;
        return data;
    }
}

export interface IGetProfilePictureOutput {
    profilePicture: string | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName!: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class BmsMstProjectCodeDto implements IBmsMstProjectCodeDto {
    id!: number;
    periodVersionName!: string | undefined;
    periodName!: string | undefined;
    segment1Name!: string | undefined;
    segment2Name!: string | undefined;
    codeProject!: string | undefined;

    constructor(data?: IBmsMstProjectCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.periodVersionName = _data["periodVersionName"];
            this.periodName = _data["periodName"];
            this.segment1Name = _data["segment1Name"];
            this.segment2Name = _data["segment2Name"];
            this.codeProject = _data["codeProject"];
        }
    }

    static fromJS(data: any): BmsMstProjectCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new BmsMstProjectCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["periodVersionName"] = this.periodVersionName;
        data["periodName"] = this.periodName;
        data["segment1Name"] = this.segment1Name;
        data["segment2Name"] = this.segment2Name;
        data["codeProject"] = this.codeProject;
        return data;
    }
}

export interface IBmsMstProjectCodeDto {
    id: number;
    periodVersionName: string | undefined;
    periodName: string | undefined;
    segment1Name: string | undefined;
    segment2Name: string | undefined;
    codeProject: string | undefined;
}

export class PagedResultDtoOfBmsMstProjectCodeDto implements IPagedResultDtoOfBmsMstProjectCodeDto {
    totalCount!: number;
    items!: BmsMstProjectCodeDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBmsMstProjectCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BmsMstProjectCodeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBmsMstProjectCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBmsMstProjectCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBmsMstProjectCodeDto {
    totalCount: number;
    items: BmsMstProjectCodeDto[] | undefined;
}

export class InputProjectCodeDto implements IInputProjectCodeDto {
    id!: number;
    periodVersionId!: number;
    periodId!: number;
    segment1Id!: number;
    segment2Id!: number;
    codeProject!: string | undefined;

    constructor(data?: IInputProjectCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.periodVersionId = _data["periodVersionId"];
            this.periodId = _data["periodId"];
            this.segment1Id = _data["segment1Id"];
            this.segment2Id = _data["segment2Id"];
            this.codeProject = _data["codeProject"];
        }
    }

    static fromJS(data: any): InputProjectCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputProjectCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["periodVersionId"] = this.periodVersionId;
        data["periodId"] = this.periodId;
        data["segment1Id"] = this.segment1Id;
        data["segment2Id"] = this.segment2Id;
        data["codeProject"] = this.codeProject;
        return data;
    }
}

export interface IInputProjectCodeDto {
    id: number;
    periodVersionId: number;
    periodId: number;
    segment1Id: number;
    segment2Id: number;
    codeProject: string | undefined;
}

export class ValProjectCodeDto implements IValProjectCodeDto {
    name!: string | undefined;
    code!: string | undefined;

    constructor(data?: IValProjectCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): ValProjectCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValProjectCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IValProjectCodeDto {
    name: string | undefined;
    code: string | undefined;
}

export class SaveMultipleProjectCodeDto implements ISaveMultipleProjectCodeDto {
    periodVersionId!: number;
    periodId!: number;
    listSegment1Id!: MstSegment1Dto[] | undefined;
    listSegment2Id!: MstSegment2Dto[] | undefined;

    constructor(data?: ISaveMultipleProjectCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.periodVersionId = _data["periodVersionId"];
            this.periodId = _data["periodId"];
            if (Array.isArray(_data["listSegment1Id"])) {
                this.listSegment1Id = [] as any;
                for (let item of _data["listSegment1Id"])
                    this.listSegment1Id!.push(MstSegment1Dto.fromJS(item));
            }
            if (Array.isArray(_data["listSegment2Id"])) {
                this.listSegment2Id = [] as any;
                for (let item of _data["listSegment2Id"])
                    this.listSegment2Id!.push(MstSegment2Dto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SaveMultipleProjectCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaveMultipleProjectCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["periodVersionId"] = this.periodVersionId;
        data["periodId"] = this.periodId;
        if (Array.isArray(this.listSegment1Id)) {
            data["listSegment1Id"] = [];
            for (let item of this.listSegment1Id)
                data["listSegment1Id"].push(item.toJSON());
        }
        if (Array.isArray(this.listSegment2Id)) {
            data["listSegment2Id"] = [];
            for (let item of this.listSegment2Id)
                data["listSegment2Id"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISaveMultipleProjectCodeDto {
    periodVersionId: number;
    periodId: number;
    listSegment1Id: MstSegment1Dto[] | undefined;
    listSegment2Id: MstSegment2Dto[] | undefined;
}

export class ValProjectCodeMultipleSave implements IValProjectCodeMultipleSave {
    valSeg1Required!: boolean;
    valSeg2Required!: boolean;

    constructor(data?: IValProjectCodeMultipleSave) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.valSeg1Required = _data["valSeg1Required"];
            this.valSeg2Required = _data["valSeg2Required"];
        }
    }

    static fromJS(data: any): ValProjectCodeMultipleSave {
        data = typeof data === 'object' ? data : {};
        let result = new ValProjectCodeMultipleSave();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["valSeg1Required"] = this.valSeg1Required;
        data["valSeg2Required"] = this.valSeg2Required;
        return data;
    }
}

export interface IValProjectCodeMultipleSave {
    valSeg1Required: boolean;
    valSeg2Required: boolean;
}

export class InputPurchaseOrdersDistributionsDto implements IInputPurchaseOrdersDistributionsDto {
    id!: number;
    codeCombinationId!: number | undefined;
    prRequisitionDistributionId!: number | undefined;
    deliverToLocationId!: number | undefined;
    deliverToPersonId!: number | undefined;
    quantityOrdered!: number | undefined;
    destinationTypeCode!: string | undefined;
    destinationOrganizationId!: number | undefined;
    distributionNum!: number | undefined;
    destinationSubinventory!: string | undefined;
    glDate!: DateTime | undefined;
    poChargeAccount!: string | undefined;
    destinationChargeAccount!: string | undefined;

    constructor(data?: IInputPurchaseOrdersDistributionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.codeCombinationId = _data["codeCombinationId"];
            this.prRequisitionDistributionId = _data["prRequisitionDistributionId"];
            this.deliverToLocationId = _data["deliverToLocationId"];
            this.deliverToPersonId = _data["deliverToPersonId"];
            this.quantityOrdered = _data["quantityOrdered"];
            this.destinationTypeCode = _data["destinationTypeCode"];
            this.destinationOrganizationId = _data["destinationOrganizationId"];
            this.distributionNum = _data["distributionNum"];
            this.destinationSubinventory = _data["destinationSubinventory"];
            this.glDate = _data["glDate"] ? DateTime.fromISO(_data["glDate"].toString()) : <any>undefined;
            this.poChargeAccount = _data["poChargeAccount"];
            this.destinationChargeAccount = _data["destinationChargeAccount"];
        }
    }

    static fromJS(data: any): InputPurchaseOrdersDistributionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputPurchaseOrdersDistributionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["codeCombinationId"] = this.codeCombinationId;
        data["prRequisitionDistributionId"] = this.prRequisitionDistributionId;
        data["deliverToLocationId"] = this.deliverToLocationId;
        data["deliverToPersonId"] = this.deliverToPersonId;
        data["quantityOrdered"] = this.quantityOrdered;
        data["destinationTypeCode"] = this.destinationTypeCode;
        data["destinationOrganizationId"] = this.destinationOrganizationId;
        data["distributionNum"] = this.distributionNum;
        data["destinationSubinventory"] = this.destinationSubinventory;
        data["glDate"] = this.glDate ? this.glDate.toString() : <any>undefined;
        data["poChargeAccount"] = this.poChargeAccount;
        data["destinationChargeAccount"] = this.destinationChargeAccount;
        return data;
    }
}

export interface IInputPurchaseOrdersDistributionsDto {
    id: number;
    codeCombinationId: number | undefined;
    prRequisitionDistributionId: number | undefined;
    deliverToLocationId: number | undefined;
    deliverToPersonId: number | undefined;
    quantityOrdered: number | undefined;
    destinationTypeCode: string | undefined;
    destinationOrganizationId: number | undefined;
    distributionNum: number | undefined;
    destinationSubinventory: string | undefined;
    glDate: DateTime | undefined;
    poChargeAccount: string | undefined;
    destinationChargeAccount: string | undefined;
}

export class InputPurchaseOrdersShipmentsDto implements IInputPurchaseOrdersShipmentsDto {
    id!: number;
    poHeaderId!: number | undefined;
    poLineId!: number | undefined;
    quantity!: number | undefined;
    unitMeasLookupCode!: string | undefined;
    shipToLocationId!: number | undefined;
    needByDate!: DateTime | undefined;
    promisedDate!: DateTime | undefined;
    shipToOrganizationId!: number | undefined;
    priceOverride!: number | undefined;
    shipmentNum!: number | undefined;
    listDistributions!: InputPurchaseOrdersDistributionsDto[] | undefined;

    constructor(data?: IInputPurchaseOrdersShipmentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.poHeaderId = _data["poHeaderId"];
            this.poLineId = _data["poLineId"];
            this.quantity = _data["quantity"];
            this.unitMeasLookupCode = _data["unitMeasLookupCode"];
            this.shipToLocationId = _data["shipToLocationId"];
            this.needByDate = _data["needByDate"] ? DateTime.fromISO(_data["needByDate"].toString()) : <any>undefined;
            this.promisedDate = _data["promisedDate"] ? DateTime.fromISO(_data["promisedDate"].toString()) : <any>undefined;
            this.shipToOrganizationId = _data["shipToOrganizationId"];
            this.priceOverride = _data["priceOverride"];
            this.shipmentNum = _data["shipmentNum"];
            if (Array.isArray(_data["listDistributions"])) {
                this.listDistributions = [] as any;
                for (let item of _data["listDistributions"])
                    this.listDistributions!.push(InputPurchaseOrdersDistributionsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InputPurchaseOrdersShipmentsDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputPurchaseOrdersShipmentsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["poHeaderId"] = this.poHeaderId;
        data["poLineId"] = this.poLineId;
        data["quantity"] = this.quantity;
        data["unitMeasLookupCode"] = this.unitMeasLookupCode;
        data["shipToLocationId"] = this.shipToLocationId;
        data["needByDate"] = this.needByDate ? this.needByDate.toString() : <any>undefined;
        data["promisedDate"] = this.promisedDate ? this.promisedDate.toString() : <any>undefined;
        data["shipToOrganizationId"] = this.shipToOrganizationId;
        data["priceOverride"] = this.priceOverride;
        data["shipmentNum"] = this.shipmentNum;
        if (Array.isArray(this.listDistributions)) {
            data["listDistributions"] = [];
            for (let item of this.listDistributions)
                data["listDistributions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInputPurchaseOrdersShipmentsDto {
    id: number;
    poHeaderId: number | undefined;
    poLineId: number | undefined;
    quantity: number | undefined;
    unitMeasLookupCode: string | undefined;
    shipToLocationId: number | undefined;
    needByDate: DateTime | undefined;
    promisedDate: DateTime | undefined;
    shipToOrganizationId: number | undefined;
    priceOverride: number | undefined;
    shipmentNum: number | undefined;
    listDistributions: InputPurchaseOrdersDistributionsDto[] | undefined;
}

export class InputPurchaseOrderLinesDto implements IInputPurchaseOrderLinesDto {
    id!: number;
    poHeaderId!: number | undefined;
    lineTypeId!: number | undefined;
    itemId!: number | undefined;
    categoryId!: number | undefined;
    urLineId!: number | undefined;
    partName!: string | undefined;
    unitMeasLookupCode!: string | undefined;
    unitPrice!: number | undefined;
    foreignPrice!: number | undefined;
    quantity!: number | undefined;
    lineNum!: number | undefined;
    needByDate!: DateTime | undefined;
    promisedDate!: DateTime | undefined;
    glDate!: DateTime | undefined;
    guranteeTerm!: string | undefined;
    poChargeAccount!: string | undefined;
    attribute9!: string | undefined;
    attribute12!: string | undefined;
    listPOShipments!: InputPurchaseOrdersShipmentsDto[] | undefined;

    constructor(data?: IInputPurchaseOrderLinesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.poHeaderId = _data["poHeaderId"];
            this.lineTypeId = _data["lineTypeId"];
            this.itemId = _data["itemId"];
            this.categoryId = _data["categoryId"];
            this.urLineId = _data["urLineId"];
            this.partName = _data["partName"];
            this.unitMeasLookupCode = _data["unitMeasLookupCode"];
            this.unitPrice = _data["unitPrice"];
            this.foreignPrice = _data["foreignPrice"];
            this.quantity = _data["quantity"];
            this.lineNum = _data["lineNum"];
            this.needByDate = _data["needByDate"] ? DateTime.fromISO(_data["needByDate"].toString()) : <any>undefined;
            this.promisedDate = _data["promisedDate"] ? DateTime.fromISO(_data["promisedDate"].toString()) : <any>undefined;
            this.glDate = _data["glDate"] ? DateTime.fromISO(_data["glDate"].toString()) : <any>undefined;
            this.guranteeTerm = _data["guranteeTerm"];
            this.poChargeAccount = _data["poChargeAccount"];
            this.attribute9 = _data["attribute9"];
            this.attribute12 = _data["attribute12"];
            if (Array.isArray(_data["listPOShipments"])) {
                this.listPOShipments = [] as any;
                for (let item of _data["listPOShipments"])
                    this.listPOShipments!.push(InputPurchaseOrdersShipmentsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InputPurchaseOrderLinesDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputPurchaseOrderLinesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["poHeaderId"] = this.poHeaderId;
        data["lineTypeId"] = this.lineTypeId;
        data["itemId"] = this.itemId;
        data["categoryId"] = this.categoryId;
        data["urLineId"] = this.urLineId;
        data["partName"] = this.partName;
        data["unitMeasLookupCode"] = this.unitMeasLookupCode;
        data["unitPrice"] = this.unitPrice;
        data["foreignPrice"] = this.foreignPrice;
        data["quantity"] = this.quantity;
        data["lineNum"] = this.lineNum;
        data["needByDate"] = this.needByDate ? this.needByDate.toString() : <any>undefined;
        data["promisedDate"] = this.promisedDate ? this.promisedDate.toString() : <any>undefined;
        data["glDate"] = this.glDate ? this.glDate.toString() : <any>undefined;
        data["guranteeTerm"] = this.guranteeTerm;
        data["poChargeAccount"] = this.poChargeAccount;
        data["attribute9"] = this.attribute9;
        data["attribute12"] = this.attribute12;
        if (Array.isArray(this.listPOShipments)) {
            data["listPOShipments"] = [];
            for (let item of this.listPOShipments)
                data["listPOShipments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInputPurchaseOrderLinesDto {
    id: number;
    poHeaderId: number | undefined;
    lineTypeId: number | undefined;
    itemId: number | undefined;
    categoryId: number | undefined;
    urLineId: number | undefined;
    partName: string | undefined;
    unitMeasLookupCode: string | undefined;
    unitPrice: number | undefined;
    foreignPrice: number | undefined;
    quantity: number | undefined;
    lineNum: number | undefined;
    needByDate: DateTime | undefined;
    promisedDate: DateTime | undefined;
    glDate: DateTime | undefined;
    guranteeTerm: string | undefined;
    poChargeAccount: string | undefined;
    attribute9: string | undefined;
    attribute12: string | undefined;
    listPOShipments: InputPurchaseOrdersShipmentsDto[] | undefined;
}

export class InputPurchaseOrdersHeadersDto implements IInputPurchaseOrdersHeadersDto {
    id!: number;
    typeLookupCode!: string | undefined;
    segment1!: string | undefined;
    vendorId!: number | undefined;
    vendorSiteId!: number | undefined;
    vendorContactId!: number | undefined;
    shipToLocationId!: number | undefined;
    billToLocationId!: number | undefined;
    currencyCode!: string | undefined;
    authorizationStatus!: string | undefined;
    approvedFlag!: string | undefined;
    description!: string | undefined;
    chargeAccount!: string | undefined;
    poRef!: string | undefined;
    totalPrice!: number | undefined;
    orgId!: number | undefined;
    inventoryGroupId!: number | undefined;
    buyerId!: number | undefined;
    termsId!: number | undefined;
    personSigningId!: number | undefined;
    attribute10!: DateTime | undefined;
    rateDate!: DateTime | undefined;
    contractExpirationDate!: DateTime | undefined;
    termDescription!: string | undefined;
    attribute11!: string | undefined;
    attribute12!: string | undefined;
    attribute13!: string | undefined;
    attribute14!: string | undefined;
    attribute15!: string | undefined;
    isPrepayReceipt!: boolean | undefined;
    inputPurchaseOrderLinesDtos!: InputPurchaseOrderLinesDto[] | undefined;

    constructor(data?: IInputPurchaseOrdersHeadersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeLookupCode = _data["typeLookupCode"];
            this.segment1 = _data["segment1"];
            this.vendorId = _data["vendorId"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.vendorContactId = _data["vendorContactId"];
            this.shipToLocationId = _data["shipToLocationId"];
            this.billToLocationId = _data["billToLocationId"];
            this.currencyCode = _data["currencyCode"];
            this.authorizationStatus = _data["authorizationStatus"];
            this.approvedFlag = _data["approvedFlag"];
            this.description = _data["description"];
            this.chargeAccount = _data["chargeAccount"];
            this.poRef = _data["poRef"];
            this.totalPrice = _data["totalPrice"];
            this.orgId = _data["orgId"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.buyerId = _data["buyerId"];
            this.termsId = _data["termsId"];
            this.personSigningId = _data["personSigningId"];
            this.attribute10 = _data["attribute10"] ? DateTime.fromISO(_data["attribute10"].toString()) : <any>undefined;
            this.rateDate = _data["rateDate"] ? DateTime.fromISO(_data["rateDate"].toString()) : <any>undefined;
            this.contractExpirationDate = _data["contractExpirationDate"] ? DateTime.fromISO(_data["contractExpirationDate"].toString()) : <any>undefined;
            this.termDescription = _data["termDescription"];
            this.attribute11 = _data["attribute11"];
            this.attribute12 = _data["attribute12"];
            this.attribute13 = _data["attribute13"];
            this.attribute14 = _data["attribute14"];
            this.attribute15 = _data["attribute15"];
            this.isPrepayReceipt = _data["isPrepayReceipt"];
            if (Array.isArray(_data["inputPurchaseOrderLinesDtos"])) {
                this.inputPurchaseOrderLinesDtos = [] as any;
                for (let item of _data["inputPurchaseOrderLinesDtos"])
                    this.inputPurchaseOrderLinesDtos!.push(InputPurchaseOrderLinesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InputPurchaseOrdersHeadersDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputPurchaseOrdersHeadersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeLookupCode"] = this.typeLookupCode;
        data["segment1"] = this.segment1;
        data["vendorId"] = this.vendorId;
        data["vendorSiteId"] = this.vendorSiteId;
        data["vendorContactId"] = this.vendorContactId;
        data["shipToLocationId"] = this.shipToLocationId;
        data["billToLocationId"] = this.billToLocationId;
        data["currencyCode"] = this.currencyCode;
        data["authorizationStatus"] = this.authorizationStatus;
        data["approvedFlag"] = this.approvedFlag;
        data["description"] = this.description;
        data["chargeAccount"] = this.chargeAccount;
        data["poRef"] = this.poRef;
        data["totalPrice"] = this.totalPrice;
        data["orgId"] = this.orgId;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["buyerId"] = this.buyerId;
        data["termsId"] = this.termsId;
        data["personSigningId"] = this.personSigningId;
        data["attribute10"] = this.attribute10 ? this.attribute10.toString() : <any>undefined;
        data["rateDate"] = this.rateDate ? this.rateDate.toString() : <any>undefined;
        data["contractExpirationDate"] = this.contractExpirationDate ? this.contractExpirationDate.toString() : <any>undefined;
        data["termDescription"] = this.termDescription;
        data["attribute11"] = this.attribute11;
        data["attribute12"] = this.attribute12;
        data["attribute13"] = this.attribute13;
        data["attribute14"] = this.attribute14;
        data["attribute15"] = this.attribute15;
        data["isPrepayReceipt"] = this.isPrepayReceipt;
        if (Array.isArray(this.inputPurchaseOrderLinesDtos)) {
            data["inputPurchaseOrderLinesDtos"] = [];
            for (let item of this.inputPurchaseOrderLinesDtos)
                data["inputPurchaseOrderLinesDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInputPurchaseOrdersHeadersDto {
    id: number;
    typeLookupCode: string | undefined;
    segment1: string | undefined;
    vendorId: number | undefined;
    vendorSiteId: number | undefined;
    vendorContactId: number | undefined;
    shipToLocationId: number | undefined;
    billToLocationId: number | undefined;
    currencyCode: string | undefined;
    authorizationStatus: string | undefined;
    approvedFlag: string | undefined;
    description: string | undefined;
    chargeAccount: string | undefined;
    poRef: string | undefined;
    totalPrice: number | undefined;
    orgId: number | undefined;
    inventoryGroupId: number | undefined;
    buyerId: number | undefined;
    termsId: number | undefined;
    personSigningId: number | undefined;
    attribute10: DateTime | undefined;
    rateDate: DateTime | undefined;
    contractExpirationDate: DateTime | undefined;
    termDescription: string | undefined;
    attribute11: string | undefined;
    attribute12: string | undefined;
    attribute13: string | undefined;
    attribute14: string | undefined;
    attribute15: string | undefined;
    isPrepayReceipt: boolean | undefined;
    inputPurchaseOrderLinesDtos: InputPurchaseOrderLinesDto[] | undefined;
}

export class GetPurchaseRequestForCreatePODto implements IGetPurchaseRequestForCreatePODto {
    id!: number | undefined;
    requisitionNo!: string | undefined;
    prRequisitionHeaderId!: number | undefined;
    lineTypeId!: number | undefined;
    itemId!: number | undefined;
    inventoryGroupId!: number | undefined;
    partNo!: string | undefined;
    partName!: string | undefined;
    productGroupName!: string | undefined;
    categoryId!: number | undefined;
    category!: string | undefined;
    unitMeasLookupCode!: string | undefined;
    uomCode!: string | undefined;
    needByDate!: DateTime | undefined;
    rateDate!: DateTime | undefined;
    quantity!: number | undefined;
    currencyId!: number | undefined;
    unitPrice!: number | undefined;
    foreignPrice!: number | undefined;
    destinationTypeCode!: string | undefined;
    destinationOrganizationId!: number | undefined;
    requesterName!: string | undefined;
    destinationSubinventory!: string | undefined;
    suggestedVendorName!: string | undefined;
    vendorId!: number | undefined;
    suggestedVendorLocation!: string | undefined;
    vendorSiteId!: number | undefined;
    deliverToLocationId!: number | undefined;
    toPersonId!: number | undefined;
    locationCode!: string | undefined;
    addressSupplier!: string | undefined;
    suggestedVendorContact!: string | undefined;
    suggestedVendorPhone!: string | undefined;
    requestNote!: string | undefined;
    replyNote!: string | undefined;
    amount!: number;
    attribute9!: string | undefined;
    attribute12!: string | undefined;
    attribute14!: string | undefined;
    attribute15!: string | undefined;
    attribute10!: string | undefined;
    attribute11!: string | undefined;
    totalCount!: number;
    chargeAccount!: string | undefined;

    constructor(data?: IGetPurchaseRequestForCreatePODto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.requisitionNo = _data["requisitionNo"];
            this.prRequisitionHeaderId = _data["prRequisitionHeaderId"];
            this.lineTypeId = _data["lineTypeId"];
            this.itemId = _data["itemId"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.partNo = _data["partNo"];
            this.partName = _data["partName"];
            this.productGroupName = _data["productGroupName"];
            this.categoryId = _data["categoryId"];
            this.category = _data["category"];
            this.unitMeasLookupCode = _data["unitMeasLookupCode"];
            this.uomCode = _data["uomCode"];
            this.needByDate = _data["needByDate"] ? DateTime.fromISO(_data["needByDate"].toString()) : <any>undefined;
            this.rateDate = _data["rateDate"] ? DateTime.fromISO(_data["rateDate"].toString()) : <any>undefined;
            this.quantity = _data["quantity"];
            this.currencyId = _data["currencyId"];
            this.unitPrice = _data["unitPrice"];
            this.foreignPrice = _data["foreignPrice"];
            this.destinationTypeCode = _data["destinationTypeCode"];
            this.destinationOrganizationId = _data["destinationOrganizationId"];
            this.requesterName = _data["requesterName"];
            this.destinationSubinventory = _data["destinationSubinventory"];
            this.suggestedVendorName = _data["suggestedVendorName"];
            this.vendorId = _data["vendorId"];
            this.suggestedVendorLocation = _data["suggestedVendorLocation"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.deliverToLocationId = _data["deliverToLocationId"];
            this.toPersonId = _data["toPersonId"];
            this.locationCode = _data["locationCode"];
            this.addressSupplier = _data["addressSupplier"];
            this.suggestedVendorContact = _data["suggestedVendorContact"];
            this.suggestedVendorPhone = _data["suggestedVendorPhone"];
            this.requestNote = _data["requestNote"];
            this.replyNote = _data["replyNote"];
            this.amount = _data["amount"];
            this.attribute9 = _data["attribute9"];
            this.attribute12 = _data["attribute12"];
            this.attribute14 = _data["attribute14"];
            this.attribute15 = _data["attribute15"];
            this.attribute10 = _data["attribute10"];
            this.attribute11 = _data["attribute11"];
            this.totalCount = _data["totalCount"];
            this.chargeAccount = _data["chargeAccount"];
        }
    }

    static fromJS(data: any): GetPurchaseRequestForCreatePODto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPurchaseRequestForCreatePODto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["requisitionNo"] = this.requisitionNo;
        data["prRequisitionHeaderId"] = this.prRequisitionHeaderId;
        data["lineTypeId"] = this.lineTypeId;
        data["itemId"] = this.itemId;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["partNo"] = this.partNo;
        data["partName"] = this.partName;
        data["productGroupName"] = this.productGroupName;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category;
        data["unitMeasLookupCode"] = this.unitMeasLookupCode;
        data["uomCode"] = this.uomCode;
        data["needByDate"] = this.needByDate ? this.needByDate.toString() : <any>undefined;
        data["rateDate"] = this.rateDate ? this.rateDate.toString() : <any>undefined;
        data["quantity"] = this.quantity;
        data["currencyId"] = this.currencyId;
        data["unitPrice"] = this.unitPrice;
        data["foreignPrice"] = this.foreignPrice;
        data["destinationTypeCode"] = this.destinationTypeCode;
        data["destinationOrganizationId"] = this.destinationOrganizationId;
        data["requesterName"] = this.requesterName;
        data["destinationSubinventory"] = this.destinationSubinventory;
        data["suggestedVendorName"] = this.suggestedVendorName;
        data["vendorId"] = this.vendorId;
        data["suggestedVendorLocation"] = this.suggestedVendorLocation;
        data["vendorSiteId"] = this.vendorSiteId;
        data["deliverToLocationId"] = this.deliverToLocationId;
        data["toPersonId"] = this.toPersonId;
        data["locationCode"] = this.locationCode;
        data["addressSupplier"] = this.addressSupplier;
        data["suggestedVendorContact"] = this.suggestedVendorContact;
        data["suggestedVendorPhone"] = this.suggestedVendorPhone;
        data["requestNote"] = this.requestNote;
        data["replyNote"] = this.replyNote;
        data["amount"] = this.amount;
        data["attribute9"] = this.attribute9;
        data["attribute12"] = this.attribute12;
        data["attribute14"] = this.attribute14;
        data["attribute15"] = this.attribute15;
        data["attribute10"] = this.attribute10;
        data["attribute11"] = this.attribute11;
        data["totalCount"] = this.totalCount;
        data["chargeAccount"] = this.chargeAccount;
        return data;
    }
}

export interface IGetPurchaseRequestForCreatePODto {
    id: number | undefined;
    requisitionNo: string | undefined;
    prRequisitionHeaderId: number | undefined;
    lineTypeId: number | undefined;
    itemId: number | undefined;
    inventoryGroupId: number | undefined;
    partNo: string | undefined;
    partName: string | undefined;
    productGroupName: string | undefined;
    categoryId: number | undefined;
    category: string | undefined;
    unitMeasLookupCode: string | undefined;
    uomCode: string | undefined;
    needByDate: DateTime | undefined;
    rateDate: DateTime | undefined;
    quantity: number | undefined;
    currencyId: number | undefined;
    unitPrice: number | undefined;
    foreignPrice: number | undefined;
    destinationTypeCode: string | undefined;
    destinationOrganizationId: number | undefined;
    requesterName: string | undefined;
    destinationSubinventory: string | undefined;
    suggestedVendorName: string | undefined;
    vendorId: number | undefined;
    suggestedVendorLocation: string | undefined;
    vendorSiteId: number | undefined;
    deliverToLocationId: number | undefined;
    toPersonId: number | undefined;
    locationCode: string | undefined;
    addressSupplier: string | undefined;
    suggestedVendorContact: string | undefined;
    suggestedVendorPhone: string | undefined;
    requestNote: string | undefined;
    replyNote: string | undefined;
    amount: number;
    attribute9: string | undefined;
    attribute12: string | undefined;
    attribute14: string | undefined;
    attribute15: string | undefined;
    attribute10: string | undefined;
    attribute11: string | undefined;
    totalCount: number;
    chargeAccount: string | undefined;
}

export class GetListPoNumberDto implements IGetListPoNumberDto {
    id!: number;
    poNumber!: string | undefined;

    constructor(data?: IGetListPoNumberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.poNumber = _data["poNumber"];
        }
    }

    static fromJS(data: any): GetListPoNumberDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetListPoNumberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["poNumber"] = this.poNumber;
        return data;
    }
}

export interface IGetListPoNumberDto {
    id: number;
    poNumber: string | undefined;
}

export class GetAllUserRequestForPrDto implements IGetAllUserRequestForPrDto {
    requisitionNo!: string | undefined;
    userRequestName!: string | undefined;
    productGroupName!: string | undefined;
    itemId!: number | undefined;
    purchasePurposeId!: number | undefined;
    partNo!: string | undefined;
    partName!: string | undefined;
    categoryId!: number | undefined;
    category!: string | undefined;
    budgetCode!: string | undefined;
    categorySetname!: string | undefined;
    uom!: string | undefined;
    quantity!: number;
    unitPrice!: number;
    exchangeUnitPrice!: number;
    needByDate!: DateTime | undefined;
    documentDate!: DateTime | undefined;
    amount!: number;
    currencyId!: number | undefined;
    currency!: string | undefined;
    requesterId!: number | undefined;
    lineTypeId!: number | undefined;
    inventoryGroupId!: number | undefined;
    requesterName!: string | undefined;
    vendorId!: number | undefined;
    vendorName!: string | undefined;
    suggestedVendorName!: string | undefined;
    vendorSiteId!: number | undefined;
    suggestedVendorLocation!: string | undefined;
    buyerId!: number | undefined;
    buyer!: string | undefined;
    totalCount!: number;
    id!: number;

    constructor(data?: IGetAllUserRequestForPrDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requisitionNo = _data["requisitionNo"];
            this.userRequestName = _data["userRequestName"];
            this.productGroupName = _data["productGroupName"];
            this.itemId = _data["itemId"];
            this.purchasePurposeId = _data["purchasePurposeId"];
            this.partNo = _data["partNo"];
            this.partName = _data["partName"];
            this.categoryId = _data["categoryId"];
            this.category = _data["category"];
            this.budgetCode = _data["budgetCode"];
            this.categorySetname = _data["categorySetname"];
            this.uom = _data["uom"];
            this.quantity = _data["quantity"];
            this.unitPrice = _data["unitPrice"];
            this.exchangeUnitPrice = _data["exchangeUnitPrice"];
            this.needByDate = _data["needByDate"] ? DateTime.fromISO(_data["needByDate"].toString()) : <any>undefined;
            this.documentDate = _data["documentDate"] ? DateTime.fromISO(_data["documentDate"].toString()) : <any>undefined;
            this.amount = _data["amount"];
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"];
            this.requesterId = _data["requesterId"];
            this.lineTypeId = _data["lineTypeId"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.requesterName = _data["requesterName"];
            this.vendorId = _data["vendorId"];
            this.vendorName = _data["vendorName"];
            this.suggestedVendorName = _data["suggestedVendorName"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.suggestedVendorLocation = _data["suggestedVendorLocation"];
            this.buyerId = _data["buyerId"];
            this.buyer = _data["buyer"];
            this.totalCount = _data["totalCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAllUserRequestForPrDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllUserRequestForPrDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requisitionNo"] = this.requisitionNo;
        data["userRequestName"] = this.userRequestName;
        data["productGroupName"] = this.productGroupName;
        data["itemId"] = this.itemId;
        data["purchasePurposeId"] = this.purchasePurposeId;
        data["partNo"] = this.partNo;
        data["partName"] = this.partName;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category;
        data["budgetCode"] = this.budgetCode;
        data["categorySetname"] = this.categorySetname;
        data["uom"] = this.uom;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["exchangeUnitPrice"] = this.exchangeUnitPrice;
        data["needByDate"] = this.needByDate ? this.needByDate.toString() : <any>undefined;
        data["documentDate"] = this.documentDate ? this.documentDate.toString() : <any>undefined;
        data["amount"] = this.amount;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency;
        data["requesterId"] = this.requesterId;
        data["lineTypeId"] = this.lineTypeId;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["requesterName"] = this.requesterName;
        data["vendorId"] = this.vendorId;
        data["vendorName"] = this.vendorName;
        data["suggestedVendorName"] = this.suggestedVendorName;
        data["vendorSiteId"] = this.vendorSiteId;
        data["suggestedVendorLocation"] = this.suggestedVendorLocation;
        data["buyerId"] = this.buyerId;
        data["buyer"] = this.buyer;
        data["totalCount"] = this.totalCount;
        data["id"] = this.id;
        return data;
    }
}

export interface IGetAllUserRequestForPrDto {
    requisitionNo: string | undefined;
    userRequestName: string | undefined;
    productGroupName: string | undefined;
    itemId: number | undefined;
    purchasePurposeId: number | undefined;
    partNo: string | undefined;
    partName: string | undefined;
    categoryId: number | undefined;
    category: string | undefined;
    budgetCode: string | undefined;
    categorySetname: string | undefined;
    uom: string | undefined;
    quantity: number;
    unitPrice: number;
    exchangeUnitPrice: number;
    needByDate: DateTime | undefined;
    documentDate: DateTime | undefined;
    amount: number;
    currencyId: number | undefined;
    currency: string | undefined;
    requesterId: number | undefined;
    lineTypeId: number | undefined;
    inventoryGroupId: number | undefined;
    requesterName: string | undefined;
    vendorId: number | undefined;
    vendorName: string | undefined;
    suggestedVendorName: string | undefined;
    vendorSiteId: number | undefined;
    suggestedVendorLocation: string | undefined;
    buyerId: number | undefined;
    buyer: string | undefined;
    totalCount: number;
    id: number;
}

export class GetPurchaseOrdersDto implements IGetPurchaseOrdersDto {
    id!: number;
    ordersNo!: string | undefined;
    description!: string | undefined;
    typeLookupCode!: string | undefined;
    authorizationStatus!: string | undefined;
    departmentApprovalName!: string | undefined;
    checkBudgetStatus!: string | undefined;
    noteOfSupplier!: string | undefined;
    orderDate!: DateTime | undefined;
    supplierName!: string | undefined;
    vendorSiteCode!: string | undefined;
    currency!: string | undefined;
    productGroupName!: string | undefined;
    requestNote!: string | undefined;
    replyNote!: string | undefined;
    isVendorConfirm!: string | undefined;
    amount!: number;
    creatorUserId!: number;
    buyerName!: string | undefined;
    totalCount!: number;

    constructor(data?: IGetPurchaseOrdersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ordersNo = _data["ordersNo"];
            this.description = _data["description"];
            this.typeLookupCode = _data["typeLookupCode"];
            this.authorizationStatus = _data["authorizationStatus"];
            this.departmentApprovalName = _data["departmentApprovalName"];
            this.checkBudgetStatus = _data["checkBudgetStatus"];
            this.noteOfSupplier = _data["noteOfSupplier"];
            this.orderDate = _data["orderDate"] ? DateTime.fromISO(_data["orderDate"].toString()) : <any>undefined;
            this.supplierName = _data["supplierName"];
            this.vendorSiteCode = _data["vendorSiteCode"];
            this.currency = _data["currency"];
            this.productGroupName = _data["productGroupName"];
            this.requestNote = _data["requestNote"];
            this.replyNote = _data["replyNote"];
            this.isVendorConfirm = _data["isVendorConfirm"];
            this.amount = _data["amount"];
            this.creatorUserId = _data["creatorUserId"];
            this.buyerName = _data["buyerName"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetPurchaseOrdersDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPurchaseOrdersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ordersNo"] = this.ordersNo;
        data["description"] = this.description;
        data["typeLookupCode"] = this.typeLookupCode;
        data["authorizationStatus"] = this.authorizationStatus;
        data["departmentApprovalName"] = this.departmentApprovalName;
        data["checkBudgetStatus"] = this.checkBudgetStatus;
        data["noteOfSupplier"] = this.noteOfSupplier;
        data["orderDate"] = this.orderDate ? this.orderDate.toString() : <any>undefined;
        data["supplierName"] = this.supplierName;
        data["vendorSiteCode"] = this.vendorSiteCode;
        data["currency"] = this.currency;
        data["productGroupName"] = this.productGroupName;
        data["requestNote"] = this.requestNote;
        data["replyNote"] = this.replyNote;
        data["isVendorConfirm"] = this.isVendorConfirm;
        data["amount"] = this.amount;
        data["creatorUserId"] = this.creatorUserId;
        data["buyerName"] = this.buyerName;
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IGetPurchaseOrdersDto {
    id: number;
    ordersNo: string | undefined;
    description: string | undefined;
    typeLookupCode: string | undefined;
    authorizationStatus: string | undefined;
    departmentApprovalName: string | undefined;
    checkBudgetStatus: string | undefined;
    noteOfSupplier: string | undefined;
    orderDate: DateTime | undefined;
    supplierName: string | undefined;
    vendorSiteCode: string | undefined;
    currency: string | undefined;
    productGroupName: string | undefined;
    requestNote: string | undefined;
    replyNote: string | undefined;
    isVendorConfirm: string | undefined;
    amount: number;
    creatorUserId: number;
    buyerName: string | undefined;
    totalCount: number;
}

export class PagedResultDtoOfGetPurchaseOrdersDto implements IPagedResultDtoOfGetPurchaseOrdersDto {
    totalCount!: number;
    items!: GetPurchaseOrdersDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPurchaseOrdersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetPurchaseOrdersDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPurchaseOrdersDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPurchaseOrdersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetPurchaseOrdersDto {
    totalCount: number;
    items: GetPurchaseOrdersDto[] | undefined;
}

export class GetAllPurchaseOrdersAttachmentsForViewDto implements IGetAllPurchaseOrdersAttachmentsForViewDto {
    id!: number;
    fileName!: string | undefined;
    serverFileName!: string | undefined;
    rootPath!: string | undefined;
    uploadTime!: DateTime | undefined;

    constructor(data?: IGetAllPurchaseOrdersAttachmentsForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileName = _data["fileName"];
            this.serverFileName = _data["serverFileName"];
            this.rootPath = _data["rootPath"];
            this.uploadTime = _data["uploadTime"] ? DateTime.fromISO(_data["uploadTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAllPurchaseOrdersAttachmentsForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllPurchaseOrdersAttachmentsForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileName"] = this.fileName;
        data["serverFileName"] = this.serverFileName;
        data["rootPath"] = this.rootPath;
        data["uploadTime"] = this.uploadTime ? this.uploadTime.toString() : <any>undefined;
        return data;
    }
}

export interface IGetAllPurchaseOrdersAttachmentsForViewDto {
    id: number;
    fileName: string | undefined;
    serverFileName: string | undefined;
    rootPath: string | undefined;
    uploadTime: DateTime | undefined;
}

export class GetPoDistributionsForEditDto implements IGetPoDistributionsForEditDto {
    id!: number;
    destinationTypeCode!: string | undefined;
    deliverToPersonId!: number | undefined;
    prRequisitionDistributionId!: number | undefined;
    requesterName!: string | undefined;
    deliverToLocationId!: number | undefined;
    deliverTo!: string | undefined;
    subinventory!: string | undefined;
    quantityOrdered!: number | undefined;
    poChargeAccount!: string | undefined;
    destinationChargeAccount!: string | undefined;
    recoveryRate!: number | undefined;
    distributionNum!: number | undefined;
    glDate!: DateTime | undefined;

    constructor(data?: IGetPoDistributionsForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.destinationTypeCode = _data["destinationTypeCode"];
            this.deliverToPersonId = _data["deliverToPersonId"];
            this.prRequisitionDistributionId = _data["prRequisitionDistributionId"];
            this.requesterName = _data["requesterName"];
            this.deliverToLocationId = _data["deliverToLocationId"];
            this.deliverTo = _data["deliverTo"];
            this.subinventory = _data["subinventory"];
            this.quantityOrdered = _data["quantityOrdered"];
            this.poChargeAccount = _data["poChargeAccount"];
            this.destinationChargeAccount = _data["destinationChargeAccount"];
            this.recoveryRate = _data["recoveryRate"];
            this.distributionNum = _data["distributionNum"];
            this.glDate = _data["glDate"] ? DateTime.fromISO(_data["glDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPoDistributionsForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPoDistributionsForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["destinationTypeCode"] = this.destinationTypeCode;
        data["deliverToPersonId"] = this.deliverToPersonId;
        data["prRequisitionDistributionId"] = this.prRequisitionDistributionId;
        data["requesterName"] = this.requesterName;
        data["deliverToLocationId"] = this.deliverToLocationId;
        data["deliverTo"] = this.deliverTo;
        data["subinventory"] = this.subinventory;
        data["quantityOrdered"] = this.quantityOrdered;
        data["poChargeAccount"] = this.poChargeAccount;
        data["destinationChargeAccount"] = this.destinationChargeAccount;
        data["recoveryRate"] = this.recoveryRate;
        data["distributionNum"] = this.distributionNum;
        data["glDate"] = this.glDate ? this.glDate.toString() : <any>undefined;
        return data;
    }
}

export interface IGetPoDistributionsForEditDto {
    id: number;
    destinationTypeCode: string | undefined;
    deliverToPersonId: number | undefined;
    prRequisitionDistributionId: number | undefined;
    requesterName: string | undefined;
    deliverToLocationId: number | undefined;
    deliverTo: string | undefined;
    subinventory: string | undefined;
    quantityOrdered: number | undefined;
    poChargeAccount: string | undefined;
    destinationChargeAccount: string | undefined;
    recoveryRate: number | undefined;
    distributionNum: number | undefined;
    glDate: DateTime | undefined;
}

export class GetPoShipmentsByLineForEditDto implements IGetPoShipmentsByLineForEditDto {
    id!: number;
    shipToOrganizationId!: number | undefined;
    shipToLocationId!: number | undefined;
    shipTo!: string | undefined;
    uom!: string | undefined;
    unitMeasLookupCode!: string | undefined;
    quantity!: number | undefined;
    shipmentNum!: number | undefined;
    promisedDate!: DateTime | undefined;
    needByDate!: DateTime | undefined;
    originalDate!: DateTime | undefined;
    noteForReceiver!: string | undefined;
    countryOfOrigin!: string | undefined;
    chargeAccount!: string | undefined;
    listDistributions!: GetPoDistributionsForEditDto[] | undefined;

    constructor(data?: IGetPoShipmentsByLineForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.shipToOrganizationId = _data["shipToOrganizationId"];
            this.shipToLocationId = _data["shipToLocationId"];
            this.shipTo = _data["shipTo"];
            this.uom = _data["uom"];
            this.unitMeasLookupCode = _data["unitMeasLookupCode"];
            this.quantity = _data["quantity"];
            this.shipmentNum = _data["shipmentNum"];
            this.promisedDate = _data["promisedDate"] ? DateTime.fromISO(_data["promisedDate"].toString()) : <any>undefined;
            this.needByDate = _data["needByDate"] ? DateTime.fromISO(_data["needByDate"].toString()) : <any>undefined;
            this.originalDate = _data["originalDate"] ? DateTime.fromISO(_data["originalDate"].toString()) : <any>undefined;
            this.noteForReceiver = _data["noteForReceiver"];
            this.countryOfOrigin = _data["countryOfOrigin"];
            this.chargeAccount = _data["chargeAccount"];
            if (Array.isArray(_data["listDistributions"])) {
                this.listDistributions = [] as any;
                for (let item of _data["listDistributions"])
                    this.listDistributions!.push(GetPoDistributionsForEditDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPoShipmentsByLineForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPoShipmentsByLineForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["shipToOrganizationId"] = this.shipToOrganizationId;
        data["shipToLocationId"] = this.shipToLocationId;
        data["shipTo"] = this.shipTo;
        data["uom"] = this.uom;
        data["unitMeasLookupCode"] = this.unitMeasLookupCode;
        data["quantity"] = this.quantity;
        data["shipmentNum"] = this.shipmentNum;
        data["promisedDate"] = this.promisedDate ? this.promisedDate.toString() : <any>undefined;
        data["needByDate"] = this.needByDate ? this.needByDate.toString() : <any>undefined;
        data["originalDate"] = this.originalDate ? this.originalDate.toString() : <any>undefined;
        data["noteForReceiver"] = this.noteForReceiver;
        data["countryOfOrigin"] = this.countryOfOrigin;
        data["chargeAccount"] = this.chargeAccount;
        if (Array.isArray(this.listDistributions)) {
            data["listDistributions"] = [];
            for (let item of this.listDistributions)
                data["listDistributions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetPoShipmentsByLineForEditDto {
    id: number;
    shipToOrganizationId: number | undefined;
    shipToLocationId: number | undefined;
    shipTo: string | undefined;
    uom: string | undefined;
    unitMeasLookupCode: string | undefined;
    quantity: number | undefined;
    shipmentNum: number | undefined;
    promisedDate: DateTime | undefined;
    needByDate: DateTime | undefined;
    originalDate: DateTime | undefined;
    noteForReceiver: string | undefined;
    countryOfOrigin: string | undefined;
    chargeAccount: string | undefined;
    listDistributions: GetPoDistributionsForEditDto[] | undefined;
}

export class GetPoLinesForEditDtocs implements IGetPoLinesForEditDtocs {
    id!: number;
    lineTypeId!: number | undefined;
    itemId!: number | undefined;
    partNo!: string | undefined;
    partName!: string | undefined;
    quantity!: number | undefined;
    unitMeasLookupCode!: string | undefined;
    uom!: string | undefined;
    unitPrice!: number | undefined;
    foreignPrice!: number | undefined;
    categoryId!: number | undefined;
    lineNum!: number | undefined;
    category!: string | undefined;
    needByDate!: DateTime | undefined;
    amount!: number | undefined;
    promisedDate!: DateTime | undefined;
    guranteeTerm!: string | undefined;
    glDate!: DateTime | undefined;
    poChargeAccount!: string | undefined;
    listPOShipments!: GetPoShipmentsByLineForEditDto[] | undefined;

    constructor(data?: IGetPoLinesForEditDtocs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.lineTypeId = _data["lineTypeId"];
            this.itemId = _data["itemId"];
            this.partNo = _data["partNo"];
            this.partName = _data["partName"];
            this.quantity = _data["quantity"];
            this.unitMeasLookupCode = _data["unitMeasLookupCode"];
            this.uom = _data["uom"];
            this.unitPrice = _data["unitPrice"];
            this.foreignPrice = _data["foreignPrice"];
            this.categoryId = _data["categoryId"];
            this.lineNum = _data["lineNum"];
            this.category = _data["category"];
            this.needByDate = _data["needByDate"] ? DateTime.fromISO(_data["needByDate"].toString()) : <any>undefined;
            this.amount = _data["amount"];
            this.promisedDate = _data["promisedDate"] ? DateTime.fromISO(_data["promisedDate"].toString()) : <any>undefined;
            this.guranteeTerm = _data["guranteeTerm"];
            this.glDate = _data["glDate"] ? DateTime.fromISO(_data["glDate"].toString()) : <any>undefined;
            this.poChargeAccount = _data["poChargeAccount"];
            if (Array.isArray(_data["listPOShipments"])) {
                this.listPOShipments = [] as any;
                for (let item of _data["listPOShipments"])
                    this.listPOShipments!.push(GetPoShipmentsByLineForEditDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPoLinesForEditDtocs {
        data = typeof data === 'object' ? data : {};
        let result = new GetPoLinesForEditDtocs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lineTypeId"] = this.lineTypeId;
        data["itemId"] = this.itemId;
        data["partNo"] = this.partNo;
        data["partName"] = this.partName;
        data["quantity"] = this.quantity;
        data["unitMeasLookupCode"] = this.unitMeasLookupCode;
        data["uom"] = this.uom;
        data["unitPrice"] = this.unitPrice;
        data["foreignPrice"] = this.foreignPrice;
        data["categoryId"] = this.categoryId;
        data["lineNum"] = this.lineNum;
        data["category"] = this.category;
        data["needByDate"] = this.needByDate ? this.needByDate.toString() : <any>undefined;
        data["amount"] = this.amount;
        data["promisedDate"] = this.promisedDate ? this.promisedDate.toString() : <any>undefined;
        data["guranteeTerm"] = this.guranteeTerm;
        data["glDate"] = this.glDate ? this.glDate.toString() : <any>undefined;
        data["poChargeAccount"] = this.poChargeAccount;
        if (Array.isArray(this.listPOShipments)) {
            data["listPOShipments"] = [];
            for (let item of this.listPOShipments)
                data["listPOShipments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetPoLinesForEditDtocs {
    id: number;
    lineTypeId: number | undefined;
    itemId: number | undefined;
    partNo: string | undefined;
    partName: string | undefined;
    quantity: number | undefined;
    unitMeasLookupCode: string | undefined;
    uom: string | undefined;
    unitPrice: number | undefined;
    foreignPrice: number | undefined;
    categoryId: number | undefined;
    lineNum: number | undefined;
    category: string | undefined;
    needByDate: DateTime | undefined;
    amount: number | undefined;
    promisedDate: DateTime | undefined;
    guranteeTerm: string | undefined;
    glDate: DateTime | undefined;
    poChargeAccount: string | undefined;
    listPOShipments: GetPoShipmentsByLineForEditDto[] | undefined;
}

export class GetPoHeadersForEditDto implements IGetPoHeadersForEditDto {
    id!: number;
    buyerId!: number | undefined;
    buyerName!: string | undefined;
    typeLookupCode!: string | undefined;
    segment1!: string | undefined;
    vendorId!: number | undefined;
    inventoryGroupId!: number | undefined;
    vendorSiteId!: number | undefined;
    vendorContactId!: number | undefined;
    shipToLocationId!: number | undefined;
    billToLocationId!: number | undefined;
    currencyCode!: string | undefined;
    vendorName!: string | undefined;
    shipToLocationName!: string | undefined;
    billToLocationName!: string | undefined;
    poRef!: string | undefined;
    rateDate!: DateTime | undefined;
    authorizationStatus!: string | undefined;
    checkBudgetStatus!: string | undefined;
    approvedFlag!: string | undefined;
    description!: string | undefined;
    chargeAccount!: string | undefined;
    termsId!: number | undefined;
    attribute10!: string | undefined;
    attribute11!: string | undefined;
    attribute12!: string | undefined;
    attribute13!: string | undefined;
    attribute14!: string | undefined;
    attribute15!: string | undefined;
    requestNote!: string | undefined;
    replyNote!: string | undefined;
    isPrepayReceipt!: boolean | undefined;
    attachments!: GetAllPurchaseOrdersAttachmentsForViewDto[] | undefined;
    inputPurchaseOrderLinesDtos!: GetPoLinesForEditDtocs[] | undefined;

    constructor(data?: IGetPoHeadersForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.buyerId = _data["buyerId"];
            this.buyerName = _data["buyerName"];
            this.typeLookupCode = _data["typeLookupCode"];
            this.segment1 = _data["segment1"];
            this.vendorId = _data["vendorId"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.vendorContactId = _data["vendorContactId"];
            this.shipToLocationId = _data["shipToLocationId"];
            this.billToLocationId = _data["billToLocationId"];
            this.currencyCode = _data["currencyCode"];
            this.vendorName = _data["vendorName"];
            this.shipToLocationName = _data["shipToLocationName"];
            this.billToLocationName = _data["billToLocationName"];
            this.poRef = _data["poRef"];
            this.rateDate = _data["rateDate"] ? DateTime.fromISO(_data["rateDate"].toString()) : <any>undefined;
            this.authorizationStatus = _data["authorizationStatus"];
            this.checkBudgetStatus = _data["checkBudgetStatus"];
            this.approvedFlag = _data["approvedFlag"];
            this.description = _data["description"];
            this.chargeAccount = _data["chargeAccount"];
            this.termsId = _data["termsId"];
            this.attribute10 = _data["attribute10"];
            this.attribute11 = _data["attribute11"];
            this.attribute12 = _data["attribute12"];
            this.attribute13 = _data["attribute13"];
            this.attribute14 = _data["attribute14"];
            this.attribute15 = _data["attribute15"];
            this.requestNote = _data["requestNote"];
            this.replyNote = _data["replyNote"];
            this.isPrepayReceipt = _data["isPrepayReceipt"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(GetAllPurchaseOrdersAttachmentsForViewDto.fromJS(item));
            }
            if (Array.isArray(_data["inputPurchaseOrderLinesDtos"])) {
                this.inputPurchaseOrderLinesDtos = [] as any;
                for (let item of _data["inputPurchaseOrderLinesDtos"])
                    this.inputPurchaseOrderLinesDtos!.push(GetPoLinesForEditDtocs.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPoHeadersForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPoHeadersForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["buyerId"] = this.buyerId;
        data["buyerName"] = this.buyerName;
        data["typeLookupCode"] = this.typeLookupCode;
        data["segment1"] = this.segment1;
        data["vendorId"] = this.vendorId;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["vendorSiteId"] = this.vendorSiteId;
        data["vendorContactId"] = this.vendorContactId;
        data["shipToLocationId"] = this.shipToLocationId;
        data["billToLocationId"] = this.billToLocationId;
        data["currencyCode"] = this.currencyCode;
        data["vendorName"] = this.vendorName;
        data["shipToLocationName"] = this.shipToLocationName;
        data["billToLocationName"] = this.billToLocationName;
        data["poRef"] = this.poRef;
        data["rateDate"] = this.rateDate ? this.rateDate.toString() : <any>undefined;
        data["authorizationStatus"] = this.authorizationStatus;
        data["checkBudgetStatus"] = this.checkBudgetStatus;
        data["approvedFlag"] = this.approvedFlag;
        data["description"] = this.description;
        data["chargeAccount"] = this.chargeAccount;
        data["termsId"] = this.termsId;
        data["attribute10"] = this.attribute10;
        data["attribute11"] = this.attribute11;
        data["attribute12"] = this.attribute12;
        data["attribute13"] = this.attribute13;
        data["attribute14"] = this.attribute14;
        data["attribute15"] = this.attribute15;
        data["requestNote"] = this.requestNote;
        data["replyNote"] = this.replyNote;
        data["isPrepayReceipt"] = this.isPrepayReceipt;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        if (Array.isArray(this.inputPurchaseOrderLinesDtos)) {
            data["inputPurchaseOrderLinesDtos"] = [];
            for (let item of this.inputPurchaseOrderLinesDtos)
                data["inputPurchaseOrderLinesDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetPoHeadersForEditDto {
    id: number;
    buyerId: number | undefined;
    buyerName: string | undefined;
    typeLookupCode: string | undefined;
    segment1: string | undefined;
    vendorId: number | undefined;
    inventoryGroupId: number | undefined;
    vendorSiteId: number | undefined;
    vendorContactId: number | undefined;
    shipToLocationId: number | undefined;
    billToLocationId: number | undefined;
    currencyCode: string | undefined;
    vendorName: string | undefined;
    shipToLocationName: string | undefined;
    billToLocationName: string | undefined;
    poRef: string | undefined;
    rateDate: DateTime | undefined;
    authorizationStatus: string | undefined;
    checkBudgetStatus: string | undefined;
    approvedFlag: string | undefined;
    description: string | undefined;
    chargeAccount: string | undefined;
    termsId: number | undefined;
    attribute10: string | undefined;
    attribute11: string | undefined;
    attribute12: string | undefined;
    attribute13: string | undefined;
    attribute14: string | undefined;
    attribute15: string | undefined;
    requestNote: string | undefined;
    replyNote: string | undefined;
    isPrepayReceipt: boolean | undefined;
    attachments: GetAllPurchaseOrdersAttachmentsForViewDto[] | undefined;
    inputPurchaseOrderLinesDtos: GetPoLinesForEditDtocs[] | undefined;
}

export class GetContractForCreatePoDto implements IGetContractForCreatePoDto {
    id!: number | undefined;
    contractNo!: string | undefined;
    lineTypeId!: number | undefined;
    itemId!: number | undefined;
    inventoryGroupId!: number | undefined;
    partNo!: string | undefined;
    partName!: string | undefined;
    categoryId!: number | undefined;
    category!: string | undefined;
    unitMeasLookupCode!: string | undefined;
    uomCode!: string | undefined;
    needByDate!: DateTime | undefined;
    quantity!: number | undefined;
    unitPrice!: number | undefined;
    destinationTypeCode!: string | undefined;
    destinationOrganizationId!: number | undefined;
    requesterName!: string | undefined;
    destinationSubinventory!: string | undefined;
    suggestedVendorName!: string | undefined;
    vendorId!: number | undefined;
    suggestedVendorLocation!: string | undefined;
    vendorSiteId!: number | undefined;
    deliverToLocationId!: number | undefined;
    toPersonId!: number | undefined;
    locationCode!: string | undefined;
    addressSupplier!: string | undefined;
    suggestedVendorContact!: string | undefined;
    suggestedVendorPhone!: string | undefined;
    amount!: number;
    totalCount!: number;
    chargeAccount!: string | undefined;

    constructor(data?: IGetContractForCreatePoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contractNo = _data["contractNo"];
            this.lineTypeId = _data["lineTypeId"];
            this.itemId = _data["itemId"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.partNo = _data["partNo"];
            this.partName = _data["partName"];
            this.categoryId = _data["categoryId"];
            this.category = _data["category"];
            this.unitMeasLookupCode = _data["unitMeasLookupCode"];
            this.uomCode = _data["uomCode"];
            this.needByDate = _data["needByDate"] ? DateTime.fromISO(_data["needByDate"].toString()) : <any>undefined;
            this.quantity = _data["quantity"];
            this.unitPrice = _data["unitPrice"];
            this.destinationTypeCode = _data["destinationTypeCode"];
            this.destinationOrganizationId = _data["destinationOrganizationId"];
            this.requesterName = _data["requesterName"];
            this.destinationSubinventory = _data["destinationSubinventory"];
            this.suggestedVendorName = _data["suggestedVendorName"];
            this.vendorId = _data["vendorId"];
            this.suggestedVendorLocation = _data["suggestedVendorLocation"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.deliverToLocationId = _data["deliverToLocationId"];
            this.toPersonId = _data["toPersonId"];
            this.locationCode = _data["locationCode"];
            this.addressSupplier = _data["addressSupplier"];
            this.suggestedVendorContact = _data["suggestedVendorContact"];
            this.suggestedVendorPhone = _data["suggestedVendorPhone"];
            this.amount = _data["amount"];
            this.totalCount = _data["totalCount"];
            this.chargeAccount = _data["chargeAccount"];
        }
    }

    static fromJS(data: any): GetContractForCreatePoDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetContractForCreatePoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contractNo"] = this.contractNo;
        data["lineTypeId"] = this.lineTypeId;
        data["itemId"] = this.itemId;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["partNo"] = this.partNo;
        data["partName"] = this.partName;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category;
        data["unitMeasLookupCode"] = this.unitMeasLookupCode;
        data["uomCode"] = this.uomCode;
        data["needByDate"] = this.needByDate ? this.needByDate.toString() : <any>undefined;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["destinationTypeCode"] = this.destinationTypeCode;
        data["destinationOrganizationId"] = this.destinationOrganizationId;
        data["requesterName"] = this.requesterName;
        data["destinationSubinventory"] = this.destinationSubinventory;
        data["suggestedVendorName"] = this.suggestedVendorName;
        data["vendorId"] = this.vendorId;
        data["suggestedVendorLocation"] = this.suggestedVendorLocation;
        data["vendorSiteId"] = this.vendorSiteId;
        data["deliverToLocationId"] = this.deliverToLocationId;
        data["toPersonId"] = this.toPersonId;
        data["locationCode"] = this.locationCode;
        data["addressSupplier"] = this.addressSupplier;
        data["suggestedVendorContact"] = this.suggestedVendorContact;
        data["suggestedVendorPhone"] = this.suggestedVendorPhone;
        data["amount"] = this.amount;
        data["totalCount"] = this.totalCount;
        data["chargeAccount"] = this.chargeAccount;
        return data;
    }
}

export interface IGetContractForCreatePoDto {
    id: number | undefined;
    contractNo: string | undefined;
    lineTypeId: number | undefined;
    itemId: number | undefined;
    inventoryGroupId: number | undefined;
    partNo: string | undefined;
    partName: string | undefined;
    categoryId: number | undefined;
    category: string | undefined;
    unitMeasLookupCode: string | undefined;
    uomCode: string | undefined;
    needByDate: DateTime | undefined;
    quantity: number | undefined;
    unitPrice: number | undefined;
    destinationTypeCode: string | undefined;
    destinationOrganizationId: number | undefined;
    requesterName: string | undefined;
    destinationSubinventory: string | undefined;
    suggestedVendorName: string | undefined;
    vendorId: number | undefined;
    suggestedVendorLocation: string | undefined;
    vendorSiteId: number | undefined;
    deliverToLocationId: number | undefined;
    toPersonId: number | undefined;
    locationCode: string | undefined;
    addressSupplier: string | undefined;
    suggestedVendorContact: string | undefined;
    suggestedVendorPhone: string | undefined;
    amount: number;
    totalCount: number;
    chargeAccount: string | undefined;
}

export class PagedResultDtoOfGetContractForCreatePoDto implements IPagedResultDtoOfGetContractForCreatePoDto {
    totalCount!: number;
    items!: GetContractForCreatePoDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetContractForCreatePoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetContractForCreatePoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetContractForCreatePoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetContractForCreatePoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetContractForCreatePoDto {
    totalCount: number;
    items: GetContractForCreatePoDto[] | undefined;
}

export class GetListPoForAddPrToPoDto implements IGetListPoForAddPrToPoDto {
    id!: number;
    poNumber!: string | undefined;
    supplierName!: string | undefined;
    descriptions!: string | undefined;

    constructor(data?: IGetListPoForAddPrToPoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.poNumber = _data["poNumber"];
            this.supplierName = _data["supplierName"];
            this.descriptions = _data["descriptions"];
        }
    }

    static fromJS(data: any): GetListPoForAddPrToPoDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetListPoForAddPrToPoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["poNumber"] = this.poNumber;
        data["supplierName"] = this.supplierName;
        data["descriptions"] = this.descriptions;
        return data;
    }
}

export interface IGetListPoForAddPrToPoDto {
    id: number;
    poNumber: string | undefined;
    supplierName: string | undefined;
    descriptions: string | undefined;
}

export class InputSearchPoDto implements IInputSearchPoDto {
    ordersNo!: string | undefined;
    supplierId!: number | undefined;
    billToLocationId!: number | undefined;
    shipToLocationId!: number | undefined;
    inventoryGroupId!: number | undefined;
    buyerId!: number | undefined;
    isInternal!: boolean | undefined;
    status!: string | undefined;
    fromDate!: DateTime | undefined;
    toDate!: DateTime | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IInputSearchPoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ordersNo = _data["ordersNo"];
            this.supplierId = _data["supplierId"];
            this.billToLocationId = _data["billToLocationId"];
            this.shipToLocationId = _data["shipToLocationId"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.buyerId = _data["buyerId"];
            this.isInternal = _data["isInternal"];
            this.status = _data["status"];
            this.fromDate = _data["fromDate"] ? DateTime.fromISO(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? DateTime.fromISO(_data["toDate"].toString()) : <any>undefined;
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): InputSearchPoDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputSearchPoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ordersNo"] = this.ordersNo;
        data["supplierId"] = this.supplierId;
        data["billToLocationId"] = this.billToLocationId;
        data["shipToLocationId"] = this.shipToLocationId;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["buyerId"] = this.buyerId;
        data["isInternal"] = this.isInternal;
        data["status"] = this.status;
        data["fromDate"] = this.fromDate ? this.fromDate.toString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toString() : <any>undefined;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data;
    }
}

export interface IInputSearchPoDto {
    ordersNo: string | undefined;
    supplierId: number | undefined;
    billToLocationId: number | undefined;
    shipToLocationId: number | undefined;
    inventoryGroupId: number | undefined;
    buyerId: number | undefined;
    isInternal: boolean | undefined;
    status: string | undefined;
    fromDate: DateTime | undefined;
    toDate: DateTime | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class GetPurchaseRequestDto implements IGetPurchaseRequestDto {
    id!: number;
    preparerName!: string | undefined;
    requisitionNo!: string | undefined;
    authorizationStatus!: string | undefined;
    description!: string | undefined;
    departmentApprovalName!: string | undefined;
    productGroupName!: string | undefined;
    requestNote!: string | undefined;
    replyNote!: string | undefined;
    status!: string | undefined;
    totalPrice!: number;
    creatorUserId!: number | undefined;
    creationTime!: DateTime;
    currency!: string | undefined;
    totalCount!: number;

    constructor(data?: IGetPurchaseRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.preparerName = _data["preparerName"];
            this.requisitionNo = _data["requisitionNo"];
            this.authorizationStatus = _data["authorizationStatus"];
            this.description = _data["description"];
            this.departmentApprovalName = _data["departmentApprovalName"];
            this.productGroupName = _data["productGroupName"];
            this.requestNote = _data["requestNote"];
            this.replyNote = _data["replyNote"];
            this.status = _data["status"];
            this.totalPrice = _data["totalPrice"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetPurchaseRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPurchaseRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["preparerName"] = this.preparerName;
        data["requisitionNo"] = this.requisitionNo;
        data["authorizationStatus"] = this.authorizationStatus;
        data["description"] = this.description;
        data["departmentApprovalName"] = this.departmentApprovalName;
        data["productGroupName"] = this.productGroupName;
        data["requestNote"] = this.requestNote;
        data["replyNote"] = this.replyNote;
        data["status"] = this.status;
        data["totalPrice"] = this.totalPrice;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["currency"] = this.currency;
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IGetPurchaseRequestDto {
    id: number;
    preparerName: string | undefined;
    requisitionNo: string | undefined;
    authorizationStatus: string | undefined;
    description: string | undefined;
    departmentApprovalName: string | undefined;
    productGroupName: string | undefined;
    requestNote: string | undefined;
    replyNote: string | undefined;
    status: string | undefined;
    totalPrice: number;
    creatorUserId: number | undefined;
    creationTime: DateTime;
    currency: string | undefined;
    totalCount: number;
}

export class PagedResultDtoOfGetPurchaseRequestDto implements IPagedResultDtoOfGetPurchaseRequestDto {
    totalCount!: number;
    items!: GetPurchaseRequestDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPurchaseRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetPurchaseRequestDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPurchaseRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPurchaseRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetPurchaseRequestDto {
    totalCount: number;
    items: GetPurchaseRequestDto[] | undefined;
}

export class GetPurchaseRequestDistributionsDto implements IGetPurchaseRequestDistributionsDto {
    id!: number;
    chargeAccount!: string | undefined;
    recoverRate!: number | undefined;
    quantity!: number | undefined;
    glDate!: DateTime | undefined;
    budgetAccount!: string | undefined;
    accrualAccount!: string | undefined;
    varianceAccount!: string | undefined;

    constructor(data?: IGetPurchaseRequestDistributionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.chargeAccount = _data["chargeAccount"];
            this.recoverRate = _data["recoverRate"];
            this.quantity = _data["quantity"];
            this.glDate = _data["glDate"] ? DateTime.fromISO(_data["glDate"].toString()) : <any>undefined;
            this.budgetAccount = _data["budgetAccount"];
            this.accrualAccount = _data["accrualAccount"];
            this.varianceAccount = _data["varianceAccount"];
        }
    }

    static fromJS(data: any): GetPurchaseRequestDistributionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPurchaseRequestDistributionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["chargeAccount"] = this.chargeAccount;
        data["recoverRate"] = this.recoverRate;
        data["quantity"] = this.quantity;
        data["glDate"] = this.glDate ? this.glDate.toString() : <any>undefined;
        data["budgetAccount"] = this.budgetAccount;
        data["accrualAccount"] = this.accrualAccount;
        data["varianceAccount"] = this.varianceAccount;
        return data;
    }
}

export interface IGetPurchaseRequestDistributionsDto {
    id: number;
    chargeAccount: string | undefined;
    recoverRate: number | undefined;
    quantity: number | undefined;
    glDate: DateTime | undefined;
    budgetAccount: string | undefined;
    accrualAccount: string | undefined;
    varianceAccount: string | undefined;
}

export class InputPurchaseRequestLineDto implements IInputPurchaseRequestLineDto {
    id!: number;
    prRequisitionHeaderId!: number | undefined;
    lineTypeId!: number | undefined;
    itemId!: number | undefined;
    categoryId!: number | undefined;
    urLineId!: number | undefined;
    partName!: string | undefined;
    unitMeasLookupCode!: string | undefined;
    unitPrice!: number | undefined;
    foreignPrice!: number | undefined;
    quantity!: number | undefined;
    needByDate!: DateTime | undefined;
    lineLocationId!: number | undefined;
    destinationTypeCode!: string | undefined;
    destinationOrganizationId!: number | undefined;
    deliverToLocationId!: number | undefined;
    toPersonId!: number | undefined;
    orderTypeLookupCode!: string | undefined;
    purchaseBasis!: string | undefined;
    matchingBasis!: string | undefined;
    sourceTypeCode!: string | undefined;
    suggestedVendorName!: string | undefined;
    suggestedVendorLocation!: string | undefined;
    suggestedVendorContact!: string | undefined;
    suggestedVendorPhone!: string | undefined;
    attribute9!: string | undefined;
    attribute12!: string | undefined;
    attribute14!: string | undefined;
    attribute15!: string | undefined;
    attribute10!: string | undefined;
    attribute11!: string | undefined;
    vendorId!: number | undefined;
    vendorSiteId!: number | undefined;
    distributionsId!: number | undefined;
    chargeAccount!: string | undefined;
    glDate!: DateTime | undefined;
    budgetAccount!: string | undefined;
    accrualAccount!: string | undefined;
    varianceAccount!: string | undefined;
    listDistributions!: GetPurchaseRequestDistributionsDto[] | undefined;

    constructor(data?: IInputPurchaseRequestLineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.prRequisitionHeaderId = _data["prRequisitionHeaderId"];
            this.lineTypeId = _data["lineTypeId"];
            this.itemId = _data["itemId"];
            this.categoryId = _data["categoryId"];
            this.urLineId = _data["urLineId"];
            this.partName = _data["partName"];
            this.unitMeasLookupCode = _data["unitMeasLookupCode"];
            this.unitPrice = _data["unitPrice"];
            this.foreignPrice = _data["foreignPrice"];
            this.quantity = _data["quantity"];
            this.needByDate = _data["needByDate"] ? DateTime.fromISO(_data["needByDate"].toString()) : <any>undefined;
            this.lineLocationId = _data["lineLocationId"];
            this.destinationTypeCode = _data["destinationTypeCode"];
            this.destinationOrganizationId = _data["destinationOrganizationId"];
            this.deliverToLocationId = _data["deliverToLocationId"];
            this.toPersonId = _data["toPersonId"];
            this.orderTypeLookupCode = _data["orderTypeLookupCode"];
            this.purchaseBasis = _data["purchaseBasis"];
            this.matchingBasis = _data["matchingBasis"];
            this.sourceTypeCode = _data["sourceTypeCode"];
            this.suggestedVendorName = _data["suggestedVendorName"];
            this.suggestedVendorLocation = _data["suggestedVendorLocation"];
            this.suggestedVendorContact = _data["suggestedVendorContact"];
            this.suggestedVendorPhone = _data["suggestedVendorPhone"];
            this.attribute9 = _data["attribute9"];
            this.attribute12 = _data["attribute12"];
            this.attribute14 = _data["attribute14"];
            this.attribute15 = _data["attribute15"];
            this.attribute10 = _data["attribute10"];
            this.attribute11 = _data["attribute11"];
            this.vendorId = _data["vendorId"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.distributionsId = _data["distributionsId"];
            this.chargeAccount = _data["chargeAccount"];
            this.glDate = _data["glDate"] ? DateTime.fromISO(_data["glDate"].toString()) : <any>undefined;
            this.budgetAccount = _data["budgetAccount"];
            this.accrualAccount = _data["accrualAccount"];
            this.varianceAccount = _data["varianceAccount"];
            if (Array.isArray(_data["listDistributions"])) {
                this.listDistributions = [] as any;
                for (let item of _data["listDistributions"])
                    this.listDistributions!.push(GetPurchaseRequestDistributionsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InputPurchaseRequestLineDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputPurchaseRequestLineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["prRequisitionHeaderId"] = this.prRequisitionHeaderId;
        data["lineTypeId"] = this.lineTypeId;
        data["itemId"] = this.itemId;
        data["categoryId"] = this.categoryId;
        data["urLineId"] = this.urLineId;
        data["partName"] = this.partName;
        data["unitMeasLookupCode"] = this.unitMeasLookupCode;
        data["unitPrice"] = this.unitPrice;
        data["foreignPrice"] = this.foreignPrice;
        data["quantity"] = this.quantity;
        data["needByDate"] = this.needByDate ? this.needByDate.toString() : <any>undefined;
        data["lineLocationId"] = this.lineLocationId;
        data["destinationTypeCode"] = this.destinationTypeCode;
        data["destinationOrganizationId"] = this.destinationOrganizationId;
        data["deliverToLocationId"] = this.deliverToLocationId;
        data["toPersonId"] = this.toPersonId;
        data["orderTypeLookupCode"] = this.orderTypeLookupCode;
        data["purchaseBasis"] = this.purchaseBasis;
        data["matchingBasis"] = this.matchingBasis;
        data["sourceTypeCode"] = this.sourceTypeCode;
        data["suggestedVendorName"] = this.suggestedVendorName;
        data["suggestedVendorLocation"] = this.suggestedVendorLocation;
        data["suggestedVendorContact"] = this.suggestedVendorContact;
        data["suggestedVendorPhone"] = this.suggestedVendorPhone;
        data["attribute9"] = this.attribute9;
        data["attribute12"] = this.attribute12;
        data["attribute14"] = this.attribute14;
        data["attribute15"] = this.attribute15;
        data["attribute10"] = this.attribute10;
        data["attribute11"] = this.attribute11;
        data["vendorId"] = this.vendorId;
        data["vendorSiteId"] = this.vendorSiteId;
        data["distributionsId"] = this.distributionsId;
        data["chargeAccount"] = this.chargeAccount;
        data["glDate"] = this.glDate ? this.glDate.toString() : <any>undefined;
        data["budgetAccount"] = this.budgetAccount;
        data["accrualAccount"] = this.accrualAccount;
        data["varianceAccount"] = this.varianceAccount;
        if (Array.isArray(this.listDistributions)) {
            data["listDistributions"] = [];
            for (let item of this.listDistributions)
                data["listDistributions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInputPurchaseRequestLineDto {
    id: number;
    prRequisitionHeaderId: number | undefined;
    lineTypeId: number | undefined;
    itemId: number | undefined;
    categoryId: number | undefined;
    urLineId: number | undefined;
    partName: string | undefined;
    unitMeasLookupCode: string | undefined;
    unitPrice: number | undefined;
    foreignPrice: number | undefined;
    quantity: number | undefined;
    needByDate: DateTime | undefined;
    lineLocationId: number | undefined;
    destinationTypeCode: string | undefined;
    destinationOrganizationId: number | undefined;
    deliverToLocationId: number | undefined;
    toPersonId: number | undefined;
    orderTypeLookupCode: string | undefined;
    purchaseBasis: string | undefined;
    matchingBasis: string | undefined;
    sourceTypeCode: string | undefined;
    suggestedVendorName: string | undefined;
    suggestedVendorLocation: string | undefined;
    suggestedVendorContact: string | undefined;
    suggestedVendorPhone: string | undefined;
    attribute9: string | undefined;
    attribute12: string | undefined;
    attribute14: string | undefined;
    attribute15: string | undefined;
    attribute10: string | undefined;
    attribute11: string | undefined;
    vendorId: number | undefined;
    vendorSiteId: number | undefined;
    distributionsId: number | undefined;
    chargeAccount: string | undefined;
    glDate: DateTime | undefined;
    budgetAccount: string | undefined;
    accrualAccount: string | undefined;
    varianceAccount: string | undefined;
    listDistributions: GetPurchaseRequestDistributionsDto[] | undefined;
}

export class InputPurchaseRequestHeaderDto implements IInputPurchaseRequestHeaderDto {
    id!: number;
    prepareId!: number | undefined;
    purchasePurposeId!: number | undefined;
    prepareName!: string | undefined;
    requisitionNo!: string | undefined;
    authorizationStatus!: string | undefined;
    requestId!: number | undefined;
    description!: string | undefined;
    destinationTypeCode!: string | undefined;
    chargeAccount!: string | undefined;
    originalCurrencyCode!: string | undefined;
    inventoryGroupId!: number | undefined;
    destinationOrganizationId!: number | undefined;
    deliverToLocationId!: number | undefined;
    totalPrice!: number | undefined;
    rateDate!: DateTime | undefined;
    currencyRate!: number | undefined;
    inputPurchaseRequestLineDtos!: InputPurchaseRequestLineDto[] | undefined;

    constructor(data?: IInputPurchaseRequestHeaderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.prepareId = _data["prepareId"];
            this.purchasePurposeId = _data["purchasePurposeId"];
            this.prepareName = _data["prepareName"];
            this.requisitionNo = _data["requisitionNo"];
            this.authorizationStatus = _data["authorizationStatus"];
            this.requestId = _data["requestId"];
            this.description = _data["description"];
            this.destinationTypeCode = _data["destinationTypeCode"];
            this.chargeAccount = _data["chargeAccount"];
            this.originalCurrencyCode = _data["originalCurrencyCode"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.destinationOrganizationId = _data["destinationOrganizationId"];
            this.deliverToLocationId = _data["deliverToLocationId"];
            this.totalPrice = _data["totalPrice"];
            this.rateDate = _data["rateDate"] ? DateTime.fromISO(_data["rateDate"].toString()) : <any>undefined;
            this.currencyRate = _data["currencyRate"];
            if (Array.isArray(_data["inputPurchaseRequestLineDtos"])) {
                this.inputPurchaseRequestLineDtos = [] as any;
                for (let item of _data["inputPurchaseRequestLineDtos"])
                    this.inputPurchaseRequestLineDtos!.push(InputPurchaseRequestLineDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InputPurchaseRequestHeaderDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputPurchaseRequestHeaderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["prepareId"] = this.prepareId;
        data["purchasePurposeId"] = this.purchasePurposeId;
        data["prepareName"] = this.prepareName;
        data["requisitionNo"] = this.requisitionNo;
        data["authorizationStatus"] = this.authorizationStatus;
        data["requestId"] = this.requestId;
        data["description"] = this.description;
        data["destinationTypeCode"] = this.destinationTypeCode;
        data["chargeAccount"] = this.chargeAccount;
        data["originalCurrencyCode"] = this.originalCurrencyCode;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["destinationOrganizationId"] = this.destinationOrganizationId;
        data["deliverToLocationId"] = this.deliverToLocationId;
        data["totalPrice"] = this.totalPrice;
        data["rateDate"] = this.rateDate ? this.rateDate.toString() : <any>undefined;
        data["currencyRate"] = this.currencyRate;
        if (Array.isArray(this.inputPurchaseRequestLineDtos)) {
            data["inputPurchaseRequestLineDtos"] = [];
            for (let item of this.inputPurchaseRequestLineDtos)
                data["inputPurchaseRequestLineDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInputPurchaseRequestHeaderDto {
    id: number;
    prepareId: number | undefined;
    purchasePurposeId: number | undefined;
    prepareName: string | undefined;
    requisitionNo: string | undefined;
    authorizationStatus: string | undefined;
    requestId: number | undefined;
    description: string | undefined;
    destinationTypeCode: string | undefined;
    chargeAccount: string | undefined;
    originalCurrencyCode: string | undefined;
    inventoryGroupId: number | undefined;
    destinationOrganizationId: number | undefined;
    deliverToLocationId: number | undefined;
    totalPrice: number | undefined;
    rateDate: DateTime | undefined;
    currencyRate: number | undefined;
    inputPurchaseRequestLineDtos: InputPurchaseRequestLineDto[] | undefined;
}

export class GetAllPurchaseRequestAttachmentsForViewDto implements IGetAllPurchaseRequestAttachmentsForViewDto {
    id!: number;
    fileName!: string | undefined;
    serverFileName!: string | undefined;
    rootPath!: string | undefined;
    uploadTime!: DateTime | undefined;

    constructor(data?: IGetAllPurchaseRequestAttachmentsForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileName = _data["fileName"];
            this.serverFileName = _data["serverFileName"];
            this.rootPath = _data["rootPath"];
            this.uploadTime = _data["uploadTime"] ? DateTime.fromISO(_data["uploadTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAllPurchaseRequestAttachmentsForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllPurchaseRequestAttachmentsForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileName"] = this.fileName;
        data["serverFileName"] = this.serverFileName;
        data["rootPath"] = this.rootPath;
        data["uploadTime"] = this.uploadTime ? this.uploadTime.toString() : <any>undefined;
        return data;
    }
}

export interface IGetAllPurchaseRequestAttachmentsForViewDto {
    id: number;
    fileName: string | undefined;
    serverFileName: string | undefined;
    rootPath: string | undefined;
    uploadTime: DateTime | undefined;
}

export class GetPurchaseRequestLineForEditDto implements IGetPurchaseRequestLineForEditDto {
    id!: number | undefined;
    prRequisitionHeaderId!: number | undefined;
    lineTypeId!: number | undefined;
    itemId!: number | undefined;
    partNo!: string | undefined;
    partName!: string | undefined;
    categoryId!: number | undefined;
    urLineId!: number | undefined;
    category!: string | undefined;
    uom!: string | undefined;
    unitMeasLookupCode!: string | undefined;
    needByDate!: string | undefined;
    quantity!: number | undefined;
    unitPrice!: number | undefined;
    destinationTypeCode!: string | undefined;
    destinationOrganizationId!: number | undefined;
    requesterName!: string | undefined;
    destinationSubinventory!: string | undefined;
    suggestedVendorName!: string | undefined;
    vendorId!: number | undefined;
    suggestedVendorLocation!: string | undefined;
    vendorSiteId!: number | undefined;
    deliverToLocationId!: number | undefined;
    toPersonId!: number | undefined;
    foreignPrice!: number | undefined;
    locationCode!: string | undefined;
    addressSupplier!: string | undefined;
    suggestedVendorContact!: string | undefined;
    suggestedVendorPhone!: string | undefined;
    attribute9!: string | undefined;
    attribute12!: string | undefined;
    attribute14!: string | undefined;
    attribute15!: string | undefined;
    attribute10!: string | undefined;
    attribute11!: string | undefined;
    amount!: number | undefined;
    distributionsId!: number | undefined;
    chargeAccount!: string | undefined;
    glDate!: DateTime | undefined;
    budgetAccount!: string | undefined;
    accrualAccount!: string | undefined;
    varianceAccount!: string | undefined;
    totalCount!: number | undefined;
    listDistributions!: GetPurchaseRequestDistributionsDto[] | undefined;

    constructor(data?: IGetPurchaseRequestLineForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.prRequisitionHeaderId = _data["prRequisitionHeaderId"];
            this.lineTypeId = _data["lineTypeId"];
            this.itemId = _data["itemId"];
            this.partNo = _data["partNo"];
            this.partName = _data["partName"];
            this.categoryId = _data["categoryId"];
            this.urLineId = _data["urLineId"];
            this.category = _data["category"];
            this.uom = _data["uom"];
            this.unitMeasLookupCode = _data["unitMeasLookupCode"];
            this.needByDate = _data["needByDate"];
            this.quantity = _data["quantity"];
            this.unitPrice = _data["unitPrice"];
            this.destinationTypeCode = _data["destinationTypeCode"];
            this.destinationOrganizationId = _data["destinationOrganizationId"];
            this.requesterName = _data["requesterName"];
            this.destinationSubinventory = _data["destinationSubinventory"];
            this.suggestedVendorName = _data["suggestedVendorName"];
            this.vendorId = _data["vendorId"];
            this.suggestedVendorLocation = _data["suggestedVendorLocation"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.deliverToLocationId = _data["deliverToLocationId"];
            this.toPersonId = _data["toPersonId"];
            this.foreignPrice = _data["foreignPrice"];
            this.locationCode = _data["locationCode"];
            this.addressSupplier = _data["addressSupplier"];
            this.suggestedVendorContact = _data["suggestedVendorContact"];
            this.suggestedVendorPhone = _data["suggestedVendorPhone"];
            this.attribute9 = _data["attribute9"];
            this.attribute12 = _data["attribute12"];
            this.attribute14 = _data["attribute14"];
            this.attribute15 = _data["attribute15"];
            this.attribute10 = _data["attribute10"];
            this.attribute11 = _data["attribute11"];
            this.amount = _data["amount"];
            this.distributionsId = _data["distributionsId"];
            this.chargeAccount = _data["chargeAccount"];
            this.glDate = _data["glDate"] ? DateTime.fromISO(_data["glDate"].toString()) : <any>undefined;
            this.budgetAccount = _data["budgetAccount"];
            this.accrualAccount = _data["accrualAccount"];
            this.varianceAccount = _data["varianceAccount"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["listDistributions"])) {
                this.listDistributions = [] as any;
                for (let item of _data["listDistributions"])
                    this.listDistributions!.push(GetPurchaseRequestDistributionsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPurchaseRequestLineForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPurchaseRequestLineForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["prRequisitionHeaderId"] = this.prRequisitionHeaderId;
        data["lineTypeId"] = this.lineTypeId;
        data["itemId"] = this.itemId;
        data["partNo"] = this.partNo;
        data["partName"] = this.partName;
        data["categoryId"] = this.categoryId;
        data["urLineId"] = this.urLineId;
        data["category"] = this.category;
        data["uom"] = this.uom;
        data["unitMeasLookupCode"] = this.unitMeasLookupCode;
        data["needByDate"] = this.needByDate;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["destinationTypeCode"] = this.destinationTypeCode;
        data["destinationOrganizationId"] = this.destinationOrganizationId;
        data["requesterName"] = this.requesterName;
        data["destinationSubinventory"] = this.destinationSubinventory;
        data["suggestedVendorName"] = this.suggestedVendorName;
        data["vendorId"] = this.vendorId;
        data["suggestedVendorLocation"] = this.suggestedVendorLocation;
        data["vendorSiteId"] = this.vendorSiteId;
        data["deliverToLocationId"] = this.deliverToLocationId;
        data["toPersonId"] = this.toPersonId;
        data["foreignPrice"] = this.foreignPrice;
        data["locationCode"] = this.locationCode;
        data["addressSupplier"] = this.addressSupplier;
        data["suggestedVendorContact"] = this.suggestedVendorContact;
        data["suggestedVendorPhone"] = this.suggestedVendorPhone;
        data["attribute9"] = this.attribute9;
        data["attribute12"] = this.attribute12;
        data["attribute14"] = this.attribute14;
        data["attribute15"] = this.attribute15;
        data["attribute10"] = this.attribute10;
        data["attribute11"] = this.attribute11;
        data["amount"] = this.amount;
        data["distributionsId"] = this.distributionsId;
        data["chargeAccount"] = this.chargeAccount;
        data["glDate"] = this.glDate ? this.glDate.toString() : <any>undefined;
        data["budgetAccount"] = this.budgetAccount;
        data["accrualAccount"] = this.accrualAccount;
        data["varianceAccount"] = this.varianceAccount;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.listDistributions)) {
            data["listDistributions"] = [];
            for (let item of this.listDistributions)
                data["listDistributions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetPurchaseRequestLineForEditDto {
    id: number | undefined;
    prRequisitionHeaderId: number | undefined;
    lineTypeId: number | undefined;
    itemId: number | undefined;
    partNo: string | undefined;
    partName: string | undefined;
    categoryId: number | undefined;
    urLineId: number | undefined;
    category: string | undefined;
    uom: string | undefined;
    unitMeasLookupCode: string | undefined;
    needByDate: string | undefined;
    quantity: number | undefined;
    unitPrice: number | undefined;
    destinationTypeCode: string | undefined;
    destinationOrganizationId: number | undefined;
    requesterName: string | undefined;
    destinationSubinventory: string | undefined;
    suggestedVendorName: string | undefined;
    vendorId: number | undefined;
    suggestedVendorLocation: string | undefined;
    vendorSiteId: number | undefined;
    deliverToLocationId: number | undefined;
    toPersonId: number | undefined;
    foreignPrice: number | undefined;
    locationCode: string | undefined;
    addressSupplier: string | undefined;
    suggestedVendorContact: string | undefined;
    suggestedVendorPhone: string | undefined;
    attribute9: string | undefined;
    attribute12: string | undefined;
    attribute14: string | undefined;
    attribute15: string | undefined;
    attribute10: string | undefined;
    attribute11: string | undefined;
    amount: number | undefined;
    distributionsId: number | undefined;
    chargeAccount: string | undefined;
    glDate: DateTime | undefined;
    budgetAccount: string | undefined;
    accrualAccount: string | undefined;
    varianceAccount: string | undefined;
    totalCount: number | undefined;
    listDistributions: GetPurchaseRequestDistributionsDto[] | undefined;
}

export class GetPurchaseRequestForEditDto implements IGetPurchaseRequestForEditDto {
    id!: number;
    preparerId!: number;
    purchasePurposeId!: number | undefined;
    prepareName!: string | undefined;
    requisitionNo!: string | undefined;
    authorizationStatus!: string | undefined;
    requestId!: number;
    destinationOrganizationId!: number | undefined;
    deliverToLocationId!: number | undefined;
    rateDate!: DateTime | undefined;
    description!: string | undefined;
    toPersonId!: number;
    inventoryGroupId!: number;
    requestNote!: string | undefined;
    chargeAccount!: string | undefined;
    originalCurrencyCode!: string | undefined;
    replyNote!: string | undefined;
    attachments!: GetAllPurchaseRequestAttachmentsForViewDto[] | undefined;
    getPurchaseRequestLineForEditDtos!: GetPurchaseRequestLineForEditDto[] | undefined;

    constructor(data?: IGetPurchaseRequestForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.preparerId = _data["preparerId"];
            this.purchasePurposeId = _data["purchasePurposeId"];
            this.prepareName = _data["prepareName"];
            this.requisitionNo = _data["requisitionNo"];
            this.authorizationStatus = _data["authorizationStatus"];
            this.requestId = _data["requestId"];
            this.destinationOrganizationId = _data["destinationOrganizationId"];
            this.deliverToLocationId = _data["deliverToLocationId"];
            this.rateDate = _data["rateDate"] ? DateTime.fromISO(_data["rateDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.toPersonId = _data["toPersonId"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.requestNote = _data["requestNote"];
            this.chargeAccount = _data["chargeAccount"];
            this.originalCurrencyCode = _data["originalCurrencyCode"];
            this.replyNote = _data["replyNote"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(GetAllPurchaseRequestAttachmentsForViewDto.fromJS(item));
            }
            if (Array.isArray(_data["getPurchaseRequestLineForEditDtos"])) {
                this.getPurchaseRequestLineForEditDtos = [] as any;
                for (let item of _data["getPurchaseRequestLineForEditDtos"])
                    this.getPurchaseRequestLineForEditDtos!.push(GetPurchaseRequestLineForEditDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPurchaseRequestForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPurchaseRequestForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["preparerId"] = this.preparerId;
        data["purchasePurposeId"] = this.purchasePurposeId;
        data["prepareName"] = this.prepareName;
        data["requisitionNo"] = this.requisitionNo;
        data["authorizationStatus"] = this.authorizationStatus;
        data["requestId"] = this.requestId;
        data["destinationOrganizationId"] = this.destinationOrganizationId;
        data["deliverToLocationId"] = this.deliverToLocationId;
        data["rateDate"] = this.rateDate ? this.rateDate.toString() : <any>undefined;
        data["description"] = this.description;
        data["toPersonId"] = this.toPersonId;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["requestNote"] = this.requestNote;
        data["chargeAccount"] = this.chargeAccount;
        data["originalCurrencyCode"] = this.originalCurrencyCode;
        data["replyNote"] = this.replyNote;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        if (Array.isArray(this.getPurchaseRequestLineForEditDtos)) {
            data["getPurchaseRequestLineForEditDtos"] = [];
            for (let item of this.getPurchaseRequestLineForEditDtos)
                data["getPurchaseRequestLineForEditDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetPurchaseRequestForEditDto {
    id: number;
    preparerId: number;
    purchasePurposeId: number | undefined;
    prepareName: string | undefined;
    requisitionNo: string | undefined;
    authorizationStatus: string | undefined;
    requestId: number;
    destinationOrganizationId: number | undefined;
    deliverToLocationId: number | undefined;
    rateDate: DateTime | undefined;
    description: string | undefined;
    toPersonId: number;
    inventoryGroupId: number;
    requestNote: string | undefined;
    chargeAccount: string | undefined;
    originalCurrencyCode: string | undefined;
    replyNote: string | undefined;
    attachments: GetAllPurchaseRequestAttachmentsForViewDto[] | undefined;
    getPurchaseRequestLineForEditDtos: GetPurchaseRequestLineForEditDto[] | undefined;
}

export class PagedResultDtoOfGetRequesterDto implements IPagedResultDtoOfGetRequesterDto {
    totalCount!: number;
    items!: GetRequesterDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRequesterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetRequesterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRequesterDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRequesterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetRequesterDto {
    totalCount: number;
    items: GetRequesterDto[] | undefined;
}

export class GetListPrNumberDto implements IGetListPrNumberDto {
    id!: number;
    prNumber!: string | undefined;

    constructor(data?: IGetListPrNumberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.prNumber = _data["prNumber"];
        }
    }

    static fromJS(data: any): GetListPrNumberDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetListPrNumberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["prNumber"] = this.prNumber;
        return data;
    }
}

export interface IGetListPrNumberDto {
    id: number;
    prNumber: string | undefined;
}

export class PagedResultDtoOfGetPurchaseRequestForCreatePODto implements IPagedResultDtoOfGetPurchaseRequestForCreatePODto {
    totalCount!: number;
    items!: GetPurchaseRequestForCreatePODto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPurchaseRequestForCreatePODto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetPurchaseRequestForCreatePODto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPurchaseRequestForCreatePODto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPurchaseRequestForCreatePODto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetPurchaseRequestForCreatePODto {
    totalCount: number;
    items: GetPurchaseRequestForCreatePODto[] | undefined;
}

export class GetPrDistributionsForCreatePoDto implements IGetPrDistributionsForCreatePoDto {
    prDistributionsId!: number;
    prRequisitionLineId!: number;
    prRequisitionHeaderId!: number;
    destinationTypeCode!: string | undefined;
    deliverToPersonId!: number | undefined;
    requesterName!: string | undefined;
    deliverToLocationId!: number | undefined;
    deliverTo!: string | undefined;
    productGroupName!: string | undefined;
    subinventory!: string | undefined;
    inventoryGroupId!: string | undefined;
    quantityOrdered!: number | undefined;
    poChargeAccount!: string | undefined;
    destinationChargeAccount!: string | undefined;
    recoveryRate!: number | undefined;
    glDate!: DateTime | undefined;

    constructor(data?: IGetPrDistributionsForCreatePoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.prDistributionsId = _data["prDistributionsId"];
            this.prRequisitionLineId = _data["prRequisitionLineId"];
            this.prRequisitionHeaderId = _data["prRequisitionHeaderId"];
            this.destinationTypeCode = _data["destinationTypeCode"];
            this.deliverToPersonId = _data["deliverToPersonId"];
            this.requesterName = _data["requesterName"];
            this.deliverToLocationId = _data["deliverToLocationId"];
            this.deliverTo = _data["deliverTo"];
            this.productGroupName = _data["productGroupName"];
            this.subinventory = _data["subinventory"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.quantityOrdered = _data["quantityOrdered"];
            this.poChargeAccount = _data["poChargeAccount"];
            this.destinationChargeAccount = _data["destinationChargeAccount"];
            this.recoveryRate = _data["recoveryRate"];
            this.glDate = _data["glDate"] ? DateTime.fromISO(_data["glDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPrDistributionsForCreatePoDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPrDistributionsForCreatePoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["prDistributionsId"] = this.prDistributionsId;
        data["prRequisitionLineId"] = this.prRequisitionLineId;
        data["prRequisitionHeaderId"] = this.prRequisitionHeaderId;
        data["destinationTypeCode"] = this.destinationTypeCode;
        data["deliverToPersonId"] = this.deliverToPersonId;
        data["requesterName"] = this.requesterName;
        data["deliverToLocationId"] = this.deliverToLocationId;
        data["deliverTo"] = this.deliverTo;
        data["productGroupName"] = this.productGroupName;
        data["subinventory"] = this.subinventory;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["quantityOrdered"] = this.quantityOrdered;
        data["poChargeAccount"] = this.poChargeAccount;
        data["destinationChargeAccount"] = this.destinationChargeAccount;
        data["recoveryRate"] = this.recoveryRate;
        data["glDate"] = this.glDate ? this.glDate.toString() : <any>undefined;
        return data;
    }
}

export interface IGetPrDistributionsForCreatePoDto {
    prDistributionsId: number;
    prRequisitionLineId: number;
    prRequisitionHeaderId: number;
    destinationTypeCode: string | undefined;
    deliverToPersonId: number | undefined;
    requesterName: string | undefined;
    deliverToLocationId: number | undefined;
    deliverTo: string | undefined;
    productGroupName: string | undefined;
    subinventory: string | undefined;
    inventoryGroupId: string | undefined;
    quantityOrdered: number | undefined;
    poChargeAccount: string | undefined;
    destinationChargeAccount: string | undefined;
    recoveryRate: number | undefined;
    glDate: DateTime | undefined;
}

export class SearchPurchaseRequestDto implements ISearchPurchaseRequestDto {
    requisitionNo!: string | undefined;
    preparerId!: number | undefined;
    buyerId!: number | undefined;
    inventoryGroupId!: number | undefined;
    status!: string | undefined;
    isInternal!: boolean | undefined;
    fromDate!: DateTime | undefined;
    toDate!: DateTime | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ISearchPurchaseRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requisitionNo = _data["requisitionNo"];
            this.preparerId = _data["preparerId"];
            this.buyerId = _data["buyerId"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.status = _data["status"];
            this.isInternal = _data["isInternal"];
            this.fromDate = _data["fromDate"] ? DateTime.fromISO(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? DateTime.fromISO(_data["toDate"].toString()) : <any>undefined;
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): SearchPurchaseRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchPurchaseRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requisitionNo"] = this.requisitionNo;
        data["preparerId"] = this.preparerId;
        data["buyerId"] = this.buyerId;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["status"] = this.status;
        data["isInternal"] = this.isInternal;
        data["fromDate"] = this.fromDate ? this.fromDate.toString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toString() : <any>undefined;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data;
    }
}

export interface ISearchPurchaseRequestDto {
    requisitionNo: string | undefined;
    preparerId: number | undefined;
    buyerId: number | undefined;
    inventoryGroupId: number | undefined;
    status: string | undefined;
    isInternal: boolean | undefined;
    fromDate: DateTime | undefined;
    toDate: DateTime | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class GetExpectedReceiptNoteLinesDto implements IGetExpectedReceiptNoteLinesDto {
    checked!: boolean;
    quantityShipped!: number | undefined;
    quantityRemained!: number | undefined;
    quantityReceived!: number | undefined;
    quantityOrdered!: number | undefined;
    quantityAccumulated!: number | undefined;
    unitOfMeasure!: string | undefined;
    itemDescription!: string | undefined;
    itemId!: number | undefined;
    categoryId!: number | undefined;
    poHeaderId!: number | undefined;
    poLineId!: number | undefined;
    poTypeLookupCode!: string | undefined;
    poNo!: string | undefined;
    vendorId!: number | undefined;
    vendorSiteId!: number | undefined;
    vendorName!: string | undefined;
    vendorSiteCode!: string | undefined;
    partNo!: string | undefined;
    poLineNum!: number;
    expiryDate!: DateTime | undefined;
    finishedDate!: DateTime | undefined;
    isManuallyAdded!: boolean;
    inventoryGroupId!: number | undefined;
    isInventory!: boolean;
    productGroupName!: string | undefined;

    constructor(data?: IGetExpectedReceiptNoteLinesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checked = _data["checked"];
            this.quantityShipped = _data["quantityShipped"];
            this.quantityRemained = _data["quantityRemained"];
            this.quantityReceived = _data["quantityReceived"];
            this.quantityOrdered = _data["quantityOrdered"];
            this.quantityAccumulated = _data["quantityAccumulated"];
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.itemDescription = _data["itemDescription"];
            this.itemId = _data["itemId"];
            this.categoryId = _data["categoryId"];
            this.poHeaderId = _data["poHeaderId"];
            this.poLineId = _data["poLineId"];
            this.poTypeLookupCode = _data["poTypeLookupCode"];
            this.poNo = _data["poNo"];
            this.vendorId = _data["vendorId"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.vendorName = _data["vendorName"];
            this.vendorSiteCode = _data["vendorSiteCode"];
            this.partNo = _data["partNo"];
            this.poLineNum = _data["poLineNum"];
            this.expiryDate = _data["expiryDate"] ? DateTime.fromISO(_data["expiryDate"].toString()) : <any>undefined;
            this.finishedDate = _data["finishedDate"] ? DateTime.fromISO(_data["finishedDate"].toString()) : <any>undefined;
            this.isManuallyAdded = _data["isManuallyAdded"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.isInventory = _data["isInventory"];
            this.productGroupName = _data["productGroupName"];
        }
    }

    static fromJS(data: any): GetExpectedReceiptNoteLinesDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetExpectedReceiptNoteLinesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checked"] = this.checked;
        data["quantityShipped"] = this.quantityShipped;
        data["quantityRemained"] = this.quantityRemained;
        data["quantityReceived"] = this.quantityReceived;
        data["quantityOrdered"] = this.quantityOrdered;
        data["quantityAccumulated"] = this.quantityAccumulated;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["itemDescription"] = this.itemDescription;
        data["itemId"] = this.itemId;
        data["categoryId"] = this.categoryId;
        data["poHeaderId"] = this.poHeaderId;
        data["poLineId"] = this.poLineId;
        data["poTypeLookupCode"] = this.poTypeLookupCode;
        data["poNo"] = this.poNo;
        data["vendorId"] = this.vendorId;
        data["vendorSiteId"] = this.vendorSiteId;
        data["vendorName"] = this.vendorName;
        data["vendorSiteCode"] = this.vendorSiteCode;
        data["partNo"] = this.partNo;
        data["poLineNum"] = this.poLineNum;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toString() : <any>undefined;
        data["finishedDate"] = this.finishedDate ? this.finishedDate.toString() : <any>undefined;
        data["isManuallyAdded"] = this.isManuallyAdded;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["isInventory"] = this.isInventory;
        data["productGroupName"] = this.productGroupName;
        return data;
    }
}

export interface IGetExpectedReceiptNoteLinesDto {
    checked: boolean;
    quantityShipped: number | undefined;
    quantityRemained: number | undefined;
    quantityReceived: number | undefined;
    quantityOrdered: number | undefined;
    quantityAccumulated: number | undefined;
    unitOfMeasure: string | undefined;
    itemDescription: string | undefined;
    itemId: number | undefined;
    categoryId: number | undefined;
    poHeaderId: number | undefined;
    poLineId: number | undefined;
    poTypeLookupCode: string | undefined;
    poNo: string | undefined;
    vendorId: number | undefined;
    vendorSiteId: number | undefined;
    vendorName: string | undefined;
    vendorSiteCode: string | undefined;
    partNo: string | undefined;
    poLineNum: number;
    expiryDate: DateTime | undefined;
    finishedDate: DateTime | undefined;
    isManuallyAdded: boolean;
    inventoryGroupId: number | undefined;
    isInventory: boolean;
    productGroupName: string | undefined;
}

export class PagedResultDtoOfGetExpectedReceiptNoteLinesDto implements IPagedResultDtoOfGetExpectedReceiptNoteLinesDto {
    totalCount!: number;
    items!: GetExpectedReceiptNoteLinesDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetExpectedReceiptNoteLinesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetExpectedReceiptNoteLinesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetExpectedReceiptNoteLinesDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetExpectedReceiptNoteLinesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetExpectedReceiptNoteLinesDto {
    totalCount: number;
    items: GetExpectedReceiptNoteLinesDto[] | undefined;
}

export class InputRcvReceiptNoteLinesDto implements IInputRcvReceiptNoteLinesDto {
    id!: number;
    checked!: boolean;
    receiptNoteHeaderId!: number;
    lineNum!: number;
    categoryId!: number | undefined;
    quantityShipped!: number | undefined;
    quantityReceived!: number | undefined;
    quantityOrdered!: number | undefined;
    unitOfMeasure!: string | undefined;
    itemDescription!: string | undefined;
    itemId!: number | undefined;
    itemRevision!: string | undefined;
    shipmentLineStatusCode!: string | undefined;
    sourceDocumentCode!: string | undefined;
    poHeaderId!: number | undefined;
    poLineId!: number | undefined;
    poLineLocationId!: number | undefined;
    poDistributionId!: number | undefined;
    routingHeaderId!: number | undefined;
    deliverToPersonId!: number | undefined;
    employeeId!: number | undefined;
    destinationTypeCode!: string | undefined;
    toOrganizationId!: number | undefined;
    toSubinventory!: string | undefined;
    locatorId!: number | undefined;
    deliverToLocationId!: number | undefined;
    requestId!: number | undefined;
    primaryUnitOfMeasure!: string | undefined;
    asnLineFlag!: string | undefined;
    shipToLocationId!: number | undefined;
    countryOfOriginCode!: string | undefined;
    secondaryQuantityReceived!: number | undefined;
    amountReceived!: number | undefined;
    poNo!: string | undefined;
    poTypeLookupCode!: string | undefined;
    partNo!: string | undefined;
    rn!: number;
    expiryDate!: DateTime | undefined;
    finishedDate!: DateTime | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IInputRcvReceiptNoteLinesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.checked = _data["checked"];
            this.receiptNoteHeaderId = _data["receiptNoteHeaderId"];
            this.lineNum = _data["lineNum"];
            this.categoryId = _data["categoryId"];
            this.quantityShipped = _data["quantityShipped"];
            this.quantityReceived = _data["quantityReceived"];
            this.quantityOrdered = _data["quantityOrdered"];
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.itemDescription = _data["itemDescription"];
            this.itemId = _data["itemId"];
            this.itemRevision = _data["itemRevision"];
            this.shipmentLineStatusCode = _data["shipmentLineStatusCode"];
            this.sourceDocumentCode = _data["sourceDocumentCode"];
            this.poHeaderId = _data["poHeaderId"];
            this.poLineId = _data["poLineId"];
            this.poLineLocationId = _data["poLineLocationId"];
            this.poDistributionId = _data["poDistributionId"];
            this.routingHeaderId = _data["routingHeaderId"];
            this.deliverToPersonId = _data["deliverToPersonId"];
            this.employeeId = _data["employeeId"];
            this.destinationTypeCode = _data["destinationTypeCode"];
            this.toOrganizationId = _data["toOrganizationId"];
            this.toSubinventory = _data["toSubinventory"];
            this.locatorId = _data["locatorId"];
            this.deliverToLocationId = _data["deliverToLocationId"];
            this.requestId = _data["requestId"];
            this.primaryUnitOfMeasure = _data["primaryUnitOfMeasure"];
            this.asnLineFlag = _data["asnLineFlag"];
            this.shipToLocationId = _data["shipToLocationId"];
            this.countryOfOriginCode = _data["countryOfOriginCode"];
            this.secondaryQuantityReceived = _data["secondaryQuantityReceived"];
            this.amountReceived = _data["amountReceived"];
            this.poNo = _data["poNo"];
            this.poTypeLookupCode = _data["poTypeLookupCode"];
            this.partNo = _data["partNo"];
            this.rn = _data["rn"];
            this.expiryDate = _data["expiryDate"] ? DateTime.fromISO(_data["expiryDate"].toString()) : <any>undefined;
            this.finishedDate = _data["finishedDate"] ? DateTime.fromISO(_data["finishedDate"].toString()) : <any>undefined;
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): InputRcvReceiptNoteLinesDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputRcvReceiptNoteLinesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["checked"] = this.checked;
        data["receiptNoteHeaderId"] = this.receiptNoteHeaderId;
        data["lineNum"] = this.lineNum;
        data["categoryId"] = this.categoryId;
        data["quantityShipped"] = this.quantityShipped;
        data["quantityReceived"] = this.quantityReceived;
        data["quantityOrdered"] = this.quantityOrdered;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["itemDescription"] = this.itemDescription;
        data["itemId"] = this.itemId;
        data["itemRevision"] = this.itemRevision;
        data["shipmentLineStatusCode"] = this.shipmentLineStatusCode;
        data["sourceDocumentCode"] = this.sourceDocumentCode;
        data["poHeaderId"] = this.poHeaderId;
        data["poLineId"] = this.poLineId;
        data["poLineLocationId"] = this.poLineLocationId;
        data["poDistributionId"] = this.poDistributionId;
        data["routingHeaderId"] = this.routingHeaderId;
        data["deliverToPersonId"] = this.deliverToPersonId;
        data["employeeId"] = this.employeeId;
        data["destinationTypeCode"] = this.destinationTypeCode;
        data["toOrganizationId"] = this.toOrganizationId;
        data["toSubinventory"] = this.toSubinventory;
        data["locatorId"] = this.locatorId;
        data["deliverToLocationId"] = this.deliverToLocationId;
        data["requestId"] = this.requestId;
        data["primaryUnitOfMeasure"] = this.primaryUnitOfMeasure;
        data["asnLineFlag"] = this.asnLineFlag;
        data["shipToLocationId"] = this.shipToLocationId;
        data["countryOfOriginCode"] = this.countryOfOriginCode;
        data["secondaryQuantityReceived"] = this.secondaryQuantityReceived;
        data["amountReceived"] = this.amountReceived;
        data["poNo"] = this.poNo;
        data["poTypeLookupCode"] = this.poTypeLookupCode;
        data["partNo"] = this.partNo;
        data["rn"] = this.rn;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toString() : <any>undefined;
        data["finishedDate"] = this.finishedDate ? this.finishedDate.toString() : <any>undefined;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data;
    }
}

export interface IInputRcvReceiptNoteLinesDto {
    id: number;
    checked: boolean;
    receiptNoteHeaderId: number;
    lineNum: number;
    categoryId: number | undefined;
    quantityShipped: number | undefined;
    quantityReceived: number | undefined;
    quantityOrdered: number | undefined;
    unitOfMeasure: string | undefined;
    itemDescription: string | undefined;
    itemId: number | undefined;
    itemRevision: string | undefined;
    shipmentLineStatusCode: string | undefined;
    sourceDocumentCode: string | undefined;
    poHeaderId: number | undefined;
    poLineId: number | undefined;
    poLineLocationId: number | undefined;
    poDistributionId: number | undefined;
    routingHeaderId: number | undefined;
    deliverToPersonId: number | undefined;
    employeeId: number | undefined;
    destinationTypeCode: string | undefined;
    toOrganizationId: number | undefined;
    toSubinventory: string | undefined;
    locatorId: number | undefined;
    deliverToLocationId: number | undefined;
    requestId: number | undefined;
    primaryUnitOfMeasure: string | undefined;
    asnLineFlag: string | undefined;
    shipToLocationId: number | undefined;
    countryOfOriginCode: string | undefined;
    secondaryQuantityReceived: number | undefined;
    amountReceived: number | undefined;
    poNo: string | undefined;
    poTypeLookupCode: string | undefined;
    partNo: string | undefined;
    rn: number;
    expiryDate: DateTime | undefined;
    finishedDate: DateTime | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class GetRcvReceiptNoteHeadersDto implements IGetRcvReceiptNoteHeadersDto {
    totalCount!: number;
    id!: number;
    receiptSourceCode!: string | undefined;
    vendorId!: number | undefined;
    vendorSiteId!: number | undefined;
    organizationId!: number | undefined;
    shipmentNum!: string | undefined;
    receiptNoteNum!: string | undefined;
    billOfLading!: string | undefined;
    receivedDate!: DateTime | undefined;
    shippedDate!: DateTime | undefined;
    employeeId!: number | undefined;
    waybillAirbillNum!: string | undefined;
    comments!: string | undefined;
    shipToOrgId!: number | undefined;
    status!: number;
    vendorName!: string | undefined;
    vendorSiteCode!: string | undefined;
    receiptNoteType!: number;
    employeeId2!: number | undefined;
    serviceStartDate!: DateTime | undefined;
    serviceEndDate!: DateTime | undefined;
    deliverName1!: string | undefined;
    deliverTitle1!: string | undefined;
    deliverName2!: string | undefined;
    deliverTitle2!: string | undefined;
    employeeName1!: string | undefined;
    employeeName2!: string | undefined;
    employeeTitle1!: string | undefined;
    employeeTitle2!: string | undefined;
    creatorUser!: string | undefined;
    inputRcvReceiptNoteLinesDto!: InputRcvReceiptNoteLinesDto[] | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IGetRcvReceiptNoteHeadersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.id = _data["id"];
            this.receiptSourceCode = _data["receiptSourceCode"];
            this.vendorId = _data["vendorId"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.organizationId = _data["organizationId"];
            this.shipmentNum = _data["shipmentNum"];
            this.receiptNoteNum = _data["receiptNoteNum"];
            this.billOfLading = _data["billOfLading"];
            this.receivedDate = _data["receivedDate"] ? DateTime.fromISO(_data["receivedDate"].toString()) : <any>undefined;
            this.shippedDate = _data["shippedDate"] ? DateTime.fromISO(_data["shippedDate"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.waybillAirbillNum = _data["waybillAirbillNum"];
            this.comments = _data["comments"];
            this.shipToOrgId = _data["shipToOrgId"];
            this.status = _data["status"];
            this.vendorName = _data["vendorName"];
            this.vendorSiteCode = _data["vendorSiteCode"];
            this.receiptNoteType = _data["receiptNoteType"];
            this.employeeId2 = _data["employeeId2"];
            this.serviceStartDate = _data["serviceStartDate"] ? DateTime.fromISO(_data["serviceStartDate"].toString()) : <any>undefined;
            this.serviceEndDate = _data["serviceEndDate"] ? DateTime.fromISO(_data["serviceEndDate"].toString()) : <any>undefined;
            this.deliverName1 = _data["deliverName1"];
            this.deliverTitle1 = _data["deliverTitle1"];
            this.deliverName2 = _data["deliverName2"];
            this.deliverTitle2 = _data["deliverTitle2"];
            this.employeeName1 = _data["employeeName1"];
            this.employeeName2 = _data["employeeName2"];
            this.employeeTitle1 = _data["employeeTitle1"];
            this.employeeTitle2 = _data["employeeTitle2"];
            this.creatorUser = _data["creatorUser"];
            if (Array.isArray(_data["inputRcvReceiptNoteLinesDto"])) {
                this.inputRcvReceiptNoteLinesDto = [] as any;
                for (let item of _data["inputRcvReceiptNoteLinesDto"])
                    this.inputRcvReceiptNoteLinesDto!.push(InputRcvReceiptNoteLinesDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): GetRcvReceiptNoteHeadersDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRcvReceiptNoteHeadersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["id"] = this.id;
        data["receiptSourceCode"] = this.receiptSourceCode;
        data["vendorId"] = this.vendorId;
        data["vendorSiteId"] = this.vendorSiteId;
        data["organizationId"] = this.organizationId;
        data["shipmentNum"] = this.shipmentNum;
        data["receiptNoteNum"] = this.receiptNoteNum;
        data["billOfLading"] = this.billOfLading;
        data["receivedDate"] = this.receivedDate ? this.receivedDate.toString() : <any>undefined;
        data["shippedDate"] = this.shippedDate ? this.shippedDate.toString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["waybillAirbillNum"] = this.waybillAirbillNum;
        data["comments"] = this.comments;
        data["shipToOrgId"] = this.shipToOrgId;
        data["status"] = this.status;
        data["vendorName"] = this.vendorName;
        data["vendorSiteCode"] = this.vendorSiteCode;
        data["receiptNoteType"] = this.receiptNoteType;
        data["employeeId2"] = this.employeeId2;
        data["serviceStartDate"] = this.serviceStartDate ? this.serviceStartDate.toString() : <any>undefined;
        data["serviceEndDate"] = this.serviceEndDate ? this.serviceEndDate.toString() : <any>undefined;
        data["deliverName1"] = this.deliverName1;
        data["deliverTitle1"] = this.deliverTitle1;
        data["deliverName2"] = this.deliverName2;
        data["deliverTitle2"] = this.deliverTitle2;
        data["employeeName1"] = this.employeeName1;
        data["employeeName2"] = this.employeeName2;
        data["employeeTitle1"] = this.employeeTitle1;
        data["employeeTitle2"] = this.employeeTitle2;
        data["creatorUser"] = this.creatorUser;
        if (Array.isArray(this.inputRcvReceiptNoteLinesDto)) {
            data["inputRcvReceiptNoteLinesDto"] = [];
            for (let item of this.inputRcvReceiptNoteLinesDto)
                data["inputRcvReceiptNoteLinesDto"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data;
    }
}

export interface IGetRcvReceiptNoteHeadersDto {
    totalCount: number;
    id: number;
    receiptSourceCode: string | undefined;
    vendorId: number | undefined;
    vendorSiteId: number | undefined;
    organizationId: number | undefined;
    shipmentNum: string | undefined;
    receiptNoteNum: string | undefined;
    billOfLading: string | undefined;
    receivedDate: DateTime | undefined;
    shippedDate: DateTime | undefined;
    employeeId: number | undefined;
    waybillAirbillNum: string | undefined;
    comments: string | undefined;
    shipToOrgId: number | undefined;
    status: number;
    vendorName: string | undefined;
    vendorSiteCode: string | undefined;
    receiptNoteType: number;
    employeeId2: number | undefined;
    serviceStartDate: DateTime | undefined;
    serviceEndDate: DateTime | undefined;
    deliverName1: string | undefined;
    deliverTitle1: string | undefined;
    deliverName2: string | undefined;
    deliverTitle2: string | undefined;
    employeeName1: string | undefined;
    employeeName2: string | undefined;
    employeeTitle1: string | undefined;
    employeeTitle2: string | undefined;
    creatorUser: string | undefined;
    inputRcvReceiptNoteLinesDto: InputRcvReceiptNoteLinesDto[] | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class PagedResultDtoOfGetRcvReceiptNoteHeadersDto implements IPagedResultDtoOfGetRcvReceiptNoteHeadersDto {
    totalCount!: number;
    items!: GetRcvReceiptNoteHeadersDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRcvReceiptNoteHeadersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetRcvReceiptNoteHeadersDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRcvReceiptNoteHeadersDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRcvReceiptNoteHeadersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetRcvReceiptNoteHeadersDto {
    totalCount: number;
    items: GetRcvReceiptNoteHeadersDto[] | undefined;
}

export class InputRcvReceiptNoteHeadersDto implements IInputRcvReceiptNoteHeadersDto {
    id!: number;
    receiptSourceCode!: string | undefined;
    vendorId!: number | undefined;
    vendorSiteId!: number | undefined;
    organizationId!: number | undefined;
    shipmentNum!: string | undefined;
    receiptNoteNum!: string | undefined;
    billOfLading!: string | undefined;
    receivedDate!: DateTime | undefined;
    shippedDate!: DateTime | undefined;
    employeeId!: number | undefined;
    waybillAirbillNum!: string | undefined;
    comments!: string | undefined;
    shipToOrgId!: number | undefined;
    receiptNoteType!: number;
    employeeId2!: number | undefined;
    serviceStartDate!: DateTime | undefined;
    serviceEndDate!: DateTime | undefined;
    deliverName1!: string | undefined;
    deliverTitle1!: string | undefined;
    deliverName2!: string | undefined;
    deliverTitle2!: string | undefined;
    vendorName!: string | undefined;
    vendorSiteCode!: string | undefined;
    employeeName1!: string | undefined;
    employeeName2!: string | undefined;
    employeeTitle1!: string | undefined;
    employeeTitle2!: string | undefined;
    inventoryGroupId!: number | undefined;
    inputRcvReceiptNoteLinesDto!: GetExpectedReceiptNoteLinesDto[] | undefined;

    constructor(data?: IInputRcvReceiptNoteHeadersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.receiptSourceCode = _data["receiptSourceCode"];
            this.vendorId = _data["vendorId"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.organizationId = _data["organizationId"];
            this.shipmentNum = _data["shipmentNum"];
            this.receiptNoteNum = _data["receiptNoteNum"];
            this.billOfLading = _data["billOfLading"];
            this.receivedDate = _data["receivedDate"] ? DateTime.fromISO(_data["receivedDate"].toString()) : <any>undefined;
            this.shippedDate = _data["shippedDate"] ? DateTime.fromISO(_data["shippedDate"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.waybillAirbillNum = _data["waybillAirbillNum"];
            this.comments = _data["comments"];
            this.shipToOrgId = _data["shipToOrgId"];
            this.receiptNoteType = _data["receiptNoteType"];
            this.employeeId2 = _data["employeeId2"];
            this.serviceStartDate = _data["serviceStartDate"] ? DateTime.fromISO(_data["serviceStartDate"].toString()) : <any>undefined;
            this.serviceEndDate = _data["serviceEndDate"] ? DateTime.fromISO(_data["serviceEndDate"].toString()) : <any>undefined;
            this.deliverName1 = _data["deliverName1"];
            this.deliverTitle1 = _data["deliverTitle1"];
            this.deliverName2 = _data["deliverName2"];
            this.deliverTitle2 = _data["deliverTitle2"];
            this.vendorName = _data["vendorName"];
            this.vendorSiteCode = _data["vendorSiteCode"];
            this.employeeName1 = _data["employeeName1"];
            this.employeeName2 = _data["employeeName2"];
            this.employeeTitle1 = _data["employeeTitle1"];
            this.employeeTitle2 = _data["employeeTitle2"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            if (Array.isArray(_data["inputRcvReceiptNoteLinesDto"])) {
                this.inputRcvReceiptNoteLinesDto = [] as any;
                for (let item of _data["inputRcvReceiptNoteLinesDto"])
                    this.inputRcvReceiptNoteLinesDto!.push(GetExpectedReceiptNoteLinesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InputRcvReceiptNoteHeadersDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputRcvReceiptNoteHeadersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["receiptSourceCode"] = this.receiptSourceCode;
        data["vendorId"] = this.vendorId;
        data["vendorSiteId"] = this.vendorSiteId;
        data["organizationId"] = this.organizationId;
        data["shipmentNum"] = this.shipmentNum;
        data["receiptNoteNum"] = this.receiptNoteNum;
        data["billOfLading"] = this.billOfLading;
        data["receivedDate"] = this.receivedDate ? this.receivedDate.toString() : <any>undefined;
        data["shippedDate"] = this.shippedDate ? this.shippedDate.toString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["waybillAirbillNum"] = this.waybillAirbillNum;
        data["comments"] = this.comments;
        data["shipToOrgId"] = this.shipToOrgId;
        data["receiptNoteType"] = this.receiptNoteType;
        data["employeeId2"] = this.employeeId2;
        data["serviceStartDate"] = this.serviceStartDate ? this.serviceStartDate.toString() : <any>undefined;
        data["serviceEndDate"] = this.serviceEndDate ? this.serviceEndDate.toString() : <any>undefined;
        data["deliverName1"] = this.deliverName1;
        data["deliverTitle1"] = this.deliverTitle1;
        data["deliverName2"] = this.deliverName2;
        data["deliverTitle2"] = this.deliverTitle2;
        data["vendorName"] = this.vendorName;
        data["vendorSiteCode"] = this.vendorSiteCode;
        data["employeeName1"] = this.employeeName1;
        data["employeeName2"] = this.employeeName2;
        data["employeeTitle1"] = this.employeeTitle1;
        data["employeeTitle2"] = this.employeeTitle2;
        data["inventoryGroupId"] = this.inventoryGroupId;
        if (Array.isArray(this.inputRcvReceiptNoteLinesDto)) {
            data["inputRcvReceiptNoteLinesDto"] = [];
            for (let item of this.inputRcvReceiptNoteLinesDto)
                data["inputRcvReceiptNoteLinesDto"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInputRcvReceiptNoteHeadersDto {
    id: number;
    receiptSourceCode: string | undefined;
    vendorId: number | undefined;
    vendorSiteId: number | undefined;
    organizationId: number | undefined;
    shipmentNum: string | undefined;
    receiptNoteNum: string | undefined;
    billOfLading: string | undefined;
    receivedDate: DateTime | undefined;
    shippedDate: DateTime | undefined;
    employeeId: number | undefined;
    waybillAirbillNum: string | undefined;
    comments: string | undefined;
    shipToOrgId: number | undefined;
    receiptNoteType: number;
    employeeId2: number | undefined;
    serviceStartDate: DateTime | undefined;
    serviceEndDate: DateTime | undefined;
    deliverName1: string | undefined;
    deliverTitle1: string | undefined;
    deliverName2: string | undefined;
    deliverTitle2: string | undefined;
    vendorName: string | undefined;
    vendorSiteCode: string | undefined;
    employeeName1: string | undefined;
    employeeName2: string | undefined;
    employeeTitle1: string | undefined;
    employeeTitle2: string | undefined;
    inventoryGroupId: number | undefined;
    inputRcvReceiptNoteLinesDto: GetExpectedReceiptNoteLinesDto[] | undefined;
}

export class AbpUserDto implements IAbpUserDto {
    tenantId!: number | undefined;
    empId!: number | undefined;
    userName!: string | undefined;
    name!: string | undefined;
    employeeCode!: string | undefined;
    id!: number;

    constructor(data?: IAbpUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.empId = _data["empId"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.employeeCode = _data["employeeCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AbpUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["empId"] = this.empId;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["employeeCode"] = this.employeeCode;
        data["id"] = this.id;
        return data;
    }
}

export interface IAbpUserDto {
    tenantId: number | undefined;
    empId: number | undefined;
    userName: string | undefined;
    name: string | undefined;
    employeeCode: string | undefined;
    id: number;
}

export class GetRcvReceiptNoteLineForEditDto implements IGetRcvReceiptNoteLineForEditDto {
    id!: number;
    checked!: boolean;
    lineNum!: number | undefined;
    categoryId!: number | undefined;
    quantityShipped!: number | undefined;
    quantityReceived!: number | undefined;
    unitOfMeasure!: string | undefined;
    itemDescription!: string | undefined;
    itemId!: number | undefined;
    itemRevision!: string | undefined;
    shipmentLineStatusCode!: string | undefined;
    sourceDocumentCode!: string | undefined;
    poHeaderId!: number | undefined;
    poLineId!: number | undefined;
    poLineShipmentId!: number | undefined;
    poDistributionId!: number | undefined;
    routingHeaderId!: number | undefined;
    deliverToPersonId!: number | undefined;
    employeeId!: number | undefined;
    destinationTypeCode!: string | undefined;
    toOrganizationId!: number | undefined;
    toSubinventory!: string | undefined;
    locatorId!: number | undefined;
    deliverToLocationId!: number | undefined;
    requestId!: number | undefined;
    primaryUnitOfMeasure!: string | undefined;
    asnLineFlag!: string | undefined;
    shipToLocationId!: number | undefined;
    countryOfOriginCode!: string | undefined;
    secondaryQuantityReceived!: number | undefined;
    amountReceived!: number | undefined;
    receiptNoteHeaderId!: number | undefined;
    receiptNoteLineId!: number | undefined;
    quantityOrdered!: number | undefined;
    quantityAccumulated!: number | undefined;
    quantityRemained!: number | undefined;
    quantityAvailable!: number | undefined;
    poNo!: string | undefined;
    vendorName!: string | undefined;
    vendorSiteCode!: string | undefined;
    needByDate!: DateTime | undefined;
    poTypeLookupCode!: string | undefined;
    destination!: string | undefined;
    receivingRoutingDesc!: string | undefined;
    categoryDesc!: string | undefined;
    partNo!: string | undefined;
    inventoryGroupId!: number | undefined;
    isManuallyAdded!: boolean;
    productGroupName!: string | undefined;
    isInventory!: boolean;
    expiryDate!: DateTime | undefined;
    finishedDate!: DateTime | undefined;
    remark!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IGetRcvReceiptNoteLineForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.checked = _data["checked"];
            this.lineNum = _data["lineNum"];
            this.categoryId = _data["categoryId"];
            this.quantityShipped = _data["quantityShipped"];
            this.quantityReceived = _data["quantityReceived"];
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.itemDescription = _data["itemDescription"];
            this.itemId = _data["itemId"];
            this.itemRevision = _data["itemRevision"];
            this.shipmentLineStatusCode = _data["shipmentLineStatusCode"];
            this.sourceDocumentCode = _data["sourceDocumentCode"];
            this.poHeaderId = _data["poHeaderId"];
            this.poLineId = _data["poLineId"];
            this.poLineShipmentId = _data["poLineShipmentId"];
            this.poDistributionId = _data["poDistributionId"];
            this.routingHeaderId = _data["routingHeaderId"];
            this.deliverToPersonId = _data["deliverToPersonId"];
            this.employeeId = _data["employeeId"];
            this.destinationTypeCode = _data["destinationTypeCode"];
            this.toOrganizationId = _data["toOrganizationId"];
            this.toSubinventory = _data["toSubinventory"];
            this.locatorId = _data["locatorId"];
            this.deliverToLocationId = _data["deliverToLocationId"];
            this.requestId = _data["requestId"];
            this.primaryUnitOfMeasure = _data["primaryUnitOfMeasure"];
            this.asnLineFlag = _data["asnLineFlag"];
            this.shipToLocationId = _data["shipToLocationId"];
            this.countryOfOriginCode = _data["countryOfOriginCode"];
            this.secondaryQuantityReceived = _data["secondaryQuantityReceived"];
            this.amountReceived = _data["amountReceived"];
            this.receiptNoteHeaderId = _data["receiptNoteHeaderId"];
            this.receiptNoteLineId = _data["receiptNoteLineId"];
            this.quantityOrdered = _data["quantityOrdered"];
            this.quantityAccumulated = _data["quantityAccumulated"];
            this.quantityRemained = _data["quantityRemained"];
            this.quantityAvailable = _data["quantityAvailable"];
            this.poNo = _data["poNo"];
            this.vendorName = _data["vendorName"];
            this.vendorSiteCode = _data["vendorSiteCode"];
            this.needByDate = _data["needByDate"] ? DateTime.fromISO(_data["needByDate"].toString()) : <any>undefined;
            this.poTypeLookupCode = _data["poTypeLookupCode"];
            this.destination = _data["destination"];
            this.receivingRoutingDesc = _data["receivingRoutingDesc"];
            this.categoryDesc = _data["categoryDesc"];
            this.partNo = _data["partNo"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.isManuallyAdded = _data["isManuallyAdded"];
            this.productGroupName = _data["productGroupName"];
            this.isInventory = _data["isInventory"];
            this.expiryDate = _data["expiryDate"] ? DateTime.fromISO(_data["expiryDate"].toString()) : <any>undefined;
            this.finishedDate = _data["finishedDate"] ? DateTime.fromISO(_data["finishedDate"].toString()) : <any>undefined;
            this.remark = _data["remark"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): GetRcvReceiptNoteLineForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRcvReceiptNoteLineForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["checked"] = this.checked;
        data["lineNum"] = this.lineNum;
        data["categoryId"] = this.categoryId;
        data["quantityShipped"] = this.quantityShipped;
        data["quantityReceived"] = this.quantityReceived;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["itemDescription"] = this.itemDescription;
        data["itemId"] = this.itemId;
        data["itemRevision"] = this.itemRevision;
        data["shipmentLineStatusCode"] = this.shipmentLineStatusCode;
        data["sourceDocumentCode"] = this.sourceDocumentCode;
        data["poHeaderId"] = this.poHeaderId;
        data["poLineId"] = this.poLineId;
        data["poLineShipmentId"] = this.poLineShipmentId;
        data["poDistributionId"] = this.poDistributionId;
        data["routingHeaderId"] = this.routingHeaderId;
        data["deliverToPersonId"] = this.deliverToPersonId;
        data["employeeId"] = this.employeeId;
        data["destinationTypeCode"] = this.destinationTypeCode;
        data["toOrganizationId"] = this.toOrganizationId;
        data["toSubinventory"] = this.toSubinventory;
        data["locatorId"] = this.locatorId;
        data["deliverToLocationId"] = this.deliverToLocationId;
        data["requestId"] = this.requestId;
        data["primaryUnitOfMeasure"] = this.primaryUnitOfMeasure;
        data["asnLineFlag"] = this.asnLineFlag;
        data["shipToLocationId"] = this.shipToLocationId;
        data["countryOfOriginCode"] = this.countryOfOriginCode;
        data["secondaryQuantityReceived"] = this.secondaryQuantityReceived;
        data["amountReceived"] = this.amountReceived;
        data["receiptNoteHeaderId"] = this.receiptNoteHeaderId;
        data["receiptNoteLineId"] = this.receiptNoteLineId;
        data["quantityOrdered"] = this.quantityOrdered;
        data["quantityAccumulated"] = this.quantityAccumulated;
        data["quantityRemained"] = this.quantityRemained;
        data["quantityAvailable"] = this.quantityAvailable;
        data["poNo"] = this.poNo;
        data["vendorName"] = this.vendorName;
        data["vendorSiteCode"] = this.vendorSiteCode;
        data["needByDate"] = this.needByDate ? this.needByDate.toString() : <any>undefined;
        data["poTypeLookupCode"] = this.poTypeLookupCode;
        data["destination"] = this.destination;
        data["receivingRoutingDesc"] = this.receivingRoutingDesc;
        data["categoryDesc"] = this.categoryDesc;
        data["partNo"] = this.partNo;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["isManuallyAdded"] = this.isManuallyAdded;
        data["productGroupName"] = this.productGroupName;
        data["isInventory"] = this.isInventory;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toString() : <any>undefined;
        data["finishedDate"] = this.finishedDate ? this.finishedDate.toString() : <any>undefined;
        data["remark"] = this.remark;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data;
    }
}

export interface IGetRcvReceiptNoteLineForEditDto {
    id: number;
    checked: boolean;
    lineNum: number | undefined;
    categoryId: number | undefined;
    quantityShipped: number | undefined;
    quantityReceived: number | undefined;
    unitOfMeasure: string | undefined;
    itemDescription: string | undefined;
    itemId: number | undefined;
    itemRevision: string | undefined;
    shipmentLineStatusCode: string | undefined;
    sourceDocumentCode: string | undefined;
    poHeaderId: number | undefined;
    poLineId: number | undefined;
    poLineShipmentId: number | undefined;
    poDistributionId: number | undefined;
    routingHeaderId: number | undefined;
    deliverToPersonId: number | undefined;
    employeeId: number | undefined;
    destinationTypeCode: string | undefined;
    toOrganizationId: number | undefined;
    toSubinventory: string | undefined;
    locatorId: number | undefined;
    deliverToLocationId: number | undefined;
    requestId: number | undefined;
    primaryUnitOfMeasure: string | undefined;
    asnLineFlag: string | undefined;
    shipToLocationId: number | undefined;
    countryOfOriginCode: string | undefined;
    secondaryQuantityReceived: number | undefined;
    amountReceived: number | undefined;
    receiptNoteHeaderId: number | undefined;
    receiptNoteLineId: number | undefined;
    quantityOrdered: number | undefined;
    quantityAccumulated: number | undefined;
    quantityRemained: number | undefined;
    quantityAvailable: number | undefined;
    poNo: string | undefined;
    vendorName: string | undefined;
    vendorSiteCode: string | undefined;
    needByDate: DateTime | undefined;
    poTypeLookupCode: string | undefined;
    destination: string | undefined;
    receivingRoutingDesc: string | undefined;
    categoryDesc: string | undefined;
    partNo: string | undefined;
    inventoryGroupId: number | undefined;
    isManuallyAdded: boolean;
    productGroupName: string | undefined;
    isInventory: boolean;
    expiryDate: DateTime | undefined;
    finishedDate: DateTime | undefined;
    remark: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class PagedResultDtoOfGetRcvReceiptNoteLineForEditDto implements IPagedResultDtoOfGetRcvReceiptNoteLineForEditDto {
    totalCount!: number;
    items!: GetRcvReceiptNoteLineForEditDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRcvReceiptNoteLineForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetRcvReceiptNoteLineForEditDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRcvReceiptNoteLineForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRcvReceiptNoteLineForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetRcvReceiptNoteLineForEditDto {
    totalCount: number;
    items: GetRcvReceiptNoteLineForEditDto[] | undefined;
}

export class GetRcvReceiptNoteHeaderForEditDto implements IGetRcvReceiptNoteHeaderForEditDto {
    id!: number;
    receiptSourceCode!: string | undefined;
    vendorId!: number | undefined;
    vendorSiteId!: number | undefined;
    organizationId!: number | undefined;
    shipmentNum!: string | undefined;
    receiptNoteNum!: string | undefined;
    receivedDate!: DateTime | undefined;
    billOfLading!: string | undefined;
    shippedDate!: DateTime | undefined;
    employeeId!: number | undefined;
    waybillAirbillNum!: string | undefined;
    comments!: string | undefined;
    shipToOrgId!: number | undefined;
    serviceStartDate!: DateTime | undefined;
    serviceEndDate!: DateTime | undefined;
    inventoryGroupId!: number | undefined;
    receiptNoteType!: number;
    employeeId2!: number | undefined;
    deliverName1!: string | undefined;
    deliverTitle1!: string | undefined;
    deliverName2!: string | undefined;
    deliverTitle2!: string | undefined;
    employeeName1!: string | undefined;
    employeeName2!: string | undefined;
    employeeTitle1!: string | undefined;
    employeeTitle2!: string | undefined;
    creatorUser!: string | undefined;
    isInventory!: boolean;
    inputRcvReceiptNoteLinesDto!: GetRcvReceiptNoteLineForEditDto[] | undefined;

    constructor(data?: IGetRcvReceiptNoteHeaderForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.receiptSourceCode = _data["receiptSourceCode"];
            this.vendorId = _data["vendorId"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.organizationId = _data["organizationId"];
            this.shipmentNum = _data["shipmentNum"];
            this.receiptNoteNum = _data["receiptNoteNum"];
            this.receivedDate = _data["receivedDate"] ? DateTime.fromISO(_data["receivedDate"].toString()) : <any>undefined;
            this.billOfLading = _data["billOfLading"];
            this.shippedDate = _data["shippedDate"] ? DateTime.fromISO(_data["shippedDate"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.waybillAirbillNum = _data["waybillAirbillNum"];
            this.comments = _data["comments"];
            this.shipToOrgId = _data["shipToOrgId"];
            this.serviceStartDate = _data["serviceStartDate"] ? DateTime.fromISO(_data["serviceStartDate"].toString()) : <any>undefined;
            this.serviceEndDate = _data["serviceEndDate"] ? DateTime.fromISO(_data["serviceEndDate"].toString()) : <any>undefined;
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.receiptNoteType = _data["receiptNoteType"];
            this.employeeId2 = _data["employeeId2"];
            this.deliverName1 = _data["deliverName1"];
            this.deliverTitle1 = _data["deliverTitle1"];
            this.deliverName2 = _data["deliverName2"];
            this.deliverTitle2 = _data["deliverTitle2"];
            this.employeeName1 = _data["employeeName1"];
            this.employeeName2 = _data["employeeName2"];
            this.employeeTitle1 = _data["employeeTitle1"];
            this.employeeTitle2 = _data["employeeTitle2"];
            this.creatorUser = _data["creatorUser"];
            this.isInventory = _data["isInventory"];
            if (Array.isArray(_data["inputRcvReceiptNoteLinesDto"])) {
                this.inputRcvReceiptNoteLinesDto = [] as any;
                for (let item of _data["inputRcvReceiptNoteLinesDto"])
                    this.inputRcvReceiptNoteLinesDto!.push(GetRcvReceiptNoteLineForEditDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRcvReceiptNoteHeaderForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRcvReceiptNoteHeaderForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["receiptSourceCode"] = this.receiptSourceCode;
        data["vendorId"] = this.vendorId;
        data["vendorSiteId"] = this.vendorSiteId;
        data["organizationId"] = this.organizationId;
        data["shipmentNum"] = this.shipmentNum;
        data["receiptNoteNum"] = this.receiptNoteNum;
        data["receivedDate"] = this.receivedDate ? this.receivedDate.toString() : <any>undefined;
        data["billOfLading"] = this.billOfLading;
        data["shippedDate"] = this.shippedDate ? this.shippedDate.toString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["waybillAirbillNum"] = this.waybillAirbillNum;
        data["comments"] = this.comments;
        data["shipToOrgId"] = this.shipToOrgId;
        data["serviceStartDate"] = this.serviceStartDate ? this.serviceStartDate.toString() : <any>undefined;
        data["serviceEndDate"] = this.serviceEndDate ? this.serviceEndDate.toString() : <any>undefined;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["receiptNoteType"] = this.receiptNoteType;
        data["employeeId2"] = this.employeeId2;
        data["deliverName1"] = this.deliverName1;
        data["deliverTitle1"] = this.deliverTitle1;
        data["deliverName2"] = this.deliverName2;
        data["deliverTitle2"] = this.deliverTitle2;
        data["employeeName1"] = this.employeeName1;
        data["employeeName2"] = this.employeeName2;
        data["employeeTitle1"] = this.employeeTitle1;
        data["employeeTitle2"] = this.employeeTitle2;
        data["creatorUser"] = this.creatorUser;
        data["isInventory"] = this.isInventory;
        if (Array.isArray(this.inputRcvReceiptNoteLinesDto)) {
            data["inputRcvReceiptNoteLinesDto"] = [];
            for (let item of this.inputRcvReceiptNoteLinesDto)
                data["inputRcvReceiptNoteLinesDto"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetRcvReceiptNoteHeaderForEditDto {
    id: number;
    receiptSourceCode: string | undefined;
    vendorId: number | undefined;
    vendorSiteId: number | undefined;
    organizationId: number | undefined;
    shipmentNum: string | undefined;
    receiptNoteNum: string | undefined;
    receivedDate: DateTime | undefined;
    billOfLading: string | undefined;
    shippedDate: DateTime | undefined;
    employeeId: number | undefined;
    waybillAirbillNum: string | undefined;
    comments: string | undefined;
    shipToOrgId: number | undefined;
    serviceStartDate: DateTime | undefined;
    serviceEndDate: DateTime | undefined;
    inventoryGroupId: number | undefined;
    receiptNoteType: number;
    employeeId2: number | undefined;
    deliverName1: string | undefined;
    deliverTitle1: string | undefined;
    deliverName2: string | undefined;
    deliverTitle2: string | undefined;
    employeeName1: string | undefined;
    employeeName2: string | undefined;
    employeeTitle1: string | undefined;
    employeeTitle2: string | undefined;
    creatorUser: string | undefined;
    isInventory: boolean;
    inputRcvReceiptNoteLinesDto: GetRcvReceiptNoteLineForEditDto[] | undefined;
}

export class PagedResultDtoOfInputRcvReceiptNoteLinesDto implements IPagedResultDtoOfInputRcvReceiptNoteLinesDto {
    totalCount!: number;
    items!: InputRcvReceiptNoteLinesDto[] | undefined;

    constructor(data?: IPagedResultDtoOfInputRcvReceiptNoteLinesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InputRcvReceiptNoteLinesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfInputRcvReceiptNoteLinesDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfInputRcvReceiptNoteLinesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfInputRcvReceiptNoteLinesDto {
    totalCount: number;
    items: InputRcvReceiptNoteLinesDto[] | undefined;
}

export class GetReceiptNoteReportDto implements IGetReceiptNoteReportDto {
    id!: number;
    receiptSourceCode!: string | undefined;
    vendorId!: number | undefined;
    vendorSiteId!: number | undefined;
    organizationId!: number | undefined;
    shipmentNum!: string | undefined;
    receiptNoteNum!: string | undefined;
    receivedDate!: DateTime | undefined;
    billOfLading!: string | undefined;
    shippedDate!: DateTime | undefined;
    employeeId!: number | undefined;
    waybillAirbillNum!: string | undefined;
    comments!: string | undefined;
    shipToOrgId!: number | undefined;
    poNo!: string | undefined;
    status!: number;
    vendorName!: string | undefined;
    vendorSiteCode!: string | undefined;
    receiptNoteType!: number;
    employeeId2!: number | undefined;
    serviceStartDate!: DateTime | undefined;
    serviceEndDate!: DateTime | undefined;
    deliverName1!: string | undefined;
    deliverTitle1!: string | undefined;
    deliverName2!: string | undefined;
    deliverTitle2!: string | undefined;
    employeeName1!: string | undefined;
    employeeName2!: string | undefined;
    employeeTitle1!: string | undefined;
    employeeTitle2!: string | undefined;
    fromType!: number;
    rnLines!: InputRcvReceiptNoteLinesDto[] | undefined;

    constructor(data?: IGetReceiptNoteReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.receiptSourceCode = _data["receiptSourceCode"];
            this.vendorId = _data["vendorId"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.organizationId = _data["organizationId"];
            this.shipmentNum = _data["shipmentNum"];
            this.receiptNoteNum = _data["receiptNoteNum"];
            this.receivedDate = _data["receivedDate"] ? DateTime.fromISO(_data["receivedDate"].toString()) : <any>undefined;
            this.billOfLading = _data["billOfLading"];
            this.shippedDate = _data["shippedDate"] ? DateTime.fromISO(_data["shippedDate"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.waybillAirbillNum = _data["waybillAirbillNum"];
            this.comments = _data["comments"];
            this.shipToOrgId = _data["shipToOrgId"];
            this.poNo = _data["poNo"];
            this.status = _data["status"];
            this.vendorName = _data["vendorName"];
            this.vendorSiteCode = _data["vendorSiteCode"];
            this.receiptNoteType = _data["receiptNoteType"];
            this.employeeId2 = _data["employeeId2"];
            this.serviceStartDate = _data["serviceStartDate"] ? DateTime.fromISO(_data["serviceStartDate"].toString()) : <any>undefined;
            this.serviceEndDate = _data["serviceEndDate"] ? DateTime.fromISO(_data["serviceEndDate"].toString()) : <any>undefined;
            this.deliverName1 = _data["deliverName1"];
            this.deliverTitle1 = _data["deliverTitle1"];
            this.deliverName2 = _data["deliverName2"];
            this.deliverTitle2 = _data["deliverTitle2"];
            this.employeeName1 = _data["employeeName1"];
            this.employeeName2 = _data["employeeName2"];
            this.employeeTitle1 = _data["employeeTitle1"];
            this.employeeTitle2 = _data["employeeTitle2"];
            this.fromType = _data["fromType"];
            if (Array.isArray(_data["rnLines"])) {
                this.rnLines = [] as any;
                for (let item of _data["rnLines"])
                    this.rnLines!.push(InputRcvReceiptNoteLinesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetReceiptNoteReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetReceiptNoteReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["receiptSourceCode"] = this.receiptSourceCode;
        data["vendorId"] = this.vendorId;
        data["vendorSiteId"] = this.vendorSiteId;
        data["organizationId"] = this.organizationId;
        data["shipmentNum"] = this.shipmentNum;
        data["receiptNoteNum"] = this.receiptNoteNum;
        data["receivedDate"] = this.receivedDate ? this.receivedDate.toString() : <any>undefined;
        data["billOfLading"] = this.billOfLading;
        data["shippedDate"] = this.shippedDate ? this.shippedDate.toString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["waybillAirbillNum"] = this.waybillAirbillNum;
        data["comments"] = this.comments;
        data["shipToOrgId"] = this.shipToOrgId;
        data["poNo"] = this.poNo;
        data["status"] = this.status;
        data["vendorName"] = this.vendorName;
        data["vendorSiteCode"] = this.vendorSiteCode;
        data["receiptNoteType"] = this.receiptNoteType;
        data["employeeId2"] = this.employeeId2;
        data["serviceStartDate"] = this.serviceStartDate ? this.serviceStartDate.toString() : <any>undefined;
        data["serviceEndDate"] = this.serviceEndDate ? this.serviceEndDate.toString() : <any>undefined;
        data["deliverName1"] = this.deliverName1;
        data["deliverTitle1"] = this.deliverTitle1;
        data["deliverName2"] = this.deliverName2;
        data["deliverTitle2"] = this.deliverTitle2;
        data["employeeName1"] = this.employeeName1;
        data["employeeName2"] = this.employeeName2;
        data["employeeTitle1"] = this.employeeTitle1;
        data["employeeTitle2"] = this.employeeTitle2;
        data["fromType"] = this.fromType;
        if (Array.isArray(this.rnLines)) {
            data["rnLines"] = [];
            for (let item of this.rnLines)
                data["rnLines"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetReceiptNoteReportDto {
    id: number;
    receiptSourceCode: string | undefined;
    vendorId: number | undefined;
    vendorSiteId: number | undefined;
    organizationId: number | undefined;
    shipmentNum: string | undefined;
    receiptNoteNum: string | undefined;
    receivedDate: DateTime | undefined;
    billOfLading: string | undefined;
    shippedDate: DateTime | undefined;
    employeeId: number | undefined;
    waybillAirbillNum: string | undefined;
    comments: string | undefined;
    shipToOrgId: number | undefined;
    poNo: string | undefined;
    status: number;
    vendorName: string | undefined;
    vendorSiteCode: string | undefined;
    receiptNoteType: number;
    employeeId2: number | undefined;
    serviceStartDate: DateTime | undefined;
    serviceEndDate: DateTime | undefined;
    deliverName1: string | undefined;
    deliverTitle1: string | undefined;
    deliverName2: string | undefined;
    deliverTitle2: string | undefined;
    employeeName1: string | undefined;
    employeeName2: string | undefined;
    employeeTitle1: string | undefined;
    employeeTitle2: string | undefined;
    fromType: number;
    rnLines: InputRcvReceiptNoteLinesDto[] | undefined;
}

export class SearchAllReceiptNotesDto implements ISearchAllReceiptNotesDto {
    receiptNoteNum!: string | undefined;
    vendorId!: number | undefined;
    vendorSiteId!: number | undefined;
    status!: number | undefined;
    receiptNoteType!: number;
    shippedDateFrom!: DateTime | undefined;
    shippedDateTo!: DateTime | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ISearchAllReceiptNotesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.receiptNoteNum = _data["receiptNoteNum"];
            this.vendorId = _data["vendorId"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.status = _data["status"];
            this.receiptNoteType = _data["receiptNoteType"];
            this.shippedDateFrom = _data["shippedDateFrom"] ? DateTime.fromISO(_data["shippedDateFrom"].toString()) : <any>undefined;
            this.shippedDateTo = _data["shippedDateTo"] ? DateTime.fromISO(_data["shippedDateTo"].toString()) : <any>undefined;
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): SearchAllReceiptNotesDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchAllReceiptNotesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiptNoteNum"] = this.receiptNoteNum;
        data["vendorId"] = this.vendorId;
        data["vendorSiteId"] = this.vendorSiteId;
        data["status"] = this.status;
        data["receiptNoteType"] = this.receiptNoteType;
        data["shippedDateFrom"] = this.shippedDateFrom ? this.shippedDateFrom.toString() : <any>undefined;
        data["shippedDateTo"] = this.shippedDateTo ? this.shippedDateTo.toString() : <any>undefined;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data;
    }
}

export interface ISearchAllReceiptNotesDto {
    receiptNoteNum: string | undefined;
    vendorId: number | undefined;
    vendorSiteId: number | undefined;
    status: number | undefined;
    receiptNoteType: number;
    shippedDateFrom: DateTime | undefined;
    shippedDateTo: DateTime | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class GetRcvRoutingHeadersDto implements IGetRcvRoutingHeadersDto {
    id!: number;
    routingName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IGetRcvRoutingHeadersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.routingName = _data["routingName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GetRcvRoutingHeadersDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRcvRoutingHeadersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["routingName"] = this.routingName;
        data["description"] = this.description;
        return data;
    }
}

export interface IGetRcvRoutingHeadersDto {
    id: number;
    routingName: string | undefined;
    description: string | undefined;
}

export class ExpectedReceiptsDto implements IExpectedReceiptsDto {
    checked!: boolean;
    quantityShipped!: number | undefined;
    quantityReceived!: number | undefined;
    unitOfMeasure!: string | undefined;
    destinationTypeCode!: string | undefined;
    itemDescription!: string | undefined;
    itemId!: number | undefined;
    preparerId!: number | undefined;
    deliverToLocationId!: number | undefined;
    toSubinventory!: string | undefined;
    locatorId!: number | undefined;
    categoryId!: number | undefined;
    countryOfOriginCode!: string | undefined;
    poHeaderId!: number | undefined;
    poLineId!: number | undefined;
    poLineShipmentId!: number | undefined;
    poDistributionId!: number | undefined;
    receivingRoutingId!: number | undefined;
    deliverToPersonId!: number | undefined;
    poTypeLookupCode!: string | undefined;
    poNo!: string | undefined;
    vendorId!: number | undefined;
    vendorName!: string | undefined;
    vendorSiteCode!: string | undefined;
    needByDate!: DateTime | undefined;
    destination!: string | undefined;
    quantityOrdered!: number | undefined;
    quantityAccumulated!: number | undefined;
    quantityRemained!: number | undefined;
    quantityAvailable!: number | undefined;
    categoryDesc!: string | undefined;
    partNo!: string | undefined;
    inventoryGroupId!: number | undefined;
    isManuallyAdded!: boolean;
    productGroupName!: string | undefined;
    isInventory!: boolean;

    constructor(data?: IExpectedReceiptsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checked = _data["checked"];
            this.quantityShipped = _data["quantityShipped"];
            this.quantityReceived = _data["quantityReceived"];
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.destinationTypeCode = _data["destinationTypeCode"];
            this.itemDescription = _data["itemDescription"];
            this.itemId = _data["itemId"];
            this.preparerId = _data["preparerId"];
            this.deliverToLocationId = _data["deliverToLocationId"];
            this.toSubinventory = _data["toSubinventory"];
            this.locatorId = _data["locatorId"];
            this.categoryId = _data["categoryId"];
            this.countryOfOriginCode = _data["countryOfOriginCode"];
            this.poHeaderId = _data["poHeaderId"];
            this.poLineId = _data["poLineId"];
            this.poLineShipmentId = _data["poLineShipmentId"];
            this.poDistributionId = _data["poDistributionId"];
            this.receivingRoutingId = _data["receivingRoutingId"];
            this.deliverToPersonId = _data["deliverToPersonId"];
            this.poTypeLookupCode = _data["poTypeLookupCode"];
            this.poNo = _data["poNo"];
            this.vendorId = _data["vendorId"];
            this.vendorName = _data["vendorName"];
            this.vendorSiteCode = _data["vendorSiteCode"];
            this.needByDate = _data["needByDate"] ? DateTime.fromISO(_data["needByDate"].toString()) : <any>undefined;
            this.destination = _data["destination"];
            this.quantityOrdered = _data["quantityOrdered"];
            this.quantityAccumulated = _data["quantityAccumulated"];
            this.quantityRemained = _data["quantityRemained"];
            this.quantityAvailable = _data["quantityAvailable"];
            this.categoryDesc = _data["categoryDesc"];
            this.partNo = _data["partNo"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.isManuallyAdded = _data["isManuallyAdded"];
            this.productGroupName = _data["productGroupName"];
            this.isInventory = _data["isInventory"];
        }
    }

    static fromJS(data: any): ExpectedReceiptsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExpectedReceiptsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checked"] = this.checked;
        data["quantityShipped"] = this.quantityShipped;
        data["quantityReceived"] = this.quantityReceived;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["destinationTypeCode"] = this.destinationTypeCode;
        data["itemDescription"] = this.itemDescription;
        data["itemId"] = this.itemId;
        data["preparerId"] = this.preparerId;
        data["deliverToLocationId"] = this.deliverToLocationId;
        data["toSubinventory"] = this.toSubinventory;
        data["locatorId"] = this.locatorId;
        data["categoryId"] = this.categoryId;
        data["countryOfOriginCode"] = this.countryOfOriginCode;
        data["poHeaderId"] = this.poHeaderId;
        data["poLineId"] = this.poLineId;
        data["poLineShipmentId"] = this.poLineShipmentId;
        data["poDistributionId"] = this.poDistributionId;
        data["receivingRoutingId"] = this.receivingRoutingId;
        data["deliverToPersonId"] = this.deliverToPersonId;
        data["poTypeLookupCode"] = this.poTypeLookupCode;
        data["poNo"] = this.poNo;
        data["vendorId"] = this.vendorId;
        data["vendorName"] = this.vendorName;
        data["vendorSiteCode"] = this.vendorSiteCode;
        data["needByDate"] = this.needByDate ? this.needByDate.toString() : <any>undefined;
        data["destination"] = this.destination;
        data["quantityOrdered"] = this.quantityOrdered;
        data["quantityAccumulated"] = this.quantityAccumulated;
        data["quantityRemained"] = this.quantityRemained;
        data["quantityAvailable"] = this.quantityAvailable;
        data["categoryDesc"] = this.categoryDesc;
        data["partNo"] = this.partNo;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["isManuallyAdded"] = this.isManuallyAdded;
        data["productGroupName"] = this.productGroupName;
        data["isInventory"] = this.isInventory;
        return data;
    }
}

export interface IExpectedReceiptsDto {
    checked: boolean;
    quantityShipped: number | undefined;
    quantityReceived: number | undefined;
    unitOfMeasure: string | undefined;
    destinationTypeCode: string | undefined;
    itemDescription: string | undefined;
    itemId: number | undefined;
    preparerId: number | undefined;
    deliverToLocationId: number | undefined;
    toSubinventory: string | undefined;
    locatorId: number | undefined;
    categoryId: number | undefined;
    countryOfOriginCode: string | undefined;
    poHeaderId: number | undefined;
    poLineId: number | undefined;
    poLineShipmentId: number | undefined;
    poDistributionId: number | undefined;
    receivingRoutingId: number | undefined;
    deliverToPersonId: number | undefined;
    poTypeLookupCode: string | undefined;
    poNo: string | undefined;
    vendorId: number | undefined;
    vendorName: string | undefined;
    vendorSiteCode: string | undefined;
    needByDate: DateTime | undefined;
    destination: string | undefined;
    quantityOrdered: number | undefined;
    quantityAccumulated: number | undefined;
    quantityRemained: number | undefined;
    quantityAvailable: number | undefined;
    categoryDesc: string | undefined;
    partNo: string | undefined;
    inventoryGroupId: number | undefined;
    isManuallyAdded: boolean;
    productGroupName: string | undefined;
    isInventory: boolean;
}

export class PagedResultDtoOfExpectedReceiptsDto implements IPagedResultDtoOfExpectedReceiptsDto {
    totalCount!: number;
    items!: ExpectedReceiptsDto[] | undefined;

    constructor(data?: IPagedResultDtoOfExpectedReceiptsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExpectedReceiptsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfExpectedReceiptsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfExpectedReceiptsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfExpectedReceiptsDto {
    totalCount: number;
    items: ExpectedReceiptsDto[] | undefined;
}

export class RcvShipmentAttachmentsDto implements IRcvShipmentAttachmentsDto {
    id!: number;
    shipmentHeaderId!: number;
    serverFileName!: string | undefined;
    serverLink!: string | undefined;
    contentType!: string | undefined;

    constructor(data?: IRcvShipmentAttachmentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.shipmentHeaderId = _data["shipmentHeaderId"];
            this.serverFileName = _data["serverFileName"];
            this.serverLink = _data["serverLink"];
            this.contentType = _data["contentType"];
        }
    }

    static fromJS(data: any): RcvShipmentAttachmentsDto {
        data = typeof data === 'object' ? data : {};
        let result = new RcvShipmentAttachmentsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["shipmentHeaderId"] = this.shipmentHeaderId;
        data["serverFileName"] = this.serverFileName;
        data["serverLink"] = this.serverLink;
        data["contentType"] = this.contentType;
        return data;
    }
}

export interface IRcvShipmentAttachmentsDto {
    id: number;
    shipmentHeaderId: number;
    serverFileName: string | undefined;
    serverLink: string | undefined;
    contentType: string | undefined;
}

export class InputRcvShipmentHeadersDto implements IInputRcvShipmentHeadersDto {
    totalCount!: number;
    id!: number;
    receiptSourceCode!: string | undefined;
    vendorId!: number | undefined;
    vendorSiteId!: number | undefined;
    organizationId!: number | undefined;
    shipmentNum!: string | undefined;
    receiptNum!: string | undefined;
    billOfLading!: string | undefined;
    receivedDate!: DateTime | undefined;
    shippedDate!: DateTime | undefined;
    employeeId!: number | undefined;
    waybillAirbillNum!: string | undefined;
    comments!: string | undefined;
    shipToOrgId!: number | undefined;
    vendorName!: string | undefined;
    vendorSiteCode!: string | undefined;
    employeeId2!: number | undefined;
    receiptType!: number;
    serviceStartDate!: DateTime | undefined;
    serviceEndDate!: DateTime | undefined;
    deliverName1!: string | undefined;
    deliverTitle1!: string | undefined;
    deliverName2!: string | undefined;
    deliverTitle2!: string | undefined;
    status!: number;
    employeeName1!: string | undefined;
    employeeName2!: string | undefined;
    employeeTitle1!: string | undefined;
    employeeTitle2!: string | undefined;
    authorizationStatus!: string | undefined;
    inventoryGroupId!: number | undefined;
    documentId!: number | undefined;
    documentName!: string | undefined;
    isInventory!: boolean;
    inputRcvShipmentLinesDto!: GetRcvReceiptNoteLineForEditDto[] | undefined;
    attachments!: RcvShipmentAttachmentsDto[] | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IInputRcvShipmentHeadersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.id = _data["id"];
            this.receiptSourceCode = _data["receiptSourceCode"];
            this.vendorId = _data["vendorId"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.organizationId = _data["organizationId"];
            this.shipmentNum = _data["shipmentNum"];
            this.receiptNum = _data["receiptNum"];
            this.billOfLading = _data["billOfLading"];
            this.receivedDate = _data["receivedDate"] ? DateTime.fromISO(_data["receivedDate"].toString()) : <any>undefined;
            this.shippedDate = _data["shippedDate"] ? DateTime.fromISO(_data["shippedDate"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.waybillAirbillNum = _data["waybillAirbillNum"];
            this.comments = _data["comments"];
            this.shipToOrgId = _data["shipToOrgId"];
            this.vendorName = _data["vendorName"];
            this.vendorSiteCode = _data["vendorSiteCode"];
            this.employeeId2 = _data["employeeId2"];
            this.receiptType = _data["receiptType"];
            this.serviceStartDate = _data["serviceStartDate"] ? DateTime.fromISO(_data["serviceStartDate"].toString()) : <any>undefined;
            this.serviceEndDate = _data["serviceEndDate"] ? DateTime.fromISO(_data["serviceEndDate"].toString()) : <any>undefined;
            this.deliverName1 = _data["deliverName1"];
            this.deliverTitle1 = _data["deliverTitle1"];
            this.deliverName2 = _data["deliverName2"];
            this.deliverTitle2 = _data["deliverTitle2"];
            this.status = _data["status"];
            this.employeeName1 = _data["employeeName1"];
            this.employeeName2 = _data["employeeName2"];
            this.employeeTitle1 = _data["employeeTitle1"];
            this.employeeTitle2 = _data["employeeTitle2"];
            this.authorizationStatus = _data["authorizationStatus"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.documentId = _data["documentId"];
            this.documentName = _data["documentName"];
            this.isInventory = _data["isInventory"];
            if (Array.isArray(_data["inputRcvShipmentLinesDto"])) {
                this.inputRcvShipmentLinesDto = [] as any;
                for (let item of _data["inputRcvShipmentLinesDto"])
                    this.inputRcvShipmentLinesDto!.push(GetRcvReceiptNoteLineForEditDto.fromJS(item));
            }
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(RcvShipmentAttachmentsDto.fromJS(item));
            }
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): InputRcvShipmentHeadersDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputRcvShipmentHeadersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["id"] = this.id;
        data["receiptSourceCode"] = this.receiptSourceCode;
        data["vendorId"] = this.vendorId;
        data["vendorSiteId"] = this.vendorSiteId;
        data["organizationId"] = this.organizationId;
        data["shipmentNum"] = this.shipmentNum;
        data["receiptNum"] = this.receiptNum;
        data["billOfLading"] = this.billOfLading;
        data["receivedDate"] = this.receivedDate ? this.receivedDate.toString() : <any>undefined;
        data["shippedDate"] = this.shippedDate ? this.shippedDate.toString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["waybillAirbillNum"] = this.waybillAirbillNum;
        data["comments"] = this.comments;
        data["shipToOrgId"] = this.shipToOrgId;
        data["vendorName"] = this.vendorName;
        data["vendorSiteCode"] = this.vendorSiteCode;
        data["employeeId2"] = this.employeeId2;
        data["receiptType"] = this.receiptType;
        data["serviceStartDate"] = this.serviceStartDate ? this.serviceStartDate.toString() : <any>undefined;
        data["serviceEndDate"] = this.serviceEndDate ? this.serviceEndDate.toString() : <any>undefined;
        data["deliverName1"] = this.deliverName1;
        data["deliverTitle1"] = this.deliverTitle1;
        data["deliverName2"] = this.deliverName2;
        data["deliverTitle2"] = this.deliverTitle2;
        data["status"] = this.status;
        data["employeeName1"] = this.employeeName1;
        data["employeeName2"] = this.employeeName2;
        data["employeeTitle1"] = this.employeeTitle1;
        data["employeeTitle2"] = this.employeeTitle2;
        data["authorizationStatus"] = this.authorizationStatus;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["documentId"] = this.documentId;
        data["documentName"] = this.documentName;
        data["isInventory"] = this.isInventory;
        if (Array.isArray(this.inputRcvShipmentLinesDto)) {
            data["inputRcvShipmentLinesDto"] = [];
            for (let item of this.inputRcvShipmentLinesDto)
                data["inputRcvShipmentLinesDto"].push(item.toJSON());
        }
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data;
    }
}

export interface IInputRcvShipmentHeadersDto {
    totalCount: number;
    id: number;
    receiptSourceCode: string | undefined;
    vendorId: number | undefined;
    vendorSiteId: number | undefined;
    organizationId: number | undefined;
    shipmentNum: string | undefined;
    receiptNum: string | undefined;
    billOfLading: string | undefined;
    receivedDate: DateTime | undefined;
    shippedDate: DateTime | undefined;
    employeeId: number | undefined;
    waybillAirbillNum: string | undefined;
    comments: string | undefined;
    shipToOrgId: number | undefined;
    vendorName: string | undefined;
    vendorSiteCode: string | undefined;
    employeeId2: number | undefined;
    receiptType: number;
    serviceStartDate: DateTime | undefined;
    serviceEndDate: DateTime | undefined;
    deliverName1: string | undefined;
    deliverTitle1: string | undefined;
    deliverName2: string | undefined;
    deliverTitle2: string | undefined;
    status: number;
    employeeName1: string | undefined;
    employeeName2: string | undefined;
    employeeTitle1: string | undefined;
    employeeTitle2: string | undefined;
    authorizationStatus: string | undefined;
    inventoryGroupId: number | undefined;
    documentId: number | undefined;
    documentName: string | undefined;
    isInventory: boolean;
    inputRcvShipmentLinesDto: GetRcvReceiptNoteLineForEditDto[] | undefined;
    attachments: RcvShipmentAttachmentsDto[] | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class PagedResultDtoOfInputRcvShipmentHeadersDto implements IPagedResultDtoOfInputRcvShipmentHeadersDto {
    totalCount!: number;
    items!: InputRcvShipmentHeadersDto[] | undefined;

    constructor(data?: IPagedResultDtoOfInputRcvShipmentHeadersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InputRcvShipmentHeadersDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfInputRcvShipmentHeadersDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfInputRcvShipmentHeadersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfInputRcvShipmentHeadersDto {
    totalCount: number;
    items: InputRcvShipmentHeadersDto[] | undefined;
}

export class GetRcvShipmentLineForEditDto implements IGetRcvShipmentLineForEditDto {
    id!: number;
    checked!: boolean;
    shipmentHeaderId!: number;
    lineNum!: number;
    categoryId!: number | undefined;
    quantityShipped!: number | undefined;
    quantityReceived!: number | undefined;
    quantityRemained!: number | undefined;
    quantityAccumulated!: number | undefined;
    quantityReturned!: number | undefined;
    unitOfMeasure!: string | undefined;
    itemDescription!: string | undefined;
    itemId!: number | undefined;
    itemRevision!: string | undefined;
    shipmentLineStatusCode!: string | undefined;
    sourceDocumentCode!: string | undefined;
    poHeaderId!: number | undefined;
    poLineId!: number | undefined;
    poLineShipmentId!: number | undefined;
    poDistributionId!: number | undefined;
    routingHeaderId!: number | undefined;
    deliverToPersonId!: number | undefined;
    employeeId!: number | undefined;
    destinationTypeCode!: string | undefined;
    toOrganizationId!: number | undefined;
    toSubinventory!: string | undefined;
    locatorId!: number | undefined;
    deliverToLocationId!: number | undefined;
    requestId!: number | undefined;
    primaryUnitOfMeasure!: string | undefined;
    asnLineFlag!: string | undefined;
    shipToLocationId!: number | undefined;
    countryOfOriginCode!: string | undefined;
    secondaryQuantityReceived!: number | undefined;
    amountReceived!: number | undefined;
    receivingRoutingDesc!: string | undefined;
    categoryDesc!: string | undefined;
    poTypeLookupCode!: string | undefined;
    poNo!: string | undefined;
    vendorName!: string | undefined;
    vendorSiteCode!: string | undefined;
    needByDate!: DateTime | undefined;
    destination!: string | undefined;
    partNo!: string | undefined;
    creatorUserName!: string | undefined;
    locationCode!: string | undefined;
    creationTime!: DateTime | undefined;
    remark!: string | undefined;

    constructor(data?: IGetRcvShipmentLineForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.checked = _data["checked"];
            this.shipmentHeaderId = _data["shipmentHeaderId"];
            this.lineNum = _data["lineNum"];
            this.categoryId = _data["categoryId"];
            this.quantityShipped = _data["quantityShipped"];
            this.quantityReceived = _data["quantityReceived"];
            this.quantityRemained = _data["quantityRemained"];
            this.quantityAccumulated = _data["quantityAccumulated"];
            this.quantityReturned = _data["quantityReturned"];
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.itemDescription = _data["itemDescription"];
            this.itemId = _data["itemId"];
            this.itemRevision = _data["itemRevision"];
            this.shipmentLineStatusCode = _data["shipmentLineStatusCode"];
            this.sourceDocumentCode = _data["sourceDocumentCode"];
            this.poHeaderId = _data["poHeaderId"];
            this.poLineId = _data["poLineId"];
            this.poLineShipmentId = _data["poLineShipmentId"];
            this.poDistributionId = _data["poDistributionId"];
            this.routingHeaderId = _data["routingHeaderId"];
            this.deliverToPersonId = _data["deliverToPersonId"];
            this.employeeId = _data["employeeId"];
            this.destinationTypeCode = _data["destinationTypeCode"];
            this.toOrganizationId = _data["toOrganizationId"];
            this.toSubinventory = _data["toSubinventory"];
            this.locatorId = _data["locatorId"];
            this.deliverToLocationId = _data["deliverToLocationId"];
            this.requestId = _data["requestId"];
            this.primaryUnitOfMeasure = _data["primaryUnitOfMeasure"];
            this.asnLineFlag = _data["asnLineFlag"];
            this.shipToLocationId = _data["shipToLocationId"];
            this.countryOfOriginCode = _data["countryOfOriginCode"];
            this.secondaryQuantityReceived = _data["secondaryQuantityReceived"];
            this.amountReceived = _data["amountReceived"];
            this.receivingRoutingDesc = _data["receivingRoutingDesc"];
            this.categoryDesc = _data["categoryDesc"];
            this.poTypeLookupCode = _data["poTypeLookupCode"];
            this.poNo = _data["poNo"];
            this.vendorName = _data["vendorName"];
            this.vendorSiteCode = _data["vendorSiteCode"];
            this.needByDate = _data["needByDate"] ? DateTime.fromISO(_data["needByDate"].toString()) : <any>undefined;
            this.destination = _data["destination"];
            this.partNo = _data["partNo"];
            this.creatorUserName = _data["creatorUserName"];
            this.locationCode = _data["locationCode"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.remark = _data["remark"];
        }
    }

    static fromJS(data: any): GetRcvShipmentLineForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRcvShipmentLineForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["checked"] = this.checked;
        data["shipmentHeaderId"] = this.shipmentHeaderId;
        data["lineNum"] = this.lineNum;
        data["categoryId"] = this.categoryId;
        data["quantityShipped"] = this.quantityShipped;
        data["quantityReceived"] = this.quantityReceived;
        data["quantityRemained"] = this.quantityRemained;
        data["quantityAccumulated"] = this.quantityAccumulated;
        data["quantityReturned"] = this.quantityReturned;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["itemDescription"] = this.itemDescription;
        data["itemId"] = this.itemId;
        data["itemRevision"] = this.itemRevision;
        data["shipmentLineStatusCode"] = this.shipmentLineStatusCode;
        data["sourceDocumentCode"] = this.sourceDocumentCode;
        data["poHeaderId"] = this.poHeaderId;
        data["poLineId"] = this.poLineId;
        data["poLineShipmentId"] = this.poLineShipmentId;
        data["poDistributionId"] = this.poDistributionId;
        data["routingHeaderId"] = this.routingHeaderId;
        data["deliverToPersonId"] = this.deliverToPersonId;
        data["employeeId"] = this.employeeId;
        data["destinationTypeCode"] = this.destinationTypeCode;
        data["toOrganizationId"] = this.toOrganizationId;
        data["toSubinventory"] = this.toSubinventory;
        data["locatorId"] = this.locatorId;
        data["deliverToLocationId"] = this.deliverToLocationId;
        data["requestId"] = this.requestId;
        data["primaryUnitOfMeasure"] = this.primaryUnitOfMeasure;
        data["asnLineFlag"] = this.asnLineFlag;
        data["shipToLocationId"] = this.shipToLocationId;
        data["countryOfOriginCode"] = this.countryOfOriginCode;
        data["secondaryQuantityReceived"] = this.secondaryQuantityReceived;
        data["amountReceived"] = this.amountReceived;
        data["receivingRoutingDesc"] = this.receivingRoutingDesc;
        data["categoryDesc"] = this.categoryDesc;
        data["poTypeLookupCode"] = this.poTypeLookupCode;
        data["poNo"] = this.poNo;
        data["vendorName"] = this.vendorName;
        data["vendorSiteCode"] = this.vendorSiteCode;
        data["needByDate"] = this.needByDate ? this.needByDate.toString() : <any>undefined;
        data["destination"] = this.destination;
        data["partNo"] = this.partNo;
        data["creatorUserName"] = this.creatorUserName;
        data["locationCode"] = this.locationCode;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["remark"] = this.remark;
        return data;
    }
}

export interface IGetRcvShipmentLineForEditDto {
    id: number;
    checked: boolean;
    shipmentHeaderId: number;
    lineNum: number;
    categoryId: number | undefined;
    quantityShipped: number | undefined;
    quantityReceived: number | undefined;
    quantityRemained: number | undefined;
    quantityAccumulated: number | undefined;
    quantityReturned: number | undefined;
    unitOfMeasure: string | undefined;
    itemDescription: string | undefined;
    itemId: number | undefined;
    itemRevision: string | undefined;
    shipmentLineStatusCode: string | undefined;
    sourceDocumentCode: string | undefined;
    poHeaderId: number | undefined;
    poLineId: number | undefined;
    poLineShipmentId: number | undefined;
    poDistributionId: number | undefined;
    routingHeaderId: number | undefined;
    deliverToPersonId: number | undefined;
    employeeId: number | undefined;
    destinationTypeCode: string | undefined;
    toOrganizationId: number | undefined;
    toSubinventory: string | undefined;
    locatorId: number | undefined;
    deliverToLocationId: number | undefined;
    requestId: number | undefined;
    primaryUnitOfMeasure: string | undefined;
    asnLineFlag: string | undefined;
    shipToLocationId: number | undefined;
    countryOfOriginCode: string | undefined;
    secondaryQuantityReceived: number | undefined;
    amountReceived: number | undefined;
    receivingRoutingDesc: string | undefined;
    categoryDesc: string | undefined;
    poTypeLookupCode: string | undefined;
    poNo: string | undefined;
    vendorName: string | undefined;
    vendorSiteCode: string | undefined;
    needByDate: DateTime | undefined;
    destination: string | undefined;
    partNo: string | undefined;
    creatorUserName: string | undefined;
    locationCode: string | undefined;
    creationTime: DateTime | undefined;
    remark: string | undefined;
}

export class PagedResultDtoOfGetRcvShipmentLineForEditDto implements IPagedResultDtoOfGetRcvShipmentLineForEditDto {
    totalCount!: number;
    items!: GetRcvShipmentLineForEditDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRcvShipmentLineForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetRcvShipmentLineForEditDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRcvShipmentLineForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRcvShipmentLineForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetRcvShipmentLineForEditDto {
    totalCount: number;
    items: GetRcvShipmentLineForEditDto[] | undefined;
}

export class GetRcvShipmentHeaderForViewDto implements IGetRcvShipmentHeaderForViewDto {
    id!: number;
    receiptSourceCode!: string | undefined;
    vendorId!: number | undefined;
    vendorSiteId!: number | undefined;
    organizationId!: number | undefined;
    shipmentNum!: string | undefined;
    receiptNum!: string | undefined;
    receivedDate!: DateTime | undefined;
    billOfLading!: string | undefined;
    shippedDate!: DateTime | undefined;
    employeeId!: number | undefined;
    waybillAirbillNum!: string | undefined;
    comments!: string | undefined;
    shipToOrgId!: number | undefined;
    documentId!: number | undefined;

    constructor(data?: IGetRcvShipmentHeaderForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.receiptSourceCode = _data["receiptSourceCode"];
            this.vendorId = _data["vendorId"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.organizationId = _data["organizationId"];
            this.shipmentNum = _data["shipmentNum"];
            this.receiptNum = _data["receiptNum"];
            this.receivedDate = _data["receivedDate"] ? DateTime.fromISO(_data["receivedDate"].toString()) : <any>undefined;
            this.billOfLading = _data["billOfLading"];
            this.shippedDate = _data["shippedDate"] ? DateTime.fromISO(_data["shippedDate"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.waybillAirbillNum = _data["waybillAirbillNum"];
            this.comments = _data["comments"];
            this.shipToOrgId = _data["shipToOrgId"];
            this.documentId = _data["documentId"];
        }
    }

    static fromJS(data: any): GetRcvShipmentHeaderForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRcvShipmentHeaderForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["receiptSourceCode"] = this.receiptSourceCode;
        data["vendorId"] = this.vendorId;
        data["vendorSiteId"] = this.vendorSiteId;
        data["organizationId"] = this.organizationId;
        data["shipmentNum"] = this.shipmentNum;
        data["receiptNum"] = this.receiptNum;
        data["receivedDate"] = this.receivedDate ? this.receivedDate.toString() : <any>undefined;
        data["billOfLading"] = this.billOfLading;
        data["shippedDate"] = this.shippedDate ? this.shippedDate.toString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["waybillAirbillNum"] = this.waybillAirbillNum;
        data["comments"] = this.comments;
        data["shipToOrgId"] = this.shipToOrgId;
        data["documentId"] = this.documentId;
        return data;
    }
}

export interface IGetRcvShipmentHeaderForViewDto {
    id: number;
    receiptSourceCode: string | undefined;
    vendorId: number | undefined;
    vendorSiteId: number | undefined;
    organizationId: number | undefined;
    shipmentNum: string | undefined;
    receiptNum: string | undefined;
    receivedDate: DateTime | undefined;
    billOfLading: string | undefined;
    shippedDate: DateTime | undefined;
    employeeId: number | undefined;
    waybillAirbillNum: string | undefined;
    comments: string | undefined;
    shipToOrgId: number | undefined;
    documentId: number | undefined;
}

export class GetRcvShipmentHeaderForEditDto implements IGetRcvShipmentHeaderForEditDto {
    id!: number;
    receiptSourceCode!: string | undefined;
    vendorId!: number | undefined;
    vendorSiteId!: number | undefined;
    organizationId!: number | undefined;
    shipmentNum!: string | undefined;
    receiptNum!: string | undefined;
    receivedDate!: DateTime | undefined;
    billOfLading!: string | undefined;
    shippedDate!: DateTime | undefined;
    employeeId!: number | undefined;
    waybillAirbillNum!: string | undefined;
    comments!: string | undefined;
    shipToOrgId!: number | undefined;
    rcvShipmentLines!: GetRcvShipmentLineForEditDto[] | undefined;

    constructor(data?: IGetRcvShipmentHeaderForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.receiptSourceCode = _data["receiptSourceCode"];
            this.vendorId = _data["vendorId"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.organizationId = _data["organizationId"];
            this.shipmentNum = _data["shipmentNum"];
            this.receiptNum = _data["receiptNum"];
            this.receivedDate = _data["receivedDate"] ? DateTime.fromISO(_data["receivedDate"].toString()) : <any>undefined;
            this.billOfLading = _data["billOfLading"];
            this.shippedDate = _data["shippedDate"] ? DateTime.fromISO(_data["shippedDate"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.waybillAirbillNum = _data["waybillAirbillNum"];
            this.comments = _data["comments"];
            this.shipToOrgId = _data["shipToOrgId"];
            if (Array.isArray(_data["rcvShipmentLines"])) {
                this.rcvShipmentLines = [] as any;
                for (let item of _data["rcvShipmentLines"])
                    this.rcvShipmentLines!.push(GetRcvShipmentLineForEditDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRcvShipmentHeaderForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRcvShipmentHeaderForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["receiptSourceCode"] = this.receiptSourceCode;
        data["vendorId"] = this.vendorId;
        data["vendorSiteId"] = this.vendorSiteId;
        data["organizationId"] = this.organizationId;
        data["shipmentNum"] = this.shipmentNum;
        data["receiptNum"] = this.receiptNum;
        data["receivedDate"] = this.receivedDate ? this.receivedDate.toString() : <any>undefined;
        data["billOfLading"] = this.billOfLading;
        data["shippedDate"] = this.shippedDate ? this.shippedDate.toString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["waybillAirbillNum"] = this.waybillAirbillNum;
        data["comments"] = this.comments;
        data["shipToOrgId"] = this.shipToOrgId;
        if (Array.isArray(this.rcvShipmentLines)) {
            data["rcvShipmentLines"] = [];
            for (let item of this.rcvShipmentLines)
                data["rcvShipmentLines"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetRcvShipmentHeaderForEditDto {
    id: number;
    receiptSourceCode: string | undefined;
    vendorId: number | undefined;
    vendorSiteId: number | undefined;
    organizationId: number | undefined;
    shipmentNum: string | undefined;
    receiptNum: string | undefined;
    receivedDate: DateTime | undefined;
    billOfLading: string | undefined;
    shippedDate: DateTime | undefined;
    employeeId: number | undefined;
    waybillAirbillNum: string | undefined;
    comments: string | undefined;
    shipToOrgId: number | undefined;
    rcvShipmentLines: GetRcvShipmentLineForEditDto[] | undefined;
}

export class SearchAllReceiptsDto implements ISearchAllReceiptsDto {
    receiptNum!: string | undefined;
    vendorId!: number | undefined;
    vendorSiteId!: number | undefined;
    status!: number | undefined;
    authorizationStatus!: string | undefined;
    receiptType!: number;
    receivedDateFrom!: DateTime | undefined;
    receivedDateTo!: DateTime | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ISearchAllReceiptsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.receiptNum = _data["receiptNum"];
            this.vendorId = _data["vendorId"];
            this.vendorSiteId = _data["vendorSiteId"];
            this.status = _data["status"];
            this.authorizationStatus = _data["authorizationStatus"];
            this.receiptType = _data["receiptType"];
            this.receivedDateFrom = _data["receivedDateFrom"] ? DateTime.fromISO(_data["receivedDateFrom"].toString()) : <any>undefined;
            this.receivedDateTo = _data["receivedDateTo"] ? DateTime.fromISO(_data["receivedDateTo"].toString()) : <any>undefined;
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): SearchAllReceiptsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchAllReceiptsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiptNum"] = this.receiptNum;
        data["vendorId"] = this.vendorId;
        data["vendorSiteId"] = this.vendorSiteId;
        data["status"] = this.status;
        data["authorizationStatus"] = this.authorizationStatus;
        data["receiptType"] = this.receiptType;
        data["receivedDateFrom"] = this.receivedDateFrom ? this.receivedDateFrom.toString() : <any>undefined;
        data["receivedDateTo"] = this.receivedDateTo ? this.receivedDateTo.toString() : <any>undefined;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data;
    }
}

export interface ISearchAllReceiptsDto {
    receiptNum: string | undefined;
    vendorId: number | undefined;
    vendorSiteId: number | undefined;
    status: number | undefined;
    authorizationStatus: string | undefined;
    receiptType: number;
    receivedDateFrom: DateTime | undefined;
    receivedDateTo: DateTime | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class ReturnLinesDto implements IReturnLinesDto {
    headerId!: number;
    id!: number;
    receiptNum!: string | undefined;
    poNo!: string | undefined;
    partNo!: string | undefined;
    itemDescription!: string | undefined;
    quantityReceived!: number | undefined;
    unitOfMeasure!: string | undefined;
    creationTime!: DateTime | undefined;
    supplierName!: string | undefined;
    remark!: string | undefined;
    totalCount!: number;

    constructor(data?: IReturnLinesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.headerId = _data["headerId"];
            this.id = _data["id"];
            this.receiptNum = _data["receiptNum"];
            this.poNo = _data["poNo"];
            this.partNo = _data["partNo"];
            this.itemDescription = _data["itemDescription"];
            this.quantityReceived = _data["quantityReceived"];
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.supplierName = _data["supplierName"];
            this.remark = _data["remark"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReturnLinesDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnLinesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["headerId"] = this.headerId;
        data["id"] = this.id;
        data["receiptNum"] = this.receiptNum;
        data["poNo"] = this.poNo;
        data["partNo"] = this.partNo;
        data["itemDescription"] = this.itemDescription;
        data["quantityReceived"] = this.quantityReceived;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["supplierName"] = this.supplierName;
        data["remark"] = this.remark;
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IReturnLinesDto {
    headerId: number;
    id: number;
    receiptNum: string | undefined;
    poNo: string | undefined;
    partNo: string | undefined;
    itemDescription: string | undefined;
    quantityReceived: number | undefined;
    unitOfMeasure: string | undefined;
    creationTime: DateTime | undefined;
    supplierName: string | undefined;
    remark: string | undefined;
    totalCount: number;
}

export class PagedResultDtoOfReturnLinesDto implements IPagedResultDtoOfReturnLinesDto {
    totalCount!: number;
    items!: ReturnLinesDto[] | undefined;

    constructor(data?: IPagedResultDtoOfReturnLinesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ReturnLinesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfReturnLinesDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfReturnLinesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfReturnLinesDto {
    totalCount: number;
    items: ReturnLinesDto[] | undefined;
}

export class SearchAllReturnsDto implements ISearchAllReturnsDto {
    receiptNum!: string | undefined;
    vendorId!: number | undefined;
    poNo!: string | undefined;
    partNo!: string | undefined;
    receiptType!: number;
    receivedDateFrom!: DateTime | undefined;
    receivedDateTo!: DateTime | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ISearchAllReturnsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.receiptNum = _data["receiptNum"];
            this.vendorId = _data["vendorId"];
            this.poNo = _data["poNo"];
            this.partNo = _data["partNo"];
            this.receiptType = _data["receiptType"];
            this.receivedDateFrom = _data["receivedDateFrom"] ? DateTime.fromISO(_data["receivedDateFrom"].toString()) : <any>undefined;
            this.receivedDateTo = _data["receivedDateTo"] ? DateTime.fromISO(_data["receivedDateTo"].toString()) : <any>undefined;
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): SearchAllReturnsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchAllReturnsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiptNum"] = this.receiptNum;
        data["vendorId"] = this.vendorId;
        data["poNo"] = this.poNo;
        data["partNo"] = this.partNo;
        data["receiptType"] = this.receiptType;
        data["receivedDateFrom"] = this.receivedDateFrom ? this.receivedDateFrom.toString() : <any>undefined;
        data["receivedDateTo"] = this.receivedDateTo ? this.receivedDateTo.toString() : <any>undefined;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data;
    }
}

export interface ISearchAllReturnsDto {
    receiptNum: string | undefined;
    vendorId: number | undefined;
    poNo: string | undefined;
    partNo: string | undefined;
    receiptType: number;
    receivedDateFrom: DateTime | undefined;
    receivedDateTo: DateTime | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class RequestApprovalSearchInputDto implements IRequestApprovalSearchInputDto {
    approvalUserId!: number;
    approvalStatus!: string | undefined;
    requestNo!: string | undefined;
    sendDateFrom!: DateTime | undefined;
    sendDateTo!: DateTime | undefined;
    requestTypeId!: number;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: IRequestApprovalSearchInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.approvalUserId = _data["approvalUserId"];
            this.approvalStatus = _data["approvalStatus"];
            this.requestNo = _data["requestNo"];
            this.sendDateFrom = _data["sendDateFrom"] ? DateTime.fromISO(_data["sendDateFrom"].toString()) : <any>undefined;
            this.sendDateTo = _data["sendDateTo"] ? DateTime.fromISO(_data["sendDateTo"].toString()) : <any>undefined;
            this.requestTypeId = _data["requestTypeId"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): RequestApprovalSearchInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestApprovalSearchInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approvalUserId"] = this.approvalUserId;
        data["approvalStatus"] = this.approvalStatus;
        data["requestNo"] = this.requestNo;
        data["sendDateFrom"] = this.sendDateFrom ? this.sendDateFrom.toString() : <any>undefined;
        data["sendDateTo"] = this.sendDateTo ? this.sendDateTo.toString() : <any>undefined;
        data["requestTypeId"] = this.requestTypeId;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IRequestApprovalSearchInputDto {
    approvalUserId: number;
    approvalStatus: string | undefined;
    requestNo: string | undefined;
    sendDateFrom: DateTime | undefined;
    sendDateTo: DateTime | undefined;
    requestTypeId: number;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class RequestApprovalSearchOutputDto implements IRequestApprovalSearchOutputDto {
    id!: number;
    reqId!: number;
    requestApprovalStepId!: number;
    processTypeCode!: string | undefined;
    approvalStatus!: string | undefined;
    requestType!: string | undefined;
    requestNo!: string | undefined;
    requestPersonName!: string | undefined;
    requestDate!: DateTime;
    description!: string | undefined;
    totalCount!: number;
    departmentApprovalName!: string | undefined;
    requestNote!: string | undefined;
    replyNote!: string | undefined;
    isBuyer!: boolean | undefined;

    constructor(data?: IRequestApprovalSearchOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.reqId = _data["reqId"];
            this.requestApprovalStepId = _data["requestApprovalStepId"];
            this.processTypeCode = _data["processTypeCode"];
            this.approvalStatus = _data["approvalStatus"];
            this.requestType = _data["requestType"];
            this.requestNo = _data["requestNo"];
            this.requestPersonName = _data["requestPersonName"];
            this.requestDate = _data["requestDate"] ? DateTime.fromISO(_data["requestDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.totalCount = _data["totalCount"];
            this.departmentApprovalName = _data["departmentApprovalName"];
            this.requestNote = _data["requestNote"];
            this.replyNote = _data["replyNote"];
            this.isBuyer = _data["isBuyer"];
        }
    }

    static fromJS(data: any): RequestApprovalSearchOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestApprovalSearchOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["reqId"] = this.reqId;
        data["requestApprovalStepId"] = this.requestApprovalStepId;
        data["processTypeCode"] = this.processTypeCode;
        data["approvalStatus"] = this.approvalStatus;
        data["requestType"] = this.requestType;
        data["requestNo"] = this.requestNo;
        data["requestPersonName"] = this.requestPersonName;
        data["requestDate"] = this.requestDate ? this.requestDate.toString() : <any>undefined;
        data["description"] = this.description;
        data["totalCount"] = this.totalCount;
        data["departmentApprovalName"] = this.departmentApprovalName;
        data["requestNote"] = this.requestNote;
        data["replyNote"] = this.replyNote;
        data["isBuyer"] = this.isBuyer;
        return data;
    }
}

export interface IRequestApprovalSearchOutputDto {
    id: number;
    reqId: number;
    requestApprovalStepId: number;
    processTypeCode: string | undefined;
    approvalStatus: string | undefined;
    requestType: string | undefined;
    requestNo: string | undefined;
    requestPersonName: string | undefined;
    requestDate: DateTime;
    description: string | undefined;
    totalCount: number;
    departmentApprovalName: string | undefined;
    requestNote: string | undefined;
    replyNote: string | undefined;
    isBuyer: boolean | undefined;
}

export class PagedResultDtoOfRequestApprovalSearchOutputDto implements IPagedResultDtoOfRequestApprovalSearchOutputDto {
    totalCount!: number;
    items!: RequestApprovalSearchOutputDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRequestApprovalSearchOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RequestApprovalSearchOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRequestApprovalSearchOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRequestApprovalSearchOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfRequestApprovalSearchOutputDto {
    totalCount: number;
    items: RequestApprovalSearchOutputDto[] | undefined;
}

export class ApproveOrRejectInputDto implements IApproveOrRejectInputDto {
    requestApprovalStepId!: number;
    reqId!: number;
    processTypeCode!: string | undefined;
    note!: string | undefined;
    approvalUserId!: number;
    isApproved!: boolean;
    createSupplierAccountUrl!: string | undefined;

    constructor(data?: IApproveOrRejectInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestApprovalStepId = _data["requestApprovalStepId"];
            this.reqId = _data["reqId"];
            this.processTypeCode = _data["processTypeCode"];
            this.note = _data["note"];
            this.approvalUserId = _data["approvalUserId"];
            this.isApproved = _data["isApproved"];
            this.createSupplierAccountUrl = _data["createSupplierAccountUrl"];
        }
    }

    static fromJS(data: any): ApproveOrRejectInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveOrRejectInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestApprovalStepId"] = this.requestApprovalStepId;
        data["reqId"] = this.reqId;
        data["processTypeCode"] = this.processTypeCode;
        data["note"] = this.note;
        data["approvalUserId"] = this.approvalUserId;
        data["isApproved"] = this.isApproved;
        data["createSupplierAccountUrl"] = this.createSupplierAccountUrl;
        return data;
    }
}

export interface IApproveOrRejectInputDto {
    requestApprovalStepId: number;
    reqId: number;
    processTypeCode: string | undefined;
    note: string | undefined;
    approvalUserId: number;
    isApproved: boolean;
    createSupplierAccountUrl: string | undefined;
}

export class ApproveOrRejectOutputDto implements IApproveOrRejectOutputDto {
    isLast!: boolean;
    status!: boolean;

    constructor(data?: IApproveOrRejectOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isLast = _data["isLast"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ApproveOrRejectOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveOrRejectOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["status"] = this.status;
        return data;
    }
}

export interface IApproveOrRejectOutputDto {
    isLast: boolean;
    status: boolean;
}

export class CreateRequestApprovalInputDto implements ICreateRequestApprovalInputDto {
    reqId!: number;
    processTypeCode!: string | undefined;

    constructor(data?: ICreateRequestApprovalInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reqId = _data["reqId"];
            this.processTypeCode = _data["processTypeCode"];
        }
    }

    static fromJS(data: any): CreateRequestApprovalInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRequestApprovalInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reqId"] = this.reqId;
        data["processTypeCode"] = this.processTypeCode;
        return data;
    }
}

export interface ICreateRequestApprovalInputDto {
    reqId: number;
    processTypeCode: string | undefined;
}

export class CreateRequestApprovalOutputDto implements ICreateRequestApprovalOutputDto {
    result!: boolean;
    message!: string | undefined;
    approvalTreeId!: number;

    constructor(data?: ICreateRequestApprovalOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
            this.message = _data["message"];
            this.approvalTreeId = _data["approvalTreeId"];
        }
    }

    static fromJS(data: any): CreateRequestApprovalOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRequestApprovalOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["message"] = this.message;
        data["approvalTreeId"] = this.approvalTreeId;
        return data;
    }
}

export interface ICreateRequestApprovalOutputDto {
    result: boolean;
    message: string | undefined;
    approvalTreeId: number;
}

export class RequestNextApprovalTreeInputDto implements IRequestNextApprovalTreeInputDto {
    reqId!: number;
    processTypeCode!: string | undefined;
    departmentName!: string | undefined;

    constructor(data?: IRequestNextApprovalTreeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reqId = _data["reqId"];
            this.processTypeCode = _data["processTypeCode"];
            this.departmentName = _data["departmentName"];
        }
    }

    static fromJS(data: any): RequestNextApprovalTreeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestNextApprovalTreeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reqId"] = this.reqId;
        data["processTypeCode"] = this.processTypeCode;
        data["departmentName"] = this.departmentName;
        return data;
    }
}

export interface IRequestNextApprovalTreeInputDto {
    reqId: number;
    processTypeCode: string | undefined;
    departmentName: string | undefined;
}

export class RequestApprovalHistoryOutputDto implements IRequestApprovalHistoryOutputDto {
    id!: number;
    approvalFullName!: string | undefined;
    approvalStatus!: string | undefined;
    approvalDate!: DateTime | undefined;
    requestDate!: DateTime | undefined;
    deadlineDate!: DateTime | undefined;
    note!: string | undefined;

    constructor(data?: IRequestApprovalHistoryOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.approvalFullName = _data["approvalFullName"];
            this.approvalStatus = _data["approvalStatus"];
            this.approvalDate = _data["approvalDate"] ? DateTime.fromISO(_data["approvalDate"].toString()) : <any>undefined;
            this.requestDate = _data["requestDate"] ? DateTime.fromISO(_data["requestDate"].toString()) : <any>undefined;
            this.deadlineDate = _data["deadlineDate"] ? DateTime.fromISO(_data["deadlineDate"].toString()) : <any>undefined;
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): RequestApprovalHistoryOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestApprovalHistoryOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["approvalFullName"] = this.approvalFullName;
        data["approvalStatus"] = this.approvalStatus;
        data["approvalDate"] = this.approvalDate ? this.approvalDate.toString() : <any>undefined;
        data["requestDate"] = this.requestDate ? this.requestDate.toString() : <any>undefined;
        data["deadlineDate"] = this.deadlineDate ? this.deadlineDate.toString() : <any>undefined;
        data["note"] = this.note;
        return data;
    }
}

export interface IRequestApprovalHistoryOutputDto {
    id: number;
    approvalFullName: string | undefined;
    approvalStatus: string | undefined;
    approvalDate: DateTime | undefined;
    requestDate: DateTime | undefined;
    deadlineDate: DateTime | undefined;
    note: string | undefined;
}

export class ForwardInputDto implements IForwardInputDto {
    requestApprovalStepId!: number;
    forwardUserId!: number;
    numberPersonToFw!: number;
    note!: string | undefined;

    constructor(data?: IForwardInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestApprovalStepId = _data["requestApprovalStepId"];
            this.forwardUserId = _data["forwardUserId"];
            this.numberPersonToFw = _data["numberPersonToFw"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): ForwardInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ForwardInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestApprovalStepId"] = this.requestApprovalStepId;
        data["forwardUserId"] = this.forwardUserId;
        data["numberPersonToFw"] = this.numberPersonToFw;
        data["note"] = this.note;
        return data;
    }
}

export interface IForwardInputDto {
    requestApprovalStepId: number;
    forwardUserId: number;
    numberPersonToFw: number;
    note: string | undefined;
}

export class FowardApproveInputDto implements IFowardApproveInputDto {
    requestApprovalStepId!: number;
    nextApproveUserId!: number;
    note!: string | undefined;
    isLast!: boolean;

    constructor(data?: IFowardApproveInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestApprovalStepId = _data["requestApprovalStepId"];
            this.nextApproveUserId = _data["nextApproveUserId"];
            this.note = _data["note"];
            this.isLast = _data["isLast"];
        }
    }

    static fromJS(data: any): FowardApproveInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new FowardApproveInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestApprovalStepId"] = this.requestApprovalStepId;
        data["nextApproveUserId"] = this.nextApproveUserId;
        data["note"] = this.note;
        data["isLast"] = this.isLast;
        return data;
    }
}

export interface IFowardApproveInputDto {
    requestApprovalStepId: number;
    nextApproveUserId: number;
    note: string | undefined;
    isLast: boolean;
}

export class UserOrganizationUnit implements IUserOrganizationUnit {
    tenantId!: number | undefined;
    userId!: number;
    organizationUnitId!: number;
    isDeleted!: boolean;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IUserOrganizationUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.isDeleted = _data["isDeleted"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserOrganizationUnit {
        data = typeof data === 'object' ? data : {};
        let result = new UserOrganizationUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["isDeleted"] = this.isDeleted;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserOrganizationUnit {
    tenantId: number | undefined;
    userId: number;
    organizationUnitId: number;
    isDeleted: boolean;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class UserToken implements IUserToken {
    tenantId!: number | undefined;
    userId!: number;
    loginProvider!: string | undefined;
    name!: string | undefined;
    value!: string | undefined;
    expireDate!: DateTime | undefined;
    id!: number;

    constructor(data?: IUserToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.expireDate = _data["expireDate"] ? DateTime.fromISO(_data["expireDate"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserToken {
        data = typeof data === 'object' ? data : {};
        let result = new UserToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["name"] = this.name;
        data["value"] = this.value;
        data["expireDate"] = this.expireDate ? this.expireDate.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserToken {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: DateTime | undefined;
    id: number;
}

export class UserLogin implements IUserLogin {
    tenantId!: number | undefined;
    userId!: number;
    loginProvider!: string;
    providerKey!: string;
    id!: number;

    constructor(data?: IUserLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.providerKey = _data["providerKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new UserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserLogin {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string;
    providerKey: string;
    id: number;
}

export class UserRole implements IUserRole {
    tenantId!: number | undefined;
    userId!: number;
    roleId!: number;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserRole {
    tenantId: number | undefined;
    userId: number;
    roleId: number;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class UserClaim implements IUserClaim {
    tenantId!: number | undefined;
    userId!: number;
    claimType!: string | undefined;
    claimValue!: string | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IUserClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserClaim {
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class UserPermissionSetting implements IUserPermissionSetting {
    userId!: number;
    tenantId!: number | undefined;
    name!: string;
    isGranted!: boolean;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IUserPermissionSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.isGranted = _data["isGranted"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserPermissionSetting {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermissionSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserPermissionSetting {
    userId: number;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class Setting implements ISetting {
    tenantId!: number | undefined;
    userId!: number | undefined;
    name!: string;
    value!: string | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ISetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Setting {
        data = typeof data === 'object' ? data : {};
        let result = new Setting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["value"] = this.value;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISetting {
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class User implements IUser {
    profilePictureId!: string | undefined;
    shouldChangePasswordOnNextLogin!: boolean;
    signInTokenExpireTimeUtc!: DateTime | undefined;
    signInToken!: string | undefined;
    googleAuthenticatorKey!: string | undefined;
    hrOrgStructureId!: string | undefined;
    titlesId!: number | undefined;
    positionId!: number | undefined;
    supplierContactId!: number | undefined;
    employeeCode!: string | undefined;
    isBuyer!: boolean;
    isFinanceMA!: boolean | undefined;
    isGroupManageRight!: boolean | undefined;
    organizationUnits!: UserOrganizationUnit[] | undefined;
    normalizedUserName!: string;
    normalizedEmailAddress!: string;
    concurrencyStamp!: string | undefined;
    tokens!: UserToken[] | undefined;
    deleterUser!: User;
    creatorUser!: User;
    lastModifierUser!: User;
    authenticationSource!: string | undefined;
    userName!: string;
    tenantId!: number | undefined;
    emailAddress!: string;
    name!: string;
    surname!: string;
    readonly fullName!: string | undefined;
    password!: string;
    emailConfirmationCode!: string | undefined;
    passwordResetCode!: string | undefined;
    lockoutEndDateUtc!: DateTime | undefined;
    accessFailedCount!: number;
    isLockoutEnabled!: boolean;
    phoneNumber!: string | undefined;
    isPhoneNumberConfirmed!: boolean;
    securityStamp!: string | undefined;
    isTwoFactorEnabled!: boolean;
    logins!: UserLogin[] | undefined;
    roles!: UserRole[] | undefined;
    claims!: UserClaim[] | undefined;
    permissions!: UserPermissionSetting[] | undefined;
    settings!: Setting[] | undefined;
    isEmailConfirmed!: boolean;
    isActive!: boolean;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.profilePictureId = _data["profilePictureId"];
            this.shouldChangePasswordOnNextLogin = _data["shouldChangePasswordOnNextLogin"];
            this.signInTokenExpireTimeUtc = _data["signInTokenExpireTimeUtc"] ? DateTime.fromISO(_data["signInTokenExpireTimeUtc"].toString()) : <any>undefined;
            this.signInToken = _data["signInToken"];
            this.googleAuthenticatorKey = _data["googleAuthenticatorKey"];
            this.hrOrgStructureId = _data["hrOrgStructureId"];
            this.titlesId = _data["titlesId"];
            this.positionId = _data["positionId"];
            this.supplierContactId = _data["supplierContactId"];
            this.employeeCode = _data["employeeCode"];
            this.isBuyer = _data["isBuyer"];
            this.isFinanceMA = _data["isFinanceMA"];
            this.isGroupManageRight = _data["isGroupManageRight"];
            if (Array.isArray(_data["organizationUnits"])) {
                this.organizationUnits = [] as any;
                for (let item of _data["organizationUnits"])
                    this.organizationUnits!.push(UserOrganizationUnit.fromJS(item));
            }
            this.normalizedUserName = _data["normalizedUserName"];
            this.normalizedEmailAddress = _data["normalizedEmailAddress"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            if (Array.isArray(_data["tokens"])) {
                this.tokens = [] as any;
                for (let item of _data["tokens"])
                    this.tokens!.push(UserToken.fromJS(item));
            }
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.authenticationSource = _data["authenticationSource"];
            this.userName = _data["userName"];
            this.tenantId = _data["tenantId"];
            this.emailAddress = _data["emailAddress"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            (<any>this).fullName = _data["fullName"];
            this.password = _data["password"];
            this.emailConfirmationCode = _data["emailConfirmationCode"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.lockoutEndDateUtc = _data["lockoutEndDateUtc"] ? DateTime.fromISO(_data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.accessFailedCount = _data["accessFailedCount"];
            this.isLockoutEnabled = _data["isLockoutEnabled"];
            this.phoneNumber = _data["phoneNumber"];
            this.isPhoneNumberConfirmed = _data["isPhoneNumberConfirmed"];
            this.securityStamp = _data["securityStamp"];
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            if (Array.isArray(_data["logins"])) {
                this.logins = [] as any;
                for (let item of _data["logins"])
                    this.logins!.push(UserLogin.fromJS(item));
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UserRole.fromJS(item));
            }
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(UserClaim.fromJS(item));
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(UserPermissionSetting.fromJS(item));
            }
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings!.push(Setting.fromJS(item));
            }
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["signInTokenExpireTimeUtc"] = this.signInTokenExpireTimeUtc ? this.signInTokenExpireTimeUtc.toString() : <any>undefined;
        data["signInToken"] = this.signInToken;
        data["googleAuthenticatorKey"] = this.googleAuthenticatorKey;
        data["hrOrgStructureId"] = this.hrOrgStructureId;
        data["titlesId"] = this.titlesId;
        data["positionId"] = this.positionId;
        data["supplierContactId"] = this.supplierContactId;
        data["employeeCode"] = this.employeeCode;
        data["isBuyer"] = this.isBuyer;
        data["isFinanceMA"] = this.isFinanceMA;
        data["isGroupManageRight"] = this.isGroupManageRight;
        if (Array.isArray(this.organizationUnits)) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item.toJSON());
        }
        data["normalizedUserName"] = this.normalizedUserName;
        data["normalizedEmailAddress"] = this.normalizedEmailAddress;
        data["concurrencyStamp"] = this.concurrencyStamp;
        if (Array.isArray(this.tokens)) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["authenticationSource"] = this.authenticationSource;
        data["userName"] = this.userName;
        data["tenantId"] = this.tenantId;
        data["emailAddress"] = this.emailAddress;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["fullName"] = this.fullName;
        data["password"] = this.password;
        data["emailConfirmationCode"] = this.emailConfirmationCode;
        data["passwordResetCode"] = this.passwordResetCode;
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toString() : <any>undefined;
        data["accessFailedCount"] = this.accessFailedCount;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["securityStamp"] = this.securityStamp;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        if (Array.isArray(this.logins)) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IUser {
    profilePictureId: string | undefined;
    shouldChangePasswordOnNextLogin: boolean;
    signInTokenExpireTimeUtc: DateTime | undefined;
    signInToken: string | undefined;
    googleAuthenticatorKey: string | undefined;
    hrOrgStructureId: string | undefined;
    titlesId: number | undefined;
    positionId: number | undefined;
    supplierContactId: number | undefined;
    employeeCode: string | undefined;
    isBuyer: boolean;
    isFinanceMA: boolean | undefined;
    isGroupManageRight: boolean | undefined;
    organizationUnits: UserOrganizationUnit[] | undefined;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    name: string;
    surname: string;
    fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: DateTime | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class GetRolesInput implements IGetRolesInput {
    permissions!: string[] | undefined;

    constructor(data?: IGetRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
        }
    }

    static fromJS(data: any): GetRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data;
    }
}

export interface IGetRolesInput {
    permissions: string[] | undefined;
}

export class RoleListDto implements IRoleListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    isStatic!: boolean;
    isDefault!: boolean;
    creationTime!: DateTime;
    id!: number;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: DateTime;
    id: number;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items!: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    id!: number | undefined;
    displayName!: string;
    isDefault!: boolean;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IRoleEditDto {
    id: number | undefined;
    displayName: string;
    isDefault: boolean;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isGrantedByDefault = _data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data;
    }
}

export interface IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role!: RoleEditDto;
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    role!: RoleEditDto;
    grantedPermissionNames!: string[];

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
            this.grantedPermissionNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : new RoleEditDto();
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];
}

export class DelayPaymentEmailContent implements IDelayPaymentEmailContent {
    receiveEmail!: string[] | undefined;
    subject!: string | undefined;
    dealerName!: string | undefined;
    contentEmail!: string | undefined;
    fileName!: string | undefined;
    ccEmail!: string | undefined;

    constructor(data?: IDelayPaymentEmailContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["receiveEmail"])) {
                this.receiveEmail = [] as any;
                for (let item of _data["receiveEmail"])
                    this.receiveEmail!.push(item);
            }
            this.subject = _data["subject"];
            this.dealerName = _data["dealerName"];
            this.contentEmail = _data["contentEmail"];
            this.fileName = _data["fileName"];
            this.ccEmail = _data["ccEmail"];
        }
    }

    static fromJS(data: any): DelayPaymentEmailContent {
        data = typeof data === 'object' ? data : {};
        let result = new DelayPaymentEmailContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.receiveEmail)) {
            data["receiveEmail"] = [];
            for (let item of this.receiveEmail)
                data["receiveEmail"].push(item);
        }
        data["subject"] = this.subject;
        data["dealerName"] = this.dealerName;
        data["contentEmail"] = this.contentEmail;
        data["fileName"] = this.fileName;
        data["ccEmail"] = this.ccEmail;
        return data;
    }
}

export interface IDelayPaymentEmailContent {
    receiveEmail: string[] | undefined;
    subject: string | undefined;
    dealerName: string | undefined;
    contentEmail: string | undefined;
    fileName: string | undefined;
    ccEmail: string | undefined;
}

export class SendEmailContent implements ISendEmailContent {
    person!: string | undefined;
    approvalPerson!: string | undefined;
    from!: string | undefined;
    document!: string | undefined;
    description!: string | undefined;
    status!: string | undefined;
    subject!: string | undefined;
    emailTemplateCode!: string | undefined;
    receiver!: string | undefined;

    constructor(data?: ISendEmailContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.person = _data["person"];
            this.approvalPerson = _data["approvalPerson"];
            this.from = _data["from"];
            this.document = _data["document"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.subject = _data["subject"];
            this.emailTemplateCode = _data["emailTemplateCode"];
            this.receiver = _data["receiver"];
        }
    }

    static fromJS(data: any): SendEmailContent {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["person"] = this.person;
        data["approvalPerson"] = this.approvalPerson;
        data["from"] = this.from;
        data["document"] = this.document;
        data["description"] = this.description;
        data["status"] = this.status;
        data["subject"] = this.subject;
        data["emailTemplateCode"] = this.emailTemplateCode;
        data["receiver"] = this.receiver;
        return data;
    }
}

export interface ISendEmailContent {
    person: string | undefined;
    approvalPerson: string | undefined;
    from: string | undefined;
    document: string | undefined;
    description: string | undefined;
    status: string | undefined;
    subject: string | undefined;
    emailTemplateCode: string | undefined;
    receiver: string | undefined;
}

export class MailContent implements IMailContent {
    to!: string | undefined;
    subject!: string | undefined;
    body!: string | undefined;

    constructor(data?: IMailContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.to = _data["to"];
            this.subject = _data["subject"];
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): MailContent {
        data = typeof data === 'object' ? data : {};
        let result = new MailContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["to"] = this.to;
        data["subject"] = this.subject;
        data["body"] = this.body;
        return data;
    }
}

export interface IMailContent {
    to: string | undefined;
    subject: string | undefined;
    body: string | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    supplierContactId!: number | undefined;
    id!: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.profilePictureId = _data["profilePictureId"];
            this.supplierContactId = _data["supplierContactId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["supplierContactId"] = this.supplierContactId;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    supplierContactId: number | undefined;
    id: number;
}

export enum SubscriptionPaymentType {
    Manual = 0,
    RecurringAutomatic = 1,
    RecurringManual = 2,
}

export class EditionInfoDto implements IEditionInfoDto {
    displayName!: string | undefined;
    trialDayCount!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    isHighestEdition!: boolean;
    isFree!: boolean;
    id!: number;

    constructor(data?: IEditionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.trialDayCount = _data["trialDayCount"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.isHighestEdition = _data["isHighestEdition"];
            this.isFree = _data["isFree"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["trialDayCount"] = this.trialDayCount;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["isHighestEdition"] = this.isHighestEdition;
        data["isFree"] = this.isFree;
        data["id"] = this.id;
        return data;
    }
}

export interface IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean;
    isFree: boolean;
    id: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    logoId!: string | undefined;
    logoFileType!: string | undefined;
    customCssId!: string | undefined;
    subscriptionEndDateUtc!: DateTime | undefined;
    isInTrialPeriod!: boolean;
    subscriptionPaymentType!: SubscriptionPaymentType;
    edition!: EditionInfoDto;
    creationTime!: DateTime;
    paymentPeriodType!: PaymentPeriodType;
    subscriptionDateString!: string | undefined;
    creationTimeString!: string | undefined;
    id!: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.logoId = _data["logoId"];
            this.logoFileType = _data["logoFileType"];
            this.customCssId = _data["customCssId"];
            this.subscriptionEndDateUtc = _data["subscriptionEndDateUtc"] ? DateTime.fromISO(_data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = _data["isInTrialPeriod"];
            this.subscriptionPaymentType = _data["subscriptionPaymentType"];
            this.edition = _data["edition"] ? EditionInfoDto.fromJS(_data["edition"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.subscriptionDateString = _data["subscriptionDateString"];
            this.creationTimeString = _data["creationTimeString"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["logoId"] = this.logoId;
        data["logoFileType"] = this.logoFileType;
        data["customCssId"] = this.customCssId;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["subscriptionPaymentType"] = this.subscriptionPaymentType;
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionDateString"] = this.subscriptionDateString;
        data["creationTimeString"] = this.creationTimeString;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    logoId: string | undefined;
    logoFileType: string | undefined;
    customCssId: string | undefined;
    subscriptionEndDateUtc: DateTime | undefined;
    isInTrialPeriod: boolean;
    subscriptionPaymentType: SubscriptionPaymentType;
    edition: EditionInfoDto;
    creationTime: DateTime;
    paymentPeriodType: PaymentPeriodType;
    subscriptionDateString: string | undefined;
    creationTimeString: string | undefined;
    id: number;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version!: string | undefined;
    releaseDate!: DateTime;
    currency!: string | undefined;
    currencySign!: string | undefined;
    allowTenantsToChangeEmailSettings!: boolean;
    userDelegationIsEnabled!: boolean;
    features!: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? DateTime.fromISO(_data["releaseDate"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.currencySign = _data["currencySign"];
            this.allowTenantsToChangeEmailSettings = _data["allowTenantsToChangeEmailSettings"];
            this.userDelegationIsEnabled = _data["userDelegationIsEnabled"];
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        (<any>this.features)![key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toString() : <any>undefined;
        data["currency"] = this.currency;
        data["currencySign"] = this.currencySign;
        data["allowTenantsToChangeEmailSettings"] = this.allowTenantsToChangeEmailSettings;
        data["userDelegationIsEnabled"] = this.userDelegationIsEnabled;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    (<any>data["features"])[key] = (<any>this.features)[key];
            }
        }
        return data;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: DateTime;
    currency: string | undefined;
    currencySign: string | undefined;
    allowTenantsToChangeEmailSettings: boolean;
    userDelegationIsEnabled: boolean;
    features: { [key: string]: boolean; } | undefined;
}

export class ThemeLayoutSettingsDto implements IThemeLayoutSettingsDto {
    layoutType!: string | undefined;

    constructor(data?: IThemeLayoutSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.layoutType = _data["layoutType"];
        }
    }

    static fromJS(data: any): ThemeLayoutSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeLayoutSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layoutType"] = this.layoutType;
        return data;
    }
}

export interface IThemeLayoutSettingsDto {
    layoutType: string | undefined;
}

export class ThemeHeaderSettingsDto implements IThemeHeaderSettingsDto {
    desktopFixedHeader!: boolean;
    mobileFixedHeader!: boolean;
    headerSkin!: string | undefined;
    minimizeDesktopHeaderType!: string | undefined;

    constructor(data?: IThemeHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.desktopFixedHeader = _data["desktopFixedHeader"];
            this.mobileFixedHeader = _data["mobileFixedHeader"];
            this.headerSkin = _data["headerSkin"];
            this.minimizeDesktopHeaderType = _data["minimizeDesktopHeaderType"];
        }
    }

    static fromJS(data: any): ThemeHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["desktopFixedHeader"] = this.desktopFixedHeader;
        data["mobileFixedHeader"] = this.mobileFixedHeader;
        data["headerSkin"] = this.headerSkin;
        data["minimizeDesktopHeaderType"] = this.minimizeDesktopHeaderType;
        return data;
    }
}

export interface IThemeHeaderSettingsDto {
    desktopFixedHeader: boolean;
    mobileFixedHeader: boolean;
    headerSkin: string | undefined;
    minimizeDesktopHeaderType: string | undefined;
}

export class ThemeSubHeaderSettingsDto implements IThemeSubHeaderSettingsDto {
    fixedSubHeader!: boolean;
    subheaderStyle!: string | undefined;
    subheaderSize!: number;
    titleStlye!: string | undefined;
    containerStyle!: string | undefined;

    constructor(data?: IThemeSubHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fixedSubHeader = _data["fixedSubHeader"];
            this.subheaderStyle = _data["subheaderStyle"];
            this.subheaderSize = _data["subheaderSize"];
            this.titleStlye = _data["titleStlye"];
            this.containerStyle = _data["containerStyle"];
        }
    }

    static fromJS(data: any): ThemeSubHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSubHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedSubHeader"] = this.fixedSubHeader;
        data["subheaderStyle"] = this.subheaderStyle;
        data["subheaderSize"] = this.subheaderSize;
        data["titleStlye"] = this.titleStlye;
        data["containerStyle"] = this.containerStyle;
        return data;
    }
}

export interface IThemeSubHeaderSettingsDto {
    fixedSubHeader: boolean;
    subheaderStyle: string | undefined;
    subheaderSize: number;
    titleStlye: string | undefined;
    containerStyle: string | undefined;
}

export class ThemeMenuSettingsDto implements IThemeMenuSettingsDto {
    position!: string | undefined;
    asideSkin!: string | undefined;
    fixedAside!: boolean;
    allowAsideMinimizing!: boolean;
    defaultMinimizedAside!: boolean;
    submenuToggle!: string | undefined;
    searchActive!: boolean;
    enableSecondary!: boolean;
    hoverableAside!: boolean;

    constructor(data?: IThemeMenuSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.position = _data["position"];
            this.asideSkin = _data["asideSkin"];
            this.fixedAside = _data["fixedAside"];
            this.allowAsideMinimizing = _data["allowAsideMinimizing"];
            this.defaultMinimizedAside = _data["defaultMinimizedAside"];
            this.submenuToggle = _data["submenuToggle"];
            this.searchActive = _data["searchActive"];
            this.enableSecondary = _data["enableSecondary"];
            this.hoverableAside = _data["hoverableAside"];
        }
    }

    static fromJS(data: any): ThemeMenuSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeMenuSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["asideSkin"] = this.asideSkin;
        data["fixedAside"] = this.fixedAside;
        data["allowAsideMinimizing"] = this.allowAsideMinimizing;
        data["defaultMinimizedAside"] = this.defaultMinimizedAside;
        data["submenuToggle"] = this.submenuToggle;
        data["searchActive"] = this.searchActive;
        data["enableSecondary"] = this.enableSecondary;
        data["hoverableAside"] = this.hoverableAside;
        return data;
    }
}

export interface IThemeMenuSettingsDto {
    position: string | undefined;
    asideSkin: string | undefined;
    fixedAside: boolean;
    allowAsideMinimizing: boolean;
    defaultMinimizedAside: boolean;
    submenuToggle: string | undefined;
    searchActive: boolean;
    enableSecondary: boolean;
    hoverableAside: boolean;
}

export class ThemeFooterSettingsDto implements IThemeFooterSettingsDto {
    fixedFooter!: boolean;

    constructor(data?: IThemeFooterSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fixedFooter = _data["fixedFooter"];
        }
    }

    static fromJS(data: any): ThemeFooterSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeFooterSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedFooter"] = this.fixedFooter;
        return data;
    }
}

export interface IThemeFooterSettingsDto {
    fixedFooter: boolean;
}

export class ThemeSettingsDto implements IThemeSettingsDto {
    theme!: string | undefined;
    layout!: ThemeLayoutSettingsDto;
    header!: ThemeHeaderSettingsDto;
    subHeader!: ThemeSubHeaderSettingsDto;
    menu!: ThemeMenuSettingsDto;
    footer!: ThemeFooterSettingsDto;

    constructor(data?: IThemeSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
            this.layout = _data["layout"] ? ThemeLayoutSettingsDto.fromJS(_data["layout"]) : <any>undefined;
            this.header = _data["header"] ? ThemeHeaderSettingsDto.fromJS(_data["header"]) : <any>undefined;
            this.subHeader = _data["subHeader"] ? ThemeSubHeaderSettingsDto.fromJS(_data["subHeader"]) : <any>undefined;
            this.menu = _data["menu"] ? ThemeMenuSettingsDto.fromJS(_data["menu"]) : <any>undefined;
            this.footer = _data["footer"] ? ThemeFooterSettingsDto.fromJS(_data["footer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ThemeSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["subHeader"] = this.subHeader ? this.subHeader.toJSON() : <any>undefined;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["footer"] = this.footer ? this.footer.toJSON() : <any>undefined;
        return data;
    }
}

export interface IThemeSettingsDto {
    theme: string | undefined;
    layout: ThemeLayoutSettingsDto;
    header: ThemeHeaderSettingsDto;
    subHeader: ThemeSubHeaderSettingsDto;
    menu: ThemeMenuSettingsDto;
    footer: ThemeFooterSettingsDto;
}

export class UiCustomizationSettingsDto implements IUiCustomizationSettingsDto {
    baseSettings!: ThemeSettingsDto;
    isLeftMenuUsed!: boolean;
    isTopMenuUsed!: boolean;
    isTabMenuUsed!: boolean;
    allowMenuScroll!: boolean;

    constructor(data?: IUiCustomizationSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseSettings = _data["baseSettings"] ? ThemeSettingsDto.fromJS(_data["baseSettings"]) : <any>undefined;
            this.isLeftMenuUsed = _data["isLeftMenuUsed"];
            this.isTopMenuUsed = _data["isTopMenuUsed"];
            this.isTabMenuUsed = _data["isTabMenuUsed"];
            this.allowMenuScroll = _data["allowMenuScroll"];
        }
    }

    static fromJS(data: any): UiCustomizationSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseSettings"] = this.baseSettings ? this.baseSettings.toJSON() : <any>undefined;
        data["isLeftMenuUsed"] = this.isLeftMenuUsed;
        data["isTopMenuUsed"] = this.isTopMenuUsed;
        data["isTabMenuUsed"] = this.isTabMenuUsed;
        data["allowMenuScroll"] = this.allowMenuScroll;
        return data;
    }
}

export interface IUiCustomizationSettingsDto {
    baseSettings: ThemeSettingsDto;
    isLeftMenuUsed: boolean;
    isTopMenuUsed: boolean;
    isTabMenuUsed: boolean;
    allowMenuScroll: boolean;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user!: UserLoginInfoDto;
    impersonatorUser!: UserLoginInfoDto;
    tenant!: TenantLoginInfoDto;
    impersonatorTenant!: TenantLoginInfoDto;
    application!: ApplicationInfoDto;
    theme!: UiCustomizationSettingsDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.impersonatorUser = _data["impersonatorUser"] ? UserLoginInfoDto.fromJS(_data["impersonatorUser"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
            this.impersonatorTenant = _data["impersonatorTenant"] ? TenantLoginInfoDto.fromJS(_data["impersonatorTenant"]) : <any>undefined;
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.theme = _data["theme"] ? UiCustomizationSettingsDto.fromJS(_data["theme"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["impersonatorUser"] = this.impersonatorUser ? this.impersonatorUser.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["impersonatorTenant"] = this.impersonatorTenant ? this.impersonatorTenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["theme"] = this.theme ? this.theme.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto;
    impersonatorUser: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
    impersonatorTenant: TenantLoginInfoDto;
    application: ApplicationInfoDto;
    theme: UiCustomizationSettingsDto;
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken!: string | undefined;
    encodedUserId!: string | undefined;
    encodedTenantId!: string | undefined;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.signInToken = _data["signInToken"];
            this.encodedUserId = _data["encodedUserId"];
            this.encodedTenantId = _data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data;
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;
}

export class StripeConfigurationDto implements IStripeConfigurationDto {
    publishableKey!: string | undefined;

    constructor(data?: IStripeConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.publishableKey = _data["publishableKey"];
        }
    }

    static fromJS(data: any): StripeConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new StripeConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publishableKey"] = this.publishableKey;
        return data;
    }
}

export interface IStripeConfigurationDto {
    publishableKey: string | undefined;
}

export class StripeCreatePaymentSessionInput implements IStripeCreatePaymentSessionInput {
    paymentId!: number;
    successUrl!: string | undefined;
    cancelUrl!: string | undefined;

    constructor(data?: IStripeCreatePaymentSessionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentId = _data["paymentId"];
            this.successUrl = _data["successUrl"];
            this.cancelUrl = _data["cancelUrl"];
        }
    }

    static fromJS(data: any): StripeCreatePaymentSessionInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeCreatePaymentSessionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["successUrl"] = this.successUrl;
        data["cancelUrl"] = this.cancelUrl;
        return data;
    }
}

export interface IStripeCreatePaymentSessionInput {
    paymentId: number;
    successUrl: string | undefined;
    cancelUrl: string | undefined;
}

export class StripePaymentResultOutput implements IStripePaymentResultOutput {
    paymentDone!: boolean;

    constructor(data?: IStripePaymentResultOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentDone = _data["paymentDone"];
        }
    }

    static fromJS(data: any): StripePaymentResultOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StripePaymentResultOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentDone"] = this.paymentDone;
        return data;
    }
}

export interface IStripePaymentResultOutput {
    paymentDone: boolean;
}

export class TenantListDto implements ITenantListDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    editionDisplayName!: string | undefined;
    connectionString!: string | undefined;
    isActive!: boolean;
    creationTime!: DateTime;
    subscriptionEndDateUtc!: DateTime | undefined;
    editionId!: number | undefined;
    isInTrialPeriod!: boolean;
    id!: number;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.editionDisplayName = _data["editionDisplayName"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.subscriptionEndDateUtc = _data["subscriptionEndDateUtc"] ? DateTime.fromISO(_data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.editionId = _data["editionId"];
            this.isInTrialPeriod = _data["isInTrialPeriod"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["editionDisplayName"] = this.editionDisplayName;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toString() : <any>undefined;
        data["editionId"] = this.editionId;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean;
    creationTime: DateTime;
    subscriptionEndDateUtc: DateTime | undefined;
    editionId: number | undefined;
    isInTrialPeriod: boolean;
    id: number;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount!: number;
    items!: TenantListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount: number;
    items: TenantListDto[] | undefined;
}

export class CreateTenantInput implements ICreateTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    connectionString!: string | undefined;
    shouldChangePasswordOnNextLogin!: boolean;
    sendActivationEmail!: boolean;
    editionId!: number | undefined;
    isActive!: boolean;
    subscriptionEndDateUtc!: DateTime | undefined;
    isInTrialPeriod!: boolean;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.adminPassword = _data["adminPassword"];
            this.connectionString = _data["connectionString"];
            this.shouldChangePasswordOnNextLogin = _data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = _data["sendActivationEmail"];
            this.editionId = _data["editionId"];
            this.isActive = _data["isActive"];
            this.subscriptionEndDateUtc = _data["subscriptionEndDateUtc"] ? DateTime.fromISO(_data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = _data["isInTrialPeriod"];
        }
    }

    static fromJS(data: any): CreateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["connectionString"] = this.connectionString;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        return data;
    }
}

export interface ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean;
    sendActivationEmail: boolean;
    editionId: number | undefined;
    isActive: boolean;
    subscriptionEndDateUtc: DateTime | undefined;
    isInTrialPeriod: boolean;
}

export class TenantEditDto implements ITenantEditDto {
    tenancyName!: string;
    name!: string;
    connectionString!: string | undefined;
    editionId!: number | undefined;
    isActive!: boolean;
    subscriptionEndDateUtc!: DateTime | undefined;
    isInTrialPeriod!: boolean;
    id!: number;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.connectionString = _data["connectionString"];
            this.editionId = _data["editionId"];
            this.isActive = _data["isActive"];
            this.subscriptionEndDateUtc = _data["subscriptionEndDateUtc"] ? DateTime.fromISO(_data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = _data["isInTrialPeriod"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean;
    subscriptionEndDateUtc: DateTime | undefined;
    isInTrialPeriod: boolean;
    id: number;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id!: number;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.featureValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateTenantFeaturesInput {
    id: number;
    featureValues: NameValueDto[];
}

export class EntityDto implements IEntityDto {
    id!: number;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityDto {
    id: number;
}

export class MemberActivity implements IMemberActivity {
    name!: string | undefined;
    earnings!: string | undefined;
    cases!: number;
    closed!: number;
    rate!: string | undefined;

    constructor(data?: IMemberActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.earnings = _data["earnings"];
            this.cases = _data["cases"];
            this.closed = _data["closed"];
            this.rate = _data["rate"];
        }
    }

    static fromJS(data: any): MemberActivity {
        data = typeof data === 'object' ? data : {};
        let result = new MemberActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["earnings"] = this.earnings;
        data["cases"] = this.cases;
        data["closed"] = this.closed;
        data["rate"] = this.rate;
        return data;
    }
}

export interface IMemberActivity {
    name: string | undefined;
    earnings: string | undefined;
    cases: number;
    closed: number;
    rate: string | undefined;
}

export class GetMemberActivityOutput implements IGetMemberActivityOutput {
    memberActivities!: MemberActivity[] | undefined;

    constructor(data?: IGetMemberActivityOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["memberActivities"])) {
                this.memberActivities = [] as any;
                for (let item of _data["memberActivities"])
                    this.memberActivities!.push(MemberActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMemberActivityOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberActivityOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.memberActivities)) {
            data["memberActivities"] = [];
            for (let item of this.memberActivities)
                data["memberActivities"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetMemberActivityOutput {
    memberActivities: MemberActivity[] | undefined;
}

export enum SalesSummaryDatePeriod {
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
}

export class SalesSummaryData implements ISalesSummaryData {
    period!: string | undefined;
    sales!: number;
    profit!: number;

    constructor(data?: ISalesSummaryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.period = _data["period"];
            this.sales = _data["sales"];
            this.profit = _data["profit"];
        }
    }

    static fromJS(data: any): SalesSummaryData {
        data = typeof data === 'object' ? data : {};
        let result = new SalesSummaryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        data["sales"] = this.sales;
        data["profit"] = this.profit;
        return data;
    }
}

export interface ISalesSummaryData {
    period: string | undefined;
    sales: number;
    profit: number;
}

export class GetDashboardDataOutput implements IGetDashboardDataOutput {
    totalProfit!: number;
    newFeedbacks!: number;
    newOrders!: number;
    newUsers!: number;
    salesSummary!: SalesSummaryData[] | undefined;
    totalSales!: number;
    revenue!: number;
    expenses!: number;
    growth!: number;
    transactionPercent!: number;
    newVisitPercent!: number;
    bouncePercent!: number;
    dailySales!: number[] | undefined;
    profitShares!: number[] | undefined;

    constructor(data?: IGetDashboardDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProfit = _data["totalProfit"];
            this.newFeedbacks = _data["newFeedbacks"];
            this.newOrders = _data["newOrders"];
            this.newUsers = _data["newUsers"];
            if (Array.isArray(_data["salesSummary"])) {
                this.salesSummary = [] as any;
                for (let item of _data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
            this.totalSales = _data["totalSales"];
            this.revenue = _data["revenue"];
            this.expenses = _data["expenses"];
            this.growth = _data["growth"];
            this.transactionPercent = _data["transactionPercent"];
            this.newVisitPercent = _data["newVisitPercent"];
            this.bouncePercent = _data["bouncePercent"];
            if (Array.isArray(_data["dailySales"])) {
                this.dailySales = [] as any;
                for (let item of _data["dailySales"])
                    this.dailySales!.push(item);
            }
            if (Array.isArray(_data["profitShares"])) {
                this.profitShares = [] as any;
                for (let item of _data["profitShares"])
                    this.profitShares!.push(item);
            }
        }
    }

    static fromJS(data: any): GetDashboardDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDashboardDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        if (Array.isArray(this.salesSummary)) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        if (Array.isArray(this.dailySales)) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        if (Array.isArray(this.profitShares)) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data;
    }
}

export interface IGetDashboardDataOutput {
    totalProfit: number;
    newFeedbacks: number;
    newOrders: number;
    newUsers: number;
    salesSummary: SalesSummaryData[] | undefined;
    totalSales: number;
    revenue: number;
    expenses: number;
    growth: number;
    transactionPercent: number;
    newVisitPercent: number;
    bouncePercent: number;
    dailySales: number[] | undefined;
    profitShares: number[] | undefined;
}

export class GetTopStatsOutput implements IGetTopStatsOutput {
    totalProfit!: number;
    newFeedbacks!: number;
    newOrders!: number;
    newUsers!: number;

    constructor(data?: IGetTopStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProfit = _data["totalProfit"];
            this.newFeedbacks = _data["newFeedbacks"];
            this.newOrders = _data["newOrders"];
            this.newUsers = _data["newUsers"];
        }
    }

    static fromJS(data: any): GetTopStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTopStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        return data;
    }
}

export interface IGetTopStatsOutput {
    totalProfit: number;
    newFeedbacks: number;
    newOrders: number;
    newUsers: number;
}

export class GetProfitShareOutput implements IGetProfitShareOutput {
    profitShares!: number[] | undefined;

    constructor(data?: IGetProfitShareOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["profitShares"])) {
                this.profitShares = [] as any;
                for (let item of _data["profitShares"])
                    this.profitShares!.push(item);
            }
        }
    }

    static fromJS(data: any): GetProfitShareOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfitShareOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.profitShares)) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data;
    }
}

export interface IGetProfitShareOutput {
    profitShares: number[] | undefined;
}

export class GetDailySalesOutput implements IGetDailySalesOutput {
    dailySales!: number[] | undefined;

    constructor(data?: IGetDailySalesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["dailySales"])) {
                this.dailySales = [] as any;
                for (let item of _data["dailySales"])
                    this.dailySales!.push(item);
            }
        }
    }

    static fromJS(data: any): GetDailySalesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDailySalesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dailySales)) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        return data;
    }
}

export interface IGetDailySalesOutput {
    dailySales: number[] | undefined;
}

export class GetSalesSummaryOutput implements IGetSalesSummaryOutput {
    totalSales!: number;
    revenue!: number;
    expenses!: number;
    growth!: number;
    salesSummary!: SalesSummaryData[] | undefined;

    constructor(data?: IGetSalesSummaryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalSales = _data["totalSales"];
            this.revenue = _data["revenue"];
            this.expenses = _data["expenses"];
            this.growth = _data["growth"];
            if (Array.isArray(_data["salesSummary"])) {
                this.salesSummary = [] as any;
                for (let item of _data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSalesSummaryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSalesSummaryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        if (Array.isArray(this.salesSummary)) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetSalesSummaryOutput {
    totalSales: number;
    revenue: number;
    expenses: number;
    growth: number;
    salesSummary: SalesSummaryData[] | undefined;
}

export class RegionalStatCountry implements IRegionalStatCountry {
    countryName!: string | undefined;
    sales!: number;
    change!: number[] | undefined;
    averagePrice!: number;
    totalPrice!: number;

    constructor(data?: IRegionalStatCountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryName = _data["countryName"];
            this.sales = _data["sales"];
            if (Array.isArray(_data["change"])) {
                this.change = [] as any;
                for (let item of _data["change"])
                    this.change!.push(item);
            }
            this.averagePrice = _data["averagePrice"];
            this.totalPrice = _data["totalPrice"];
        }
    }

    static fromJS(data: any): RegionalStatCountry {
        data = typeof data === 'object' ? data : {};
        let result = new RegionalStatCountry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryName"] = this.countryName;
        data["sales"] = this.sales;
        if (Array.isArray(this.change)) {
            data["change"] = [];
            for (let item of this.change)
                data["change"].push(item);
        }
        data["averagePrice"] = this.averagePrice;
        data["totalPrice"] = this.totalPrice;
        return data;
    }
}

export interface IRegionalStatCountry {
    countryName: string | undefined;
    sales: number;
    change: number[] | undefined;
    averagePrice: number;
    totalPrice: number;
}

export class GetRegionalStatsOutput implements IGetRegionalStatsOutput {
    stats!: RegionalStatCountry[] | undefined;

    constructor(data?: IGetRegionalStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["stats"])) {
                this.stats = [] as any;
                for (let item of _data["stats"])
                    this.stats!.push(RegionalStatCountry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRegionalStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRegionalStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.stats)) {
            data["stats"] = [];
            for (let item of this.stats)
                data["stats"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetRegionalStatsOutput {
    stats: RegionalStatCountry[] | undefined;
}

export class GetGeneralStatsOutput implements IGetGeneralStatsOutput {
    transactionPercent!: number;
    newVisitPercent!: number;
    bouncePercent!: number;

    constructor(data?: IGetGeneralStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionPercent = _data["transactionPercent"];
            this.newVisitPercent = _data["newVisitPercent"];
            this.bouncePercent = _data["bouncePercent"];
        }
    }

    static fromJS(data: any): GetGeneralStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        return data;
    }
}

export interface IGetGeneralStatsOutput {
    transactionPercent: number;
    newVisitPercent: number;
    bouncePercent: number;
}

export enum SubscriptionStartType {
    Free = 1,
    Trial = 2,
    Paid = 3,
}

export class RegisterTenantInput implements IRegisterTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    captchaResponse!: string | undefined;
    subscriptionStartType!: SubscriptionStartType;
    editionId!: number | undefined;

    constructor(data?: IRegisterTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.adminPassword = _data["adminPassword"];
            this.captchaResponse = _data["captchaResponse"];
            this.subscriptionStartType = _data["subscriptionStartType"];
            this.editionId = _data["editionId"];
        }
    }

    static fromJS(data: any): RegisterTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["captchaResponse"] = this.captchaResponse;
        data["subscriptionStartType"] = this.subscriptionStartType;
        data["editionId"] = this.editionId;
        return data;
    }
}

export interface IRegisterTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    captchaResponse: string | undefined;
    subscriptionStartType: SubscriptionStartType;
    editionId: number | undefined;
}

export class RegisterTenantOutput implements IRegisterTenantOutput {
    tenantId!: number;
    tenancyName!: string | undefined;
    name!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    isTenantActive!: boolean;
    isActive!: boolean;
    isEmailConfirmationRequired!: boolean;

    constructor(data?: IRegisterTenantOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.isTenantActive = _data["isTenantActive"];
            this.isActive = _data["isActive"];
            this.isEmailConfirmationRequired = _data["isEmailConfirmationRequired"];
        }
    }

    static fromJS(data: any): RegisterTenantOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isTenantActive"] = this.isTenantActive;
        data["isActive"] = this.isActive;
        data["isEmailConfirmationRequired"] = this.isEmailConfirmationRequired;
        return data;
    }
}

export interface IRegisterTenantOutput {
    tenantId: number;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isTenantActive: boolean;
    isActive: boolean;
    isEmailConfirmationRequired: boolean;
}

export class FlatFeatureSelectDto implements IFlatFeatureSelectDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: IInputType;
    textHtmlColor!: string | undefined;

    constructor(data?: IFlatFeatureSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.defaultValue = _data["defaultValue"];
            this.inputType = _data["inputType"] ? IInputType.fromJS(_data["inputType"]) : <any>undefined;
            this.textHtmlColor = _data["textHtmlColor"];
        }
    }

    static fromJS(data: any): FlatFeatureSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        data["textHtmlColor"] = this.textHtmlColor;
        return data;
    }
}

export interface IFlatFeatureSelectDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: IInputType;
    textHtmlColor: string | undefined;
}

export class EditionWithFeaturesDto implements IEditionWithFeaturesDto {
    edition!: EditionSelectDto;
    featureValues!: NameValueDto[] | undefined;

    constructor(data?: IEditionWithFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionSelectDto.fromJS(_data["edition"]) : <any>undefined;
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionWithFeaturesDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionWithFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEditionWithFeaturesDto {
    edition: EditionSelectDto;
    featureValues: NameValueDto[] | undefined;
}

export class EditionsSelectOutput implements IEditionsSelectOutput {
    allFeatures!: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures!: EditionWithFeaturesDto[] | undefined;

    constructor(data?: IEditionsSelectOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["allFeatures"])) {
                this.allFeatures = [] as any;
                for (let item of _data["allFeatures"])
                    this.allFeatures!.push(FlatFeatureSelectDto.fromJS(item));
            }
            if (Array.isArray(_data["editionsWithFeatures"])) {
                this.editionsWithFeatures = [] as any;
                for (let item of _data["editionsWithFeatures"])
                    this.editionsWithFeatures!.push(EditionWithFeaturesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionsSelectOutput {
        data = typeof data === 'object' ? data : {};
        let result = new EditionsSelectOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.allFeatures)) {
            data["allFeatures"] = [];
            for (let item of this.allFeatures)
                data["allFeatures"].push(item.toJSON());
        }
        if (Array.isArray(this.editionsWithFeatures)) {
            data["editionsWithFeatures"] = [];
            for (let item of this.editionsWithFeatures)
                data["editionsWithFeatures"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEditionsSelectOutput {
    allFeatures: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures: EditionWithFeaturesDto[] | undefined;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
    allowSelfRegistration!: boolean;
    isNewRegisteredUserActiveByDefault!: boolean;
    isEmailConfirmationRequiredForLogin!: boolean;
    useCaptchaOnRegistration!: boolean;
    useCaptchaOnLogin!: boolean;
    isCookieConsentEnabled!: boolean;
    isQuickThemeSelectEnabled!: boolean;
    allowUsingGravatarProfilePicture!: boolean;
    sessionTimeOutSettings!: SessionTimeOutSettingsEditDto;

    constructor(data?: ITenantUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowSelfRegistration = _data["allowSelfRegistration"];
            this.isNewRegisteredUserActiveByDefault = _data["isNewRegisteredUserActiveByDefault"];
            this.isEmailConfirmationRequiredForLogin = _data["isEmailConfirmationRequiredForLogin"];
            this.useCaptchaOnRegistration = _data["useCaptchaOnRegistration"];
            this.useCaptchaOnLogin = _data["useCaptchaOnLogin"];
            this.isCookieConsentEnabled = _data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
            this.allowUsingGravatarProfilePicture = _data["allowUsingGravatarProfilePicture"];
            this.sessionTimeOutSettings = _data["sessionTimeOutSettings"] ? SessionTimeOutSettingsEditDto.fromJS(_data["sessionTimeOutSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredUserActiveByDefault"] = this.isNewRegisteredUserActiveByDefault;
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["useCaptchaOnLogin"] = this.useCaptchaOnLogin;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        data["allowUsingGravatarProfilePicture"] = this.allowUsingGravatarProfilePicture;
        data["sessionTimeOutSettings"] = this.sessionTimeOutSettings ? this.sessionTimeOutSettings.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredUserActiveByDefault: boolean;
    isEmailConfirmationRequiredForLogin: boolean;
    useCaptchaOnRegistration: boolean;
    useCaptchaOnLogin: boolean;
    isCookieConsentEnabled: boolean;
    isQuickThemeSelectEnabled: boolean;
    allowUsingGravatarProfilePicture: boolean;
    sessionTimeOutSettings: SessionTimeOutSettingsEditDto;
}

export class TenantEmailSettingsEditDto implements ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings!: boolean;
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean;
    smtpUseDefaultCredentials!: boolean;

    constructor(data?: ITenantEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.useHostDefaultEmailSettings = _data["useHostDefaultEmailSettings"];
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
            this.smtpHost = _data["smtpHost"];
            this.smtpPort = _data["smtpPort"];
            this.smtpUserName = _data["smtpUserName"];
            this.smtpPassword = _data["smtpPassword"];
            this.smtpDomain = _data["smtpDomain"];
            this.smtpEnableSsl = _data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): TenantEmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useHostDefaultEmailSettings"] = this.useHostDefaultEmailSettings;
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data;
    }
}

export interface ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings: boolean;
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
    isModuleEnabled!: boolean;
    isEnabled!: boolean;
    domain!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;

    constructor(data?: ILdapSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isModuleEnabled = _data["isModuleEnabled"];
            this.isEnabled = _data["isEnabled"];
            this.domain = _data["domain"];
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LdapSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LdapSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isModuleEnabled"] = this.isModuleEnabled;
        data["isEnabled"] = this.isEnabled;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface ILdapSettingsEditDto {
    isModuleEnabled: boolean;
    isEnabled: boolean;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;
}

export class TenantBillingSettingsEditDto implements ITenantBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;
    taxVatNo!: string | undefined;

    constructor(data?: ITenantBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.legalName = _data["legalName"];
            this.address = _data["address"];
            this.taxVatNo = _data["taxVatNo"];
        }
    }

    static fromJS(data: any): TenantBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        return data;
    }
}

export interface ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;
}

export class TenantOtherSettingsEditDto implements ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean;

    constructor(data?: ITenantOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): TenantOtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantOtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data;
    }
}

export interface ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: TenantUserManagementSettingsEditDto;
    email!: TenantEmailSettingsEditDto;
    ldap!: LdapSettingsEditDto;
    security!: SecuritySettingsEditDto;
    billing!: TenantBillingSettingsEditDto;
    otherSettings!: TenantOtherSettingsEditDto;
    externalLoginProviderSettings!: ExternalLoginProviderSettingsEditDto;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userManagement = new TenantUserManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.general = _data["general"] ? GeneralSettingsEditDto.fromJS(_data["general"]) : <any>undefined;
            this.userManagement = _data["userManagement"] ? TenantUserManagementSettingsEditDto.fromJS(_data["userManagement"]) : new TenantUserManagementSettingsEditDto();
            this.email = _data["email"] ? TenantEmailSettingsEditDto.fromJS(_data["email"]) : <any>undefined;
            this.ldap = _data["ldap"] ? LdapSettingsEditDto.fromJS(_data["ldap"]) : <any>undefined;
            this.security = _data["security"] ? SecuritySettingsEditDto.fromJS(_data["security"]) : new SecuritySettingsEditDto();
            this.billing = _data["billing"] ? TenantBillingSettingsEditDto.fromJS(_data["billing"]) : <any>undefined;
            this.otherSettings = _data["otherSettings"] ? TenantOtherSettingsEditDto.fromJS(_data["otherSettings"]) : <any>undefined;
            this.externalLoginProviderSettings = _data["externalLoginProviderSettings"] ? ExternalLoginProviderSettingsEditDto.fromJS(_data["externalLoginProviderSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["ldap"] = this.ldap ? this.ldap.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        data["externalLoginProviderSettings"] = this.externalLoginProviderSettings ? this.externalLoginProviderSettings.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITenantSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: TenantUserManagementSettingsEditDto;
    email: TenantEmailSettingsEditDto;
    ldap: LdapSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto;
    otherSettings: TenantOtherSettingsEditDto;
    externalLoginProviderSettings: ExternalLoginProviderSettingsEditDto;
}

export enum SettingScopes {
    Application = 1,
    Tenant = 2,
    User = 4,
    All = 7,
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
    items!: NameValueDto[] | undefined;

    constructor(data?: IListResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress!: string;
    password!: string;
    twoFactorVerificationCode!: string | undefined;
    rememberClient!: boolean;
    twoFactorRememberClientToken!: string | undefined;
    singleSignIn!: boolean | undefined;
    returnUrl!: string | undefined;
    captchaResponse!: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.twoFactorVerificationCode = _data["twoFactorVerificationCode"];
            this.rememberClient = _data["rememberClient"];
            this.twoFactorRememberClientToken = _data["twoFactorRememberClientToken"];
            this.singleSignIn = _data["singleSignIn"];
            this.returnUrl = _data["returnUrl"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["twoFactorVerificationCode"] = this.twoFactorVerificationCode;
        data["rememberClient"] = this.rememberClient;
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["singleSignIn"] = this.singleSignIn;
        data["returnUrl"] = this.returnUrl;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    twoFactorVerificationCode: string | undefined;
    rememberClient: boolean;
    twoFactorRememberClientToken: string | undefined;
    singleSignIn: boolean | undefined;
    returnUrl: string | undefined;
    captchaResponse: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    shouldResetPassword!: boolean;
    passwordResetCode!: string | undefined;
    userId!: number;
    requiresTwoFactorVerification!: boolean;
    twoFactorAuthProviders!: string[] | undefined;
    twoFactorRememberClientToken!: string | undefined;
    returnUrl!: string | undefined;
    refreshToken!: string | undefined;
    refreshTokenExpireInSeconds!: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.shouldResetPassword = _data["shouldResetPassword"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.userId = _data["userId"];
            this.requiresTwoFactorVerification = _data["requiresTwoFactorVerification"];
            if (Array.isArray(_data["twoFactorAuthProviders"])) {
                this.twoFactorAuthProviders = [] as any;
                for (let item of _data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders!.push(item);
            }
            this.twoFactorRememberClientToken = _data["twoFactorRememberClientToken"];
            this.returnUrl = _data["returnUrl"];
            this.refreshToken = _data["refreshToken"];
            this.refreshTokenExpireInSeconds = _data["refreshTokenExpireInSeconds"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (Array.isArray(this.twoFactorAuthProviders)) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        data["refreshToken"] = this.refreshToken;
        data["refreshTokenExpireInSeconds"] = this.refreshTokenExpireInSeconds;
        return data;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    shouldResetPassword: boolean;
    passwordResetCode: string | undefined;
    userId: number;
    requiresTwoFactorVerification: boolean;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
    refreshToken: string | undefined;
    refreshTokenExpireInSeconds: number;
}

export class RefreshTokenResult implements IRefreshTokenResult {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;

    constructor(data?: IRefreshTokenResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): RefreshTokenResult {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data;
    }
}

export interface IRefreshTokenResult {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export class SendTwoFactorAuthCodeModel implements ISendTwoFactorAuthCodeModel {
    userId!: number;
    provider!: string;

    constructor(data?: ISendTwoFactorAuthCodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.provider = _data["provider"];
        }
    }

    static fromJS(data: any): SendTwoFactorAuthCodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendTwoFactorAuthCodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["provider"] = this.provider;
        return data;
    }
}

export interface ISendTwoFactorAuthCodeModel {
    userId: number;
    provider: string;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;

    constructor(data?: IImpersonatedAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): ImpersonatedAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data;
    }
}

export interface IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;

    constructor(data?: ISwitchedAccountAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data;
    }
}

export interface ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name!: string | undefined;
    clientId!: string | undefined;
    additionalParams!: { [key: string]: string; } | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
            if (_data["additionalParams"]) {
                this.additionalParams = {} as any;
                for (let key in _data["additionalParams"]) {
                    if (_data["additionalParams"].hasOwnProperty(key))
                        (<any>this.additionalParams)![key] = _data["additionalParams"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        if (this.additionalParams) {
            data["additionalParams"] = {};
            for (let key in this.additionalParams) {
                if (this.additionalParams.hasOwnProperty(key))
                    (<any>data["additionalParams"])[key] = (<any>this.additionalParams)[key];
            }
        }
        return data;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
    additionalParams: { [key: string]: string; } | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider!: string;
    providerKey!: string;
    providerAccessCode!: string;
    returnUrl!: string | undefined;
    singleSignIn!: boolean | undefined;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
            this.returnUrl = _data["returnUrl"];
            this.singleSignIn = _data["singleSignIn"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        return data;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    returnUrl: string | undefined;
    singleSignIn: boolean | undefined;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    waitingForActivation!: boolean;
    returnUrl!: string | undefined;
    refreshToken!: string | undefined;
    refreshTokenExpireInSeconds!: number;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
            this.returnUrl = _data["returnUrl"];
            this.refreshToken = _data["refreshToken"];
            this.refreshTokenExpireInSeconds = _data["refreshTokenExpireInSeconds"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        data["returnUrl"] = this.returnUrl;
        data["refreshToken"] = this.refreshToken;
        data["refreshTokenExpireInSeconds"] = this.refreshTokenExpireInSeconds;
        return data;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
    returnUrl: string | undefined;
    refreshToken: string | undefined;
    refreshTokenExpireInSeconds: number;
}

export class TwitterGetRequestTokenResponse implements ITwitterGetRequestTokenResponse {
    token!: string | undefined;
    secret!: string | undefined;
    confirmed!: boolean;
    redirectUrl!: string | undefined;

    constructor(data?: ITwitterGetRequestTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.secret = _data["secret"];
            this.confirmed = _data["confirmed"];
            this.redirectUrl = _data["redirectUrl"];
        }
    }

    static fromJS(data: any): TwitterGetRequestTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TwitterGetRequestTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["secret"] = this.secret;
        data["confirmed"] = this.confirmed;
        data["redirectUrl"] = this.redirectUrl;
        return data;
    }
}

export interface ITwitterGetRequestTokenResponse {
    token: string | undefined;
    secret: string | undefined;
    confirmed: boolean;
    redirectUrl: string | undefined;
}

export class TwitterGetAccessTokenResponse implements ITwitterGetAccessTokenResponse {
    accessToken!: string | undefined;
    accessTokenSecret!: string | undefined;
    userId!: string | undefined;
    userName!: string | undefined;

    constructor(data?: ITwitterGetAccessTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.accessTokenSecret = _data["accessTokenSecret"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): TwitterGetAccessTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TwitterGetAccessTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["accessTokenSecret"] = this.accessTokenSecret;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        return data;
    }
}

export interface ITwitterGetAccessTokenResponse {
    accessToken: string | undefined;
    accessTokenSecret: string | undefined;
    userId: string | undefined;
    userName: string | undefined;
}

export class GetAllCatalogProductForViewDto implements IGetAllCatalogProductForViewDto {
    inventoryGroupId!: number | undefined;
    picDepartmentId!: string;
    productGroupName!: string | undefined;
    productName!: string | undefined;
    productCode!: string | undefined;
    color!: string | undefined;
    primaryUomCode!: string | undefined;
    supplierId!: number;
    supplierName!: string | undefined;
    currencyId!: number;
    currencyCode!: string | undefined;
    unitPrice!: number | undefined;
    taxPrice!: number | undefined;
    effectiveFrom!: DateTime | undefined;
    effectiveTo!: DateTime | undefined;
    productImage!: string | undefined;
    inventoryItemId!: number | undefined;
    totalCount!: number;
    id!: number;

    constructor(data?: IGetAllCatalogProductForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.picDepartmentId = _data["picDepartmentId"];
            this.productGroupName = _data["productGroupName"];
            this.productName = _data["productName"];
            this.productCode = _data["productCode"];
            this.color = _data["color"];
            this.primaryUomCode = _data["primaryUomCode"];
            this.supplierId = _data["supplierId"];
            this.supplierName = _data["supplierName"];
            this.currencyId = _data["currencyId"];
            this.currencyCode = _data["currencyCode"];
            this.unitPrice = _data["unitPrice"];
            this.taxPrice = _data["taxPrice"];
            this.effectiveFrom = _data["effectiveFrom"] ? DateTime.fromISO(_data["effectiveFrom"].toString()) : <any>undefined;
            this.effectiveTo = _data["effectiveTo"] ? DateTime.fromISO(_data["effectiveTo"].toString()) : <any>undefined;
            this.productImage = _data["productImage"];
            this.inventoryItemId = _data["inventoryItemId"];
            this.totalCount = _data["totalCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAllCatalogProductForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllCatalogProductForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["picDepartmentId"] = this.picDepartmentId;
        data["productGroupName"] = this.productGroupName;
        data["productName"] = this.productName;
        data["productCode"] = this.productCode;
        data["color"] = this.color;
        data["primaryUomCode"] = this.primaryUomCode;
        data["supplierId"] = this.supplierId;
        data["supplierName"] = this.supplierName;
        data["currencyId"] = this.currencyId;
        data["currencyCode"] = this.currencyCode;
        data["unitPrice"] = this.unitPrice;
        data["taxPrice"] = this.taxPrice;
        data["effectiveFrom"] = this.effectiveFrom ? this.effectiveFrom.toString() : <any>undefined;
        data["effectiveTo"] = this.effectiveTo ? this.effectiveTo.toString() : <any>undefined;
        data["productImage"] = this.productImage;
        data["inventoryItemId"] = this.inventoryItemId;
        data["totalCount"] = this.totalCount;
        data["id"] = this.id;
        return data;
    }
}

export interface IGetAllCatalogProductForViewDto {
    inventoryGroupId: number | undefined;
    picDepartmentId: string;
    productGroupName: string | undefined;
    productName: string | undefined;
    productCode: string | undefined;
    color: string | undefined;
    primaryUomCode: string | undefined;
    supplierId: number;
    supplierName: string | undefined;
    currencyId: number;
    currencyCode: string | undefined;
    unitPrice: number | undefined;
    taxPrice: number | undefined;
    effectiveFrom: DateTime | undefined;
    effectiveTo: DateTime | undefined;
    productImage: string | undefined;
    inventoryItemId: number | undefined;
    totalCount: number;
    id: number;
}

export class PagedResultDtoOfGetAllCatalogProductForViewDto implements IPagedResultDtoOfGetAllCatalogProductForViewDto {
    totalCount!: number;
    items!: GetAllCatalogProductForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAllCatalogProductForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllCatalogProductForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAllCatalogProductForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAllCatalogProductForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAllCatalogProductForViewDto {
    totalCount: number;
    items: GetAllCatalogProductForViewDto[] | undefined;
}

export class CreateBuyRequestFromCatalogDto implements ICreateBuyRequestFromCatalogDto {
    productName!: string | undefined;
    supplierId!: number;
    supplierName!: string | undefined;
    currencyId!: number;
    documentDate!: DateTime | undefined;
    currencyCode!: string | undefined;
    contractPriceAmount!: number | undefined;
    qty!: number;
    inventoryItemId!: number | undefined;
    inventoryGroupId!: number | undefined;
    unitPrice!: number | undefined;
    taxPrice!: number | undefined;
    picDepartmentId!: string;
    uom!: string | undefined;
    deliveryDate!: DateTime;
    budgetCodeId!: number | undefined;
    headerBudgetCodeId!: number | undefined;
    userRequestName!: string | undefined;
    id!: number;

    constructor(data?: ICreateBuyRequestFromCatalogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productName = _data["productName"];
            this.supplierId = _data["supplierId"];
            this.supplierName = _data["supplierName"];
            this.currencyId = _data["currencyId"];
            this.documentDate = _data["documentDate"] ? DateTime.fromISO(_data["documentDate"].toString()) : <any>undefined;
            this.currencyCode = _data["currencyCode"];
            this.contractPriceAmount = _data["contractPriceAmount"];
            this.qty = _data["qty"];
            this.inventoryItemId = _data["inventoryItemId"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.unitPrice = _data["unitPrice"];
            this.taxPrice = _data["taxPrice"];
            this.picDepartmentId = _data["picDepartmentId"];
            this.uom = _data["uom"];
            this.deliveryDate = _data["deliveryDate"] ? DateTime.fromISO(_data["deliveryDate"].toString()) : <any>undefined;
            this.budgetCodeId = _data["budgetCodeId"];
            this.headerBudgetCodeId = _data["headerBudgetCodeId"];
            this.userRequestName = _data["userRequestName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateBuyRequestFromCatalogDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBuyRequestFromCatalogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productName"] = this.productName;
        data["supplierId"] = this.supplierId;
        data["supplierName"] = this.supplierName;
        data["currencyId"] = this.currencyId;
        data["documentDate"] = this.documentDate ? this.documentDate.toString() : <any>undefined;
        data["currencyCode"] = this.currencyCode;
        data["contractPriceAmount"] = this.contractPriceAmount;
        data["qty"] = this.qty;
        data["inventoryItemId"] = this.inventoryItemId;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["unitPrice"] = this.unitPrice;
        data["taxPrice"] = this.taxPrice;
        data["picDepartmentId"] = this.picDepartmentId;
        data["uom"] = this.uom;
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toString() : <any>undefined;
        data["budgetCodeId"] = this.budgetCodeId;
        data["headerBudgetCodeId"] = this.headerBudgetCodeId;
        data["userRequestName"] = this.userRequestName;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateBuyRequestFromCatalogDto {
    productName: string | undefined;
    supplierId: number;
    supplierName: string | undefined;
    currencyId: number;
    documentDate: DateTime | undefined;
    currencyCode: string | undefined;
    contractPriceAmount: number | undefined;
    qty: number;
    inventoryItemId: number | undefined;
    inventoryGroupId: number | undefined;
    unitPrice: number | undefined;
    taxPrice: number | undefined;
    picDepartmentId: string;
    uom: string | undefined;
    deliveryDate: DateTime;
    budgetCodeId: number | undefined;
    headerBudgetCodeId: number | undefined;
    userRequestName: string | undefined;
    id: number;
}

export class GetAllUserRequestForViewDto implements IGetAllUserRequestForViewDto {
    userRequestNumber!: string | undefined;
    userRequestName!: string | undefined;
    requestDate!: DateTime | undefined;
    creatorUserId!: number | undefined;
    requestUser!: string | undefined;
    departmentName!: string | undefined;
    approvalStatus!: string | undefined;
    departmentApprovalName!: string | undefined;
    checkBudgetStatus!: string | undefined;
    totalPrice!: number | undefined;
    currencyCode!: string | undefined;
    productGroupName!: string | undefined;
    totalCount!: number;
    requestNote!: string | undefined;
    replyNote!: string | undefined;
    id!: number;

    constructor(data?: IGetAllUserRequestForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRequestNumber = _data["userRequestNumber"];
            this.userRequestName = _data["userRequestName"];
            this.requestDate = _data["requestDate"] ? DateTime.fromISO(_data["requestDate"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.requestUser = _data["requestUser"];
            this.departmentName = _data["departmentName"];
            this.approvalStatus = _data["approvalStatus"];
            this.departmentApprovalName = _data["departmentApprovalName"];
            this.checkBudgetStatus = _data["checkBudgetStatus"];
            this.totalPrice = _data["totalPrice"];
            this.currencyCode = _data["currencyCode"];
            this.productGroupName = _data["productGroupName"];
            this.totalCount = _data["totalCount"];
            this.requestNote = _data["requestNote"];
            this.replyNote = _data["replyNote"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAllUserRequestForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllUserRequestForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRequestNumber"] = this.userRequestNumber;
        data["userRequestName"] = this.userRequestName;
        data["requestDate"] = this.requestDate ? this.requestDate.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["requestUser"] = this.requestUser;
        data["departmentName"] = this.departmentName;
        data["approvalStatus"] = this.approvalStatus;
        data["departmentApprovalName"] = this.departmentApprovalName;
        data["checkBudgetStatus"] = this.checkBudgetStatus;
        data["totalPrice"] = this.totalPrice;
        data["currencyCode"] = this.currencyCode;
        data["productGroupName"] = this.productGroupName;
        data["totalCount"] = this.totalCount;
        data["requestNote"] = this.requestNote;
        data["replyNote"] = this.replyNote;
        data["id"] = this.id;
        return data;
    }
}

export interface IGetAllUserRequestForViewDto {
    userRequestNumber: string | undefined;
    userRequestName: string | undefined;
    requestDate: DateTime | undefined;
    creatorUserId: number | undefined;
    requestUser: string | undefined;
    departmentName: string | undefined;
    approvalStatus: string | undefined;
    departmentApprovalName: string | undefined;
    checkBudgetStatus: string | undefined;
    totalPrice: number | undefined;
    currencyCode: string | undefined;
    productGroupName: string | undefined;
    totalCount: number;
    requestNote: string | undefined;
    replyNote: string | undefined;
    id: number;
}

export class PagedResultDtoOfGetAllUserRequestForViewDto implements IPagedResultDtoOfGetAllUserRequestForViewDto {
    totalCount!: number;
    items!: GetAllUserRequestForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAllUserRequestForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllUserRequestForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAllUserRequestForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAllUserRequestForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAllUserRequestForViewDto {
    totalCount: number;
    items: GetAllUserRequestForViewDto[] | undefined;
}

export class GetAllProductsForViewDto implements IGetAllProductsForViewDto {
    inventoryItemId!: number | undefined;
    inventoryGroupId!: number | undefined;
    picDepartmentId!: string | undefined;
    budgetCodeId!: number | undefined;
    budgetCode!: string | undefined;
    productCode!: string | undefined;
    color!: string | undefined;
    productName!: string | undefined;
    uom!: string | undefined;
    currencyId!: number | undefined;
    originalCurrencyId!: number | undefined;
    currencyCode!: string | undefined;
    supplierId!: number | undefined;
    supplierName!: string | undefined;
    unitPrice!: number;
    exchangeUnitPrice!: number;
    quantity!: number;
    deliveryDate!: DateTime | undefined;
    monthN!: number;
    monthN1!: number;
    monthN2!: number;
    monthN3!: number;
    lineNum!: number | undefined;
    totalCount!: number;
    id!: number;

    constructor(data?: IGetAllProductsForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inventoryItemId = _data["inventoryItemId"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.picDepartmentId = _data["picDepartmentId"];
            this.budgetCodeId = _data["budgetCodeId"];
            this.budgetCode = _data["budgetCode"];
            this.productCode = _data["productCode"];
            this.color = _data["color"];
            this.productName = _data["productName"];
            this.uom = _data["uom"];
            this.currencyId = _data["currencyId"];
            this.originalCurrencyId = _data["originalCurrencyId"];
            this.currencyCode = _data["currencyCode"];
            this.supplierId = _data["supplierId"];
            this.supplierName = _data["supplierName"];
            this.unitPrice = _data["unitPrice"];
            this.exchangeUnitPrice = _data["exchangeUnitPrice"];
            this.quantity = _data["quantity"];
            this.deliveryDate = _data["deliveryDate"] ? DateTime.fromISO(_data["deliveryDate"].toString()) : <any>undefined;
            this.monthN = _data["monthN"];
            this.monthN1 = _data["monthN1"];
            this.monthN2 = _data["monthN2"];
            this.monthN3 = _data["monthN3"];
            this.lineNum = _data["lineNum"];
            this.totalCount = _data["totalCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAllProductsForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllProductsForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inventoryItemId"] = this.inventoryItemId;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["picDepartmentId"] = this.picDepartmentId;
        data["budgetCodeId"] = this.budgetCodeId;
        data["budgetCode"] = this.budgetCode;
        data["productCode"] = this.productCode;
        data["color"] = this.color;
        data["productName"] = this.productName;
        data["uom"] = this.uom;
        data["currencyId"] = this.currencyId;
        data["originalCurrencyId"] = this.originalCurrencyId;
        data["currencyCode"] = this.currencyCode;
        data["supplierId"] = this.supplierId;
        data["supplierName"] = this.supplierName;
        data["unitPrice"] = this.unitPrice;
        data["exchangeUnitPrice"] = this.exchangeUnitPrice;
        data["quantity"] = this.quantity;
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toString() : <any>undefined;
        data["monthN"] = this.monthN;
        data["monthN1"] = this.monthN1;
        data["monthN2"] = this.monthN2;
        data["monthN3"] = this.monthN3;
        data["lineNum"] = this.lineNum;
        data["totalCount"] = this.totalCount;
        data["id"] = this.id;
        return data;
    }
}

export interface IGetAllProductsForViewDto {
    inventoryItemId: number | undefined;
    inventoryGroupId: number | undefined;
    picDepartmentId: string | undefined;
    budgetCodeId: number | undefined;
    budgetCode: string | undefined;
    productCode: string | undefined;
    color: string | undefined;
    productName: string | undefined;
    uom: string | undefined;
    currencyId: number | undefined;
    originalCurrencyId: number | undefined;
    currencyCode: string | undefined;
    supplierId: number | undefined;
    supplierName: string | undefined;
    unitPrice: number;
    exchangeUnitPrice: number;
    quantity: number;
    deliveryDate: DateTime | undefined;
    monthN: number;
    monthN1: number;
    monthN2: number;
    monthN3: number;
    lineNum: number | undefined;
    totalCount: number;
    id: number;
}

export class PagedResultDtoOfGetAllProductsForViewDto implements IPagedResultDtoOfGetAllProductsForViewDto {
    totalCount!: number;
    items!: GetAllProductsForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAllProductsForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllProductsForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAllProductsForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAllProductsForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAllProductsForViewDto {
    totalCount: number;
    items: GetAllProductsForViewDto[] | undefined;
}

export class GetAllUserRequestAttachmentsForViewDto implements IGetAllUserRequestAttachmentsForViewDto {
    fileName!: string | undefined;
    serverFileName!: string | undefined;
    rootPath!: string | undefined;
    uploadTime!: DateTime;
    onSystem!: boolean;
    id!: number;

    constructor(data?: IGetAllUserRequestAttachmentsForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.serverFileName = _data["serverFileName"];
            this.rootPath = _data["rootPath"];
            this.uploadTime = _data["uploadTime"] ? DateTime.fromISO(_data["uploadTime"].toString()) : <any>undefined;
            this.onSystem = _data["onSystem"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAllUserRequestAttachmentsForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllUserRequestAttachmentsForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["serverFileName"] = this.serverFileName;
        data["rootPath"] = this.rootPath;
        data["uploadTime"] = this.uploadTime ? this.uploadTime.toString() : <any>undefined;
        data["onSystem"] = this.onSystem;
        data["id"] = this.id;
        return data;
    }
}

export interface IGetAllUserRequestAttachmentsForViewDto {
    fileName: string | undefined;
    serverFileName: string | undefined;
    rootPath: string | undefined;
    uploadTime: DateTime;
    onSystem: boolean;
    id: number;
}

export class GetUserRequestDetailForView implements IGetUserRequestDetailForView {
    userRequestName!: string | undefined;
    userRequestNumber!: string | undefined;
    picDepartmentId!: string | undefined;
    requestUser!: string | undefined;
    creatorUserId!: number | undefined;
    requestDate!: DateTime | undefined;
    departmentName!: string | undefined;
    inventoryGroupId!: number | undefined;
    supplierId!: number | undefined;
    currencyId!: number | undefined;
    originalCurrencyId!: number | undefined;
    expenseDepartmentId!: number | undefined;
    documentTypeId!: number | undefined;
    purchasePurposeId!: number | undefined;
    budgetCodeId!: number | undefined;
    budgetCode!: string | undefined;
    supplierName!: string | undefined;
    inventoryGroupName!: string | undefined;
    currencyName!: string | undefined;
    totalPrice!: number | undefined;
    originalTotalPrice!: number | undefined;
    checkBudgetStatus!: string | undefined;
    approvalStatus!: string | undefined;
    status!: string | undefined;
    note!: string | undefined;
    documentDate!: DateTime;
    requestNote!: string | undefined;
    replyNote!: string | undefined;
    products!: GetAllProductsForViewDto[] | undefined;
    attachments!: GetAllUserRequestAttachmentsForViewDto[] | undefined;
    id!: number;

    constructor(data?: IGetUserRequestDetailForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRequestName = _data["userRequestName"];
            this.userRequestNumber = _data["userRequestNumber"];
            this.picDepartmentId = _data["picDepartmentId"];
            this.requestUser = _data["requestUser"];
            this.creatorUserId = _data["creatorUserId"];
            this.requestDate = _data["requestDate"] ? DateTime.fromISO(_data["requestDate"].toString()) : <any>undefined;
            this.departmentName = _data["departmentName"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.supplierId = _data["supplierId"];
            this.currencyId = _data["currencyId"];
            this.originalCurrencyId = _data["originalCurrencyId"];
            this.expenseDepartmentId = _data["expenseDepartmentId"];
            this.documentTypeId = _data["documentTypeId"];
            this.purchasePurposeId = _data["purchasePurposeId"];
            this.budgetCodeId = _data["budgetCodeId"];
            this.budgetCode = _data["budgetCode"];
            this.supplierName = _data["supplierName"];
            this.inventoryGroupName = _data["inventoryGroupName"];
            this.currencyName = _data["currencyName"];
            this.totalPrice = _data["totalPrice"];
            this.originalTotalPrice = _data["originalTotalPrice"];
            this.checkBudgetStatus = _data["checkBudgetStatus"];
            this.approvalStatus = _data["approvalStatus"];
            this.status = _data["status"];
            this.note = _data["note"];
            this.documentDate = _data["documentDate"] ? DateTime.fromISO(_data["documentDate"].toString()) : <any>undefined;
            this.requestNote = _data["requestNote"];
            this.replyNote = _data["replyNote"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(GetAllProductsForViewDto.fromJS(item));
            }
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(GetAllUserRequestAttachmentsForViewDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetUserRequestDetailForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserRequestDetailForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRequestName"] = this.userRequestName;
        data["userRequestNumber"] = this.userRequestNumber;
        data["picDepartmentId"] = this.picDepartmentId;
        data["requestUser"] = this.requestUser;
        data["creatorUserId"] = this.creatorUserId;
        data["requestDate"] = this.requestDate ? this.requestDate.toString() : <any>undefined;
        data["departmentName"] = this.departmentName;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["supplierId"] = this.supplierId;
        data["currencyId"] = this.currencyId;
        data["originalCurrencyId"] = this.originalCurrencyId;
        data["expenseDepartmentId"] = this.expenseDepartmentId;
        data["documentTypeId"] = this.documentTypeId;
        data["purchasePurposeId"] = this.purchasePurposeId;
        data["budgetCodeId"] = this.budgetCodeId;
        data["budgetCode"] = this.budgetCode;
        data["supplierName"] = this.supplierName;
        data["inventoryGroupName"] = this.inventoryGroupName;
        data["currencyName"] = this.currencyName;
        data["totalPrice"] = this.totalPrice;
        data["originalTotalPrice"] = this.originalTotalPrice;
        data["checkBudgetStatus"] = this.checkBudgetStatus;
        data["approvalStatus"] = this.approvalStatus;
        data["status"] = this.status;
        data["note"] = this.note;
        data["documentDate"] = this.documentDate ? this.documentDate.toString() : <any>undefined;
        data["requestNote"] = this.requestNote;
        data["replyNote"] = this.replyNote;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IGetUserRequestDetailForView {
    userRequestName: string | undefined;
    userRequestNumber: string | undefined;
    picDepartmentId: string | undefined;
    requestUser: string | undefined;
    creatorUserId: number | undefined;
    requestDate: DateTime | undefined;
    departmentName: string | undefined;
    inventoryGroupId: number | undefined;
    supplierId: number | undefined;
    currencyId: number | undefined;
    originalCurrencyId: number | undefined;
    expenseDepartmentId: number | undefined;
    documentTypeId: number | undefined;
    purchasePurposeId: number | undefined;
    budgetCodeId: number | undefined;
    budgetCode: string | undefined;
    supplierName: string | undefined;
    inventoryGroupName: string | undefined;
    currencyName: string | undefined;
    totalPrice: number | undefined;
    originalTotalPrice: number | undefined;
    checkBudgetStatus: string | undefined;
    approvalStatus: string | undefined;
    status: string | undefined;
    note: string | undefined;
    documentDate: DateTime;
    requestNote: string | undefined;
    replyNote: string | undefined;
    products: GetAllProductsForViewDto[] | undefined;
    attachments: GetAllUserRequestAttachmentsForViewDto[] | undefined;
    id: number;
}

export class CreateOrEditUserRequestInputDto implements ICreateOrEditUserRequestInputDto {
    userRequestName!: string | undefined;
    userRequestNumber!: string | undefined;
    type!: number | undefined;
    expenseDepartmentId!: number | undefined;
    documentTypeId!: number | undefined;
    purchasePurposeId!: number | undefined;
    budgetCodeId!: number | undefined;
    requestDate!: DateTime;
    picDepartmentId!: string | undefined;
    inventoryGroupId!: number | undefined;
    supplierId!: number | undefined;
    currencyId!: number | undefined;
    originalCurrencyId!: number | undefined;
    originalCurrencyCode!: string | undefined;
    documentId!: number | undefined;
    purchaseOrganization!: string | undefined;
    totalPrice!: number | undefined;
    originalTotalPrice!: number | undefined;
    note!: string | undefined;
    documentDate!: DateTime | undefined;
    products!: GetAllProductsForViewDto[] | undefined;
    id!: number;

    constructor(data?: ICreateOrEditUserRequestInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRequestName = _data["userRequestName"];
            this.userRequestNumber = _data["userRequestNumber"];
            this.type = _data["type"];
            this.expenseDepartmentId = _data["expenseDepartmentId"];
            this.documentTypeId = _data["documentTypeId"];
            this.purchasePurposeId = _data["purchasePurposeId"];
            this.budgetCodeId = _data["budgetCodeId"];
            this.requestDate = _data["requestDate"] ? DateTime.fromISO(_data["requestDate"].toString()) : <any>undefined;
            this.picDepartmentId = _data["picDepartmentId"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.supplierId = _data["supplierId"];
            this.currencyId = _data["currencyId"];
            this.originalCurrencyId = _data["originalCurrencyId"];
            this.originalCurrencyCode = _data["originalCurrencyCode"];
            this.documentId = _data["documentId"];
            this.purchaseOrganization = _data["purchaseOrganization"];
            this.totalPrice = _data["totalPrice"];
            this.originalTotalPrice = _data["originalTotalPrice"];
            this.note = _data["note"];
            this.documentDate = _data["documentDate"] ? DateTime.fromISO(_data["documentDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(GetAllProductsForViewDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditUserRequestInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditUserRequestInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRequestName"] = this.userRequestName;
        data["userRequestNumber"] = this.userRequestNumber;
        data["type"] = this.type;
        data["expenseDepartmentId"] = this.expenseDepartmentId;
        data["documentTypeId"] = this.documentTypeId;
        data["purchasePurposeId"] = this.purchasePurposeId;
        data["budgetCodeId"] = this.budgetCodeId;
        data["requestDate"] = this.requestDate ? this.requestDate.toString() : <any>undefined;
        data["picDepartmentId"] = this.picDepartmentId;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["supplierId"] = this.supplierId;
        data["currencyId"] = this.currencyId;
        data["originalCurrencyId"] = this.originalCurrencyId;
        data["originalCurrencyCode"] = this.originalCurrencyCode;
        data["documentId"] = this.documentId;
        data["purchaseOrganization"] = this.purchaseOrganization;
        data["totalPrice"] = this.totalPrice;
        data["originalTotalPrice"] = this.originalTotalPrice;
        data["note"] = this.note;
        data["documentDate"] = this.documentDate ? this.documentDate.toString() : <any>undefined;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditUserRequestInputDto {
    userRequestName: string | undefined;
    userRequestNumber: string | undefined;
    type: number | undefined;
    expenseDepartmentId: number | undefined;
    documentTypeId: number | undefined;
    purchasePurposeId: number | undefined;
    budgetCodeId: number | undefined;
    requestDate: DateTime;
    picDepartmentId: string | undefined;
    inventoryGroupId: number | undefined;
    supplierId: number | undefined;
    currencyId: number | undefined;
    originalCurrencyId: number | undefined;
    originalCurrencyCode: string | undefined;
    documentId: number | undefined;
    purchaseOrganization: string | undefined;
    totalPrice: number | undefined;
    originalTotalPrice: number | undefined;
    note: string | undefined;
    documentDate: DateTime | undefined;
    products: GetAllProductsForViewDto[] | undefined;
    id: number;
}

export class PagedResultDtoOfGetAllUserRequestForPrDto implements IPagedResultDtoOfGetAllUserRequestForPrDto {
    totalCount!: number;
    items!: GetAllUserRequestForPrDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAllUserRequestForPrDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllUserRequestForPrDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAllUserRequestForPrDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAllUserRequestForPrDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAllUserRequestForPrDto {
    totalCount: number;
    items: GetAllUserRequestForPrDto[] | undefined;
}

export class CreateUserRequestFromExcelInput implements ICreateUserRequestFromExcelInput {
    inventoryGroupId!: number | undefined;
    picDepartmentId!: string | undefined;
    productId!: number | undefined;
    productName!: string | undefined;
    currencyId!: number | undefined;
    currencyCode!: string | undefined;
    supplierId!: number | undefined;
    unitPrice!: number | undefined;
    totalPrice!: number | undefined;
    uom!: string | undefined;
    monthN!: string | undefined;
    monthN1!: string | undefined;
    monthN2!: string | undefined;
    monthN3!: string | undefined;
    deliveries!: UserRequestDeliveryDto[] | undefined;

    constructor(data?: ICreateUserRequestFromExcelInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.picDepartmentId = _data["picDepartmentId"];
            this.productId = _data["productId"];
            this.productName = _data["productName"];
            this.currencyId = _data["currencyId"];
            this.currencyCode = _data["currencyCode"];
            this.supplierId = _data["supplierId"];
            this.unitPrice = _data["unitPrice"];
            this.totalPrice = _data["totalPrice"];
            this.uom = _data["uom"];
            this.monthN = _data["monthN"];
            this.monthN1 = _data["monthN1"];
            this.monthN2 = _data["monthN2"];
            this.monthN3 = _data["monthN3"];
            if (Array.isArray(_data["deliveries"])) {
                this.deliveries = [] as any;
                for (let item of _data["deliveries"])
                    this.deliveries!.push(UserRequestDeliveryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateUserRequestFromExcelInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserRequestFromExcelInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["picDepartmentId"] = this.picDepartmentId;
        data["productId"] = this.productId;
        data["productName"] = this.productName;
        data["currencyId"] = this.currencyId;
        data["currencyCode"] = this.currencyCode;
        data["supplierId"] = this.supplierId;
        data["unitPrice"] = this.unitPrice;
        data["totalPrice"] = this.totalPrice;
        data["uom"] = this.uom;
        data["monthN"] = this.monthN;
        data["monthN1"] = this.monthN1;
        data["monthN2"] = this.monthN2;
        data["monthN3"] = this.monthN3;
        if (Array.isArray(this.deliveries)) {
            data["deliveries"] = [];
            for (let item of this.deliveries)
                data["deliveries"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateUserRequestFromExcelInput {
    inventoryGroupId: number | undefined;
    picDepartmentId: string | undefined;
    productId: number | undefined;
    productName: string | undefined;
    currencyId: number | undefined;
    currencyCode: string | undefined;
    supplierId: number | undefined;
    unitPrice: number | undefined;
    totalPrice: number | undefined;
    uom: string | undefined;
    monthN: string | undefined;
    monthN1: string | undefined;
    monthN2: string | undefined;
    monthN3: string | undefined;
    deliveries: UserRequestDeliveryDto[] | undefined;
}

export class GetAllApprovalInfoForViewDto implements IGetAllApprovalInfoForViewDto {
    approvalSeq!: number | undefined;
    approvalUserName!: string | undefined;
    approvalUserDepartment!: string | undefined;
    approvalUserTitle!: string | undefined;
    leadTime!: DateTime | undefined;
    approvalDate!: DateTime | undefined;
    rejectDate!: DateTime | undefined;
    approvalStatus!: string | undefined;
    note!: string | undefined;
    dayOfProcess!: number;
    approvalUserId!: number | undefined;
    approvalTreeDetailId!: number | undefined;
    isBuyer!: boolean | undefined;
    id!: number;

    constructor(data?: IGetAllApprovalInfoForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.approvalSeq = _data["approvalSeq"];
            this.approvalUserName = _data["approvalUserName"];
            this.approvalUserDepartment = _data["approvalUserDepartment"];
            this.approvalUserTitle = _data["approvalUserTitle"];
            this.leadTime = _data["leadTime"] ? DateTime.fromISO(_data["leadTime"].toString()) : <any>undefined;
            this.approvalDate = _data["approvalDate"] ? DateTime.fromISO(_data["approvalDate"].toString()) : <any>undefined;
            this.rejectDate = _data["rejectDate"] ? DateTime.fromISO(_data["rejectDate"].toString()) : <any>undefined;
            this.approvalStatus = _data["approvalStatus"];
            this.note = _data["note"];
            this.dayOfProcess = _data["dayOfProcess"];
            this.approvalUserId = _data["approvalUserId"];
            this.approvalTreeDetailId = _data["approvalTreeDetailId"];
            this.isBuyer = _data["isBuyer"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAllApprovalInfoForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllApprovalInfoForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approvalSeq"] = this.approvalSeq;
        data["approvalUserName"] = this.approvalUserName;
        data["approvalUserDepartment"] = this.approvalUserDepartment;
        data["approvalUserTitle"] = this.approvalUserTitle;
        data["leadTime"] = this.leadTime ? this.leadTime.toString() : <any>undefined;
        data["approvalDate"] = this.approvalDate ? this.approvalDate.toString() : <any>undefined;
        data["rejectDate"] = this.rejectDate ? this.rejectDate.toString() : <any>undefined;
        data["approvalStatus"] = this.approvalStatus;
        data["note"] = this.note;
        data["dayOfProcess"] = this.dayOfProcess;
        data["approvalUserId"] = this.approvalUserId;
        data["approvalTreeDetailId"] = this.approvalTreeDetailId;
        data["isBuyer"] = this.isBuyer;
        data["id"] = this.id;
        return data;
    }
}

export interface IGetAllApprovalInfoForViewDto {
    approvalSeq: number | undefined;
    approvalUserName: string | undefined;
    approvalUserDepartment: string | undefined;
    approvalUserTitle: string | undefined;
    leadTime: DateTime | undefined;
    approvalDate: DateTime | undefined;
    rejectDate: DateTime | undefined;
    approvalStatus: string | undefined;
    note: string | undefined;
    dayOfProcess: number;
    approvalUserId: number | undefined;
    approvalTreeDetailId: number | undefined;
    isBuyer: boolean | undefined;
    id: number;
}

export class ExportUserRequestToExcelInput implements IExportUserRequestToExcelInput {
    isIncludeDetail!: boolean;
    userId!: number | undefined;
    inventoryGroupId!: number | undefined;
    status!: string | undefined;
    fromDate!: DateTime | undefined;
    toDate!: DateTime | undefined;

    constructor(data?: IExportUserRequestToExcelInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isIncludeDetail = _data["isIncludeDetail"];
            this.userId = _data["userId"];
            this.inventoryGroupId = _data["inventoryGroupId"];
            this.status = _data["status"];
            this.fromDate = _data["fromDate"] ? DateTime.fromISO(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? DateTime.fromISO(_data["toDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ExportUserRequestToExcelInput {
        data = typeof data === 'object' ? data : {};
        let result = new ExportUserRequestToExcelInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isIncludeDetail"] = this.isIncludeDetail;
        data["userId"] = this.userId;
        data["inventoryGroupId"] = this.inventoryGroupId;
        data["status"] = this.status;
        data["fromDate"] = this.fromDate ? this.fromDate.toString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toString() : <any>undefined;
        return data;
    }
}

export interface IExportUserRequestToExcelInput {
    isIncludeDetail: boolean;
    userId: number | undefined;
    inventoryGroupId: number | undefined;
    status: string | undefined;
    fromDate: DateTime | undefined;
    toDate: DateTime | undefined;
}

export class GetAllReferenceInfoForViewDto implements IGetAllReferenceInfoForViewDto {
    type!: string | undefined;
    referenceNum!: string | undefined;
    referenceLineNum!: number | undefined;
    lineNum!: number | undefined;

    constructor(data?: IGetAllReferenceInfoForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.referenceNum = _data["referenceNum"];
            this.referenceLineNum = _data["referenceLineNum"];
            this.lineNum = _data["lineNum"];
        }
    }

    static fromJS(data: any): GetAllReferenceInfoForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllReferenceInfoForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["referenceNum"] = this.referenceNum;
        data["referenceLineNum"] = this.referenceLineNum;
        data["lineNum"] = this.lineNum;
        return data;
    }
}

export interface IGetAllReferenceInfoForViewDto {
    type: string | undefined;
    referenceNum: string | undefined;
    referenceLineNum: number | undefined;
    lineNum: number | undefined;
}

export class GetUsersInput implements IGetUsersInput {
    filter!: string | undefined;
    permissions!: string[] | undefined;
    role!: number | undefined;
    onlyLockedUsers!: boolean;
    name!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IGetUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["filter"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            this.role = _data["role"];
            this.onlyLockedUsers = _data["onlyLockedUsers"];
            this.name = _data["name"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): GetUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["role"] = this.role;
        data["onlyLockedUsers"] = this.onlyLockedUsers;
        data["name"] = this.name;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data;
    }
}

export interface IGetUsersInput {
    filter: string | undefined;
    permissions: string[] | undefined;
    role: number | undefined;
    onlyLockedUsers: boolean;
    name: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId!: number;
    roleName!: string | undefined;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data;
    }
}

export interface IUserListRoleDto {
    roleId: number;
    roleName: string | undefined;
}

export class UserListDto implements IUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    profilePictureId!: string | undefined;
    isEmailConfirmed!: boolean;
    roles!: UserListRoleDto[] | undefined;
    isActive!: boolean;
    creationTime!: DateTime;
    id!: number;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.profilePictureId = _data["profilePictureId"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UserListRoleDto.fromJS(item));
            }
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["profilePictureId"] = this.profilePictureId;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    profilePictureId: string | undefined;
    isEmailConfirmed: boolean;
    roles: UserListRoleDto[] | undefined;
    isActive: boolean;
    creationTime: DateTime;
    id: number;
}

export class PagedResultDtoOfUserListDto implements IPagedResultDtoOfUserListDto {
    totalCount!: number;
    items!: UserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfUserListDto {
    totalCount: number;
    items: UserListDto[] | undefined;
}

export class UserEditDto implements IUserEditDto {
    id!: number | undefined;
    name!: string;
    surname!: string | undefined;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    password!: string | undefined;
    isActive!: boolean;
    shouldChangePasswordOnNextLogin!: boolean;
    isTwoFactorEnabled!: boolean;
    isLockoutEnabled!: boolean;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
            this.isActive = _data["isActive"];
            this.shouldChangePasswordOnNextLogin = _data["shouldChangePasswordOnNextLogin"];
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            this.isLockoutEnabled = _data["isLockoutEnabled"];
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        return data;
    }
}

export interface IUserEditDto {
    id: number | undefined;
    name: string;
    surname: string | undefined;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    password: string | undefined;
    isActive: boolean;
    shouldChangePasswordOnNextLogin: boolean;
    isTwoFactorEnabled: boolean;
    isLockoutEnabled: boolean;
}

export class UserRoleDto implements IUserRoleDto {
    roleId!: number;
    roleName!: string | undefined;
    roleDisplayName!: string | undefined;
    isAssigned!: boolean;
    inheritedFromOrganizationUnit!: boolean;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            this.roleDisplayName = _data["roleDisplayName"];
            this.isAssigned = _data["isAssigned"];
            this.inheritedFromOrganizationUnit = _data["inheritedFromOrganizationUnit"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        data["inheritedFromOrganizationUnit"] = this.inheritedFromOrganizationUnit;
        return data;
    }
}

export interface IUserRoleDto {
    roleId: number;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean;
    inheritedFromOrganizationUnit: boolean;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
    profilePictureId!: string | undefined;
    user!: UserEditDto;
    roles!: UserRoleDto[] | undefined;
    allOrganizationUnits!: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits!: string[] | undefined;

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.profilePictureId = _data["profilePictureId"];
            this.user = _data["user"] ? UserEditDto.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UserRoleDto.fromJS(item));
            }
            if (Array.isArray(_data["allOrganizationUnits"])) {
                this.allOrganizationUnits = [] as any;
                for (let item of _data["allOrganizationUnits"])
                    this.allOrganizationUnits!.push(OrganizationUnitDto.fromJS(item));
            }
            if (Array.isArray(_data["memberedOrganizationUnits"])) {
                this.memberedOrganizationUnits = [] as any;
                for (let item of _data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits!.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.allOrganizationUnits)) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (Array.isArray(this.memberedOrganizationUnits)) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        return data;
    }
}

export interface IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
    id!: number;

    constructor(data?: IEntityDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityDtoOfInt64 {
    id: number;
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id!: number;
    grantedPermissionNames!: string[];

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissionNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface IUpdateUserPermissionsInput {
    id: number;
    grantedPermissionNames: string[];
}

export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    user!: UserEditDto;
    assignedRoleNames!: string[];
    sendActivationEmail!: boolean;
    setRandomPassword!: boolean;
    organizationUnits!: number[] | undefined;

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEditDto();
            this.assignedRoleNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserEditDto.fromJS(_data["user"]) : new UserEditDto();
            if (Array.isArray(_data["assignedRoleNames"])) {
                this.assignedRoleNames = [] as any;
                for (let item of _data["assignedRoleNames"])
                    this.assignedRoleNames!.push(item);
            }
            this.sendActivationEmail = _data["sendActivationEmail"];
            this.setRandomPassword = _data["setRandomPassword"];
            if (Array.isArray(_data["organizationUnits"])) {
                this.organizationUnits = [] as any;
                for (let item of _data["organizationUnits"])
                    this.organizationUnits!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.assignedRoleNames)) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["setRandomPassword"] = this.setRandomPassword;
        if (Array.isArray(this.organizationUnits)) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item);
        }
        return data;
    }
}

export interface ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    sendActivationEmail: boolean;
    setRandomPassword: boolean;
    organizationUnits: number[] | undefined;
}

export class UserDelegationDto implements IUserDelegationDto {
    username!: string | undefined;
    startTime!: DateTime;
    endTime!: DateTime;
    id!: number;

    constructor(data?: IUserDelegationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDelegationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDelegationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserDelegationDto {
    username: string | undefined;
    startTime: DateTime;
    endTime: DateTime;
    id: number;
}

export class PagedResultDtoOfUserDelegationDto implements IPagedResultDtoOfUserDelegationDto {
    totalCount!: number;
    items!: UserDelegationDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserDelegationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserDelegationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDelegationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserDelegationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfUserDelegationDto {
    totalCount: number;
    items: UserDelegationDto[] | undefined;
}

export class CreateUserDelegationDto implements ICreateUserDelegationDto {
    targetUserId!: number;
    startTime!: DateTime;
    endTime!: DateTime;

    constructor(data?: ICreateUserDelegationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetUserId = _data["targetUserId"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateUserDelegationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDelegationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetUserId"] = this.targetUserId;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        return data;
    }
}

export interface ICreateUserDelegationDto {
    targetUserId: number;
    startTime: DateTime;
    endTime: DateTime;
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName!: string | undefined;
    usernameOrEmailAddress!: string;
    password!: string;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.usernameOrEmailAddress = _data["usernameOrEmailAddress"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data;
    }
}

export interface ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string;
    password: string;
}

export class LinkedUserDto implements ILinkedUserDto {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    username!: string | undefined;
    id!: number;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.tenancyName = _data["tenancyName"];
            this.username = _data["username"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["username"] = this.username;
        data["id"] = this.id;
        return data;
    }
}

export interface ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    id: number;
}

export class PagedResultDtoOfLinkedUserDto implements IPagedResultDtoOfLinkedUserDto {
    totalCount!: number;
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfLinkedUserDto {
    totalCount: number;
    items: LinkedUserDto[] | undefined;
}

export class ListResultDtoOfLinkedUserDto implements IListResultDtoOfLinkedUserDto {
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IListResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId!: number | undefined;
    userId!: number;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName!: string | undefined;
    userNameOrEmail!: string | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    result!: string | undefined;
    creationTime!: DateTime;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.userNameOrEmail = _data["userNameOrEmail"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.browserInfo = _data["browserInfo"];
            this.result = _data["result"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmail"] = this.userNameOrEmail;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        return data;
    }
}

export interface IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmail: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: DateTime;
}

export class ListResultDtoOfUserLoginAttemptDto implements IListResultDtoOfUserLoginAttemptDto {
    items!: UserLoginAttemptDto[] | undefined;

    constructor(data?: IListResultDtoOfUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;
}

export class WebhookEvent implements IWebhookEvent {
    webhookName!: string;
    data!: string | undefined;
    creationTime!: DateTime;
    tenantId!: number | undefined;
    isDeleted!: boolean;
    deletionTime!: DateTime | undefined;
    id!: string;

    constructor(data?: IWebhookEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.webhookName = _data["webhookName"];
            this.data = _data["data"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.isDeleted = _data["isDeleted"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WebhookEvent {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webhookName"] = this.webhookName;
        data["data"] = this.data;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["isDeleted"] = this.isDeleted;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IWebhookEvent {
    webhookName: string;
    data: string | undefined;
    creationTime: DateTime;
    tenantId: number | undefined;
    isDeleted: boolean;
    deletionTime: DateTime | undefined;
    id: string;
}

export enum HttpStatusCode {
    Continue = 100,
    SwitchingProtocols = 101,
    Processing = 102,
    EarlyHints = 103,
    OK = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritativeInformation = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultiStatus = 207,
    AlreadyReported = 208,
    IMUsed = 226,
    MultipleChoices = 300,
    Ambiguous = 301,
    MovedPermanently = 302,
    Moved = 303,
    Found = 304,
    Redirect = 305,
    SeeOther = 306,
    RedirectMethod = 307,
    NotModified = 308,
    UseProxy = 400,
    Unused = 401,
    TemporaryRedirect = 402,
    RedirectKeepVerb = 403,
    PermanentRedirect = 404,
    BadRequest = 405,
    Unauthorized = 406,
    PaymentRequired = 407,
    Forbidden = 408,
    NotFound = 409,
    MethodNotAllowed = 410,
    NotAcceptable = 411,
    ProxyAuthenticationRequired = 412,
    RequestTimeout = 413,
    Conflict = 414,
    Gone = 415,
    LengthRequired = 416,
    PreconditionFailed = 417,
    RequestEntityTooLarge = 421,
    RequestUriTooLong = 422,
    UnsupportedMediaType = 423,
    RequestedRangeNotSatisfiable = 424,
    ExpectationFailed = 426,
    MisdirectedRequest = 428,
    UnprocessableEntity = 429,
    Locked = 431,
    FailedDependency = 451,
    UpgradeRequired = 500,
    PreconditionRequired = 501,
    TooManyRequests = 502,
    RequestHeaderFieldsTooLarge = 503,
    UnavailableForLegalReasons = 504,
    InternalServerError = 505,
    NotImplemented = 506,
    BadGateway = 507,
    ServiceUnavailable = 508,
    GatewayTimeout = 510,
    HttpVersionNotSupported = 511,
}

export class GetAllSendAttemptsOutput implements IGetAllSendAttemptsOutput {
    id!: string;
    webhookEventId!: string;
    webhookName!: string | undefined;
    data!: string | undefined;
    response!: string | undefined;
    responseStatusCode!: HttpStatusCode;
    creationTime!: DateTime;

    constructor(data?: IGetAllSendAttemptsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.webhookEventId = _data["webhookEventId"];
            this.webhookName = _data["webhookName"];
            this.data = _data["data"];
            this.response = _data["response"];
            this.responseStatusCode = _data["responseStatusCode"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAllSendAttemptsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSendAttemptsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["webhookEventId"] = this.webhookEventId;
        data["webhookName"] = this.webhookName;
        data["data"] = this.data;
        data["response"] = this.response;
        data["responseStatusCode"] = this.responseStatusCode;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        return data;
    }
}

export interface IGetAllSendAttemptsOutput {
    id: string;
    webhookEventId: string;
    webhookName: string | undefined;
    data: string | undefined;
    response: string | undefined;
    responseStatusCode: HttpStatusCode;
    creationTime: DateTime;
}

export class PagedResultDtoOfGetAllSendAttemptsOutput implements IPagedResultDtoOfGetAllSendAttemptsOutput {
    totalCount!: number;
    items!: GetAllSendAttemptsOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAllSendAttemptsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllSendAttemptsOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAllSendAttemptsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAllSendAttemptsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAllSendAttemptsOutput {
    totalCount: number;
    items: GetAllSendAttemptsOutput[] | undefined;
}

export class GetAllSendAttemptsOfWebhookEventOutput implements IGetAllSendAttemptsOfWebhookEventOutput {
    id!: string;
    webhookUri!: string | undefined;
    webhookSubscriptionId!: string;
    response!: string | undefined;
    responseStatusCode!: HttpStatusCode;
    creationTime!: DateTime;
    lastModificationTime!: DateTime | undefined;

    constructor(data?: IGetAllSendAttemptsOfWebhookEventOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.webhookUri = _data["webhookUri"];
            this.webhookSubscriptionId = _data["webhookSubscriptionId"];
            this.response = _data["response"];
            this.responseStatusCode = _data["responseStatusCode"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAllSendAttemptsOfWebhookEventOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSendAttemptsOfWebhookEventOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["webhookUri"] = this.webhookUri;
        data["webhookSubscriptionId"] = this.webhookSubscriptionId;
        data["response"] = this.response;
        data["responseStatusCode"] = this.responseStatusCode;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        return data;
    }
}

export interface IGetAllSendAttemptsOfWebhookEventOutput {
    id: string;
    webhookUri: string | undefined;
    webhookSubscriptionId: string;
    response: string | undefined;
    responseStatusCode: HttpStatusCode;
    creationTime: DateTime;
    lastModificationTime: DateTime | undefined;
}

export class ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput implements IListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput {
    items!: GetAllSendAttemptsOfWebhookEventOutput[] | undefined;

    constructor(data?: IListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllSendAttemptsOfWebhookEventOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput {
    items: GetAllSendAttemptsOfWebhookEventOutput[] | undefined;
}

export class GetAllSubscriptionsOutput implements IGetAllSubscriptionsOutput {
    webhookUri!: string | undefined;
    isActive!: boolean;
    webhooks!: string[] | undefined;
    id!: string;

    constructor(data?: IGetAllSubscriptionsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.webhookUri = _data["webhookUri"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["webhooks"])) {
                this.webhooks = [] as any;
                for (let item of _data["webhooks"])
                    this.webhooks!.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAllSubscriptionsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSubscriptionsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webhookUri"] = this.webhookUri;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.webhooks)) {
            data["webhooks"] = [];
            for (let item of this.webhooks)
                data["webhooks"].push(item);
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IGetAllSubscriptionsOutput {
    webhookUri: string | undefined;
    isActive: boolean;
    webhooks: string[] | undefined;
    id: string;
}

export class ListResultDtoOfGetAllSubscriptionsOutput implements IListResultDtoOfGetAllSubscriptionsOutput {
    items!: GetAllSubscriptionsOutput[] | undefined;

    constructor(data?: IListResultDtoOfGetAllSubscriptionsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllSubscriptionsOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllSubscriptionsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllSubscriptionsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfGetAllSubscriptionsOutput {
    items: GetAllSubscriptionsOutput[] | undefined;
}

export class WebhookSubscription implements IWebhookSubscription {
    tenantId!: number | undefined;
    webhookUri!: string | undefined;
    secret!: string | undefined;
    isActive!: boolean;
    webhooks!: string[] | undefined;
    headers!: { [key: string]: string; } | undefined;
    id!: string;

    constructor(data?: IWebhookSubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.webhookUri = _data["webhookUri"];
            this.secret = _data["secret"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["webhooks"])) {
                this.webhooks = [] as any;
                for (let item of _data["webhooks"])
                    this.webhooks!.push(item);
            }
            if (_data["headers"]) {
                this.headers = {} as any;
                for (let key in _data["headers"]) {
                    if (_data["headers"].hasOwnProperty(key))
                        (<any>this.headers)![key] = _data["headers"][key];
                }
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WebhookSubscription {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookSubscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["webhookUri"] = this.webhookUri;
        data["secret"] = this.secret;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.webhooks)) {
            data["webhooks"] = [];
            for (let item of this.webhooks)
                data["webhooks"].push(item);
        }
        if (this.headers) {
            data["headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    (<any>data["headers"])[key] = (<any>this.headers)[key];
            }
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IWebhookSubscription {
    tenantId: number | undefined;
    webhookUri: string | undefined;
    secret: string | undefined;
    isActive: boolean;
    webhooks: string[] | undefined;
    headers: { [key: string]: string; } | undefined;
    id: string;
}

export class ActivateWebhookSubscriptionInput implements IActivateWebhookSubscriptionInput {
    subscriptionId!: string;
    isActive!: boolean;

    constructor(data?: IActivateWebhookSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionId = _data["subscriptionId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ActivateWebhookSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateWebhookSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionId"] = this.subscriptionId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IActivateWebhookSubscriptionInput {
    subscriptionId: string;
    isActive: boolean;
}

export class GetAllAvailableWebhooksOutput implements IGetAllAvailableWebhooksOutput {
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IGetAllAvailableWebhooksOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GetAllAvailableWebhooksOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllAvailableWebhooksOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }
}

export interface IGetAllAvailableWebhooksOutput {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class ListResultDtoOfGetAllAvailableWebhooksOutput implements IListResultDtoOfGetAllAvailableWebhooksOutput {
    items!: GetAllAvailableWebhooksOutput[] | undefined;

    constructor(data?: IListResultDtoOfGetAllAvailableWebhooksOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllAvailableWebhooksOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllAvailableWebhooksOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllAvailableWebhooksOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfGetAllAvailableWebhooksOutput {
    items: GetAllAvailableWebhooksOutput[] | undefined;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines!: string[] | undefined;

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["latestWebLogLines"])) {
                this.latestWebLogLines = [] as any;
                for (let item of _data["latestWebLogLines"])
                    this.latestWebLogLines!.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.latestWebLogLines)) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data;
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;
}

export class AdditionalData implements IAdditionalData {
    paypal!: { [key: string]: string; };
    stripe!: { [key: string]: string; };

    [key: string]: any;

    constructor(data?: IAdditionalData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["Paypal"]) {
                this.paypal = {} as any;
                for (let key in _data["Paypal"]) {
                    if (_data["Paypal"].hasOwnProperty(key))
                        (<any>this.paypal)![key] = _data["Paypal"][key];
                }
            }
            if (_data["Stripe"]) {
                this.stripe = {} as any;
                for (let key in _data["Stripe"]) {
                    if (_data["Stripe"].hasOwnProperty(key))
                        (<any>this.stripe)![key] = _data["Stripe"][key];
                }
            }
        }
    }

    static fromJS(data: any): AdditionalData {
        data = typeof data === 'object' ? data : {};
        let result = new AdditionalData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.paypal) {
            data["Paypal"] = {};
            for (let key in this.paypal) {
                if (this.paypal.hasOwnProperty(key))
                    (<any>data["Paypal"])[key] = (<any>this.paypal)[key];
            }
        }
        if (this.stripe) {
            data["Stripe"] = {};
            for (let key in this.stripe) {
                if (this.stripe.hasOwnProperty(key))
                    (<any>data["Stripe"])[key] = (<any>this.stripe)[key];
            }
        }
        return data;
    }
}

export interface IAdditionalData {
    paypal: { [key: string]: string; };
    stripe: { [key: string]: string; };

    [key: string]: any;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}